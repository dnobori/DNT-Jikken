// Auto generated by IPA Box Test
using System;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219

public static unsafe class VCode
{
public static void CodeMain(VCpuState state)
{
uint eax = state.Eax; ref ushort al = ref *((ushort*)(&eax) + 0); ref ushort ah = ref *((ushort*)(&eax) + 1);
uint ebx = state.Ebx; ref ushort bl = ref *((ushort*)(&ebx) + 0); ref ushort bh = ref *((ushort*)(&ebx) + 1);
uint ecx = state.Ecx; ref ushort cl = ref *((ushort*)(&ecx) + 0); ref ushort ch = ref *((ushort*)(&ecx) + 1);
uint edx = state.Edx; ref ushort dl = ref *((ushort*)(&edx) + 0); ref ushort dh = ref *((ushort*)(&edx) + 1);
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint esp = state.Esp; 
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
uint compare_result = 0;
VMemory Memory = state.Memory;
VPageTableEntry* pte = Memory.PageTableEntry;

// 8048460 push %edi
L_8048460:
{
esp -= 4;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = "Access violation at 0x8048460.";
    exception_address = 0x8048460;
    goto L_RETURN;
}
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = "Access violation at 0x8048460.";
        exception_address = 0x8048460;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = edi;
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = edi;
}

}

// 8048461 push %esi
L_8048461:
{
esp -= 4;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = "Access violation at 0x8048461.";
    exception_address = 0x8048461;
    goto L_RETURN;
}
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = "Access violation at 0x8048461.";
        exception_address = 0x8048461;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = esi;
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = esi;
}

}

// 8048462 xor %edi,%edi
L_8048462:
{
edi ^= edi;
}

// 8048464 mov 0x804a020,%esi
L_8048464:
{
uint vaddr = ( +0x804a020);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = "Access violation at 0x8048464.";
    exception_address = 0x8048464;
    goto L_RETURN;
}
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = "Access violation at 0x8048464.";
        exception_address = 0x8048464;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    esi = get_value;
}
else
{
    esi = *((uint *)realaddr1);
}

}

// 804846a push %ebx
L_804846a:
{
esp -= 4;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = "Access violation at 0x804846a.";
    exception_address = 0x804846a;
    goto L_RETURN;
}
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = "Access violation at 0x804846a.";
        exception_address = 0x804846a;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = ebx;
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = ebx;
}

}

// 804846b mov $0x3,%ebx
L_804846b:
{
ebx = ( +0x3);
}

// 8048470 test $0x1,%bl
L_8048470:
{
compare_result = (uint)(bl & ( +0x1));
}

// 8048473 je 8048499 <test_target1+0x39>
L_8048473:
{
}

// 8048475 mov $0x2,%ecx
L_8048475:
{
ecx = ( +0x2);
}

// 804847a jmp 804848a <test_target1+0x2a>
L_804847a:
{
}

// 804847c lea 0x0(%esi,%eiz,1),%esi
L_804847c:
{
}

// 8048480 xor %edx,%edx
L_8048480:
{
edx ^= edx;
}

// 8048482 mov %ebx,%eax
L_8048482:
{
eax = ebx;
}

// 8048484 div %ecx
L_8048484:
{
}

// 8048486 test %edx,%edx
L_8048486:
{
compare_result = (uint)(edx & edx);
}

// 8048488 je 8048499 <test_target1+0x39>
L_8048488:
{
}

// 804848a add $0x1,%ecx
L_804848a:
{
}

// 804848d cmp %ebx,%ecx
L_804848d:
{
}

// 804848f jne 8048480 <test_target1+0x20>
L_804848f:
{
}

// 8048491 add $0x1,%esi
L_8048491:
{
}

// 8048494 mov $0x1,%edi
L_8048494:
{
edi = ( +0x1);
}

// 8048499 add $0x1,%ebx
L_8048499:
{
}

// 804849c cmp $0x4e21,%ebx
L_804849c:
{
}

// 80484a2 jne 8048470 <test_target1+0x10>
L_80484a2:
{
}

// 80484a4 mov %edi,%eax
L_80484a4:
{
eax = edi;
}

// 80484a6 movl $0x4e21,0x804a024
L_80484a6:
{
}

// 80484b0 test %al,%al
L_80484b0:
{
compare_result = (uint)(al & al);
}

// 80484b2 jne 80484ba <test_target1+0x5a>
L_80484b2:
{
}

// 80484b4 mov %esi,%eax
L_80484b4:
{
eax = esi;
}

// 80484b6 pop %ebx
L_80484b6:
{
}

// 80484b7 pop %esi
L_80484b7:
{
}

// 80484b8 pop %edi
L_80484b8:
{
}

// 80484ba mov %esi,0x804a020
L_80484ba:
{
}

// 80484c0 jmp 80484b4 <test_target1+0x54>
L_80484c0:
{
}

// 80484c2 xchg %ax,%ax
L_80484c2:
{
}

// 80484c4 xchg %ax,%ax
L_80484c4:
{
}

// 80484c6 xchg %ax,%ax
L_80484c6:
{
}

// 80484c8 xchg %ax,%ax
L_80484c8:
{
}

// 80484ca xchg %ax,%ax
L_80484ca:
{
}

// 80484cc xchg %ax,%ax
L_80484cc:
{
}

// 80484ce xchg %ax,%ax
L_80484ce:
{
}

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}
}

