// Auto generated by IPA Box Test for CSharp
using System;
using System.Runtime.CompilerServices;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219, CS1717, CS0162, CS0168

public static unsafe class VCode
{
public enum CallRetAddress {
    _MagicReturn,
    _0xb60,
    _0xbb5,
}

public static void Iam_The_IntelCPU_HaHaHa(VCpuState state, uint ip)
{
uint eax = state.Eax;
uint ebx = state.Ebx;
uint ecx = state.Ecx;
uint edx = state.Edx;
uint esp = state.Esp; 
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint cache_last_page1 = 0xffffffff;
uint last_used_cache = 0;
byte *cache_last_realaddr1 = null;
uint cache_last_page2 = 0xffffffff;
byte *cache_last_realaddr2 = null;
uint vaddr = 0, vaddr1_index = 0, vaddr1_offset = 0;
uint write_tmp = 0, read_tmp = 0;
uint compare_result = 0;
VMemory Memory = state.Memory;
VPageTableEntry* pte = Memory.PageTableEntry;
byte *cont_memory = Memory.ContiguousMemory;
uint cont_start = Memory.ContiguousStart;
uint cont_end = Memory.ContiguousEnd;
byte *cont_memory_minus_start = (byte *)(Memory.ContiguousMemory - cont_start);
uint next_ip = ip;
CallRetAddress next_return = (CallRetAddress)0x7fffffff;
ref ushort al = ref *((ushort*)(&eax) + 0); ref ushort ah = ref *((ushort*)(&eax) + 1);
ref ushort bl = ref *((ushort*)(&ebx) + 0); ref ushort bh = ref *((ushort*)(&ebx) + 1);
ref ushort cl = ref *((ushort*)(&ecx) + 0); ref ushort ch = ref *((ushort*)(&ecx) + 1);
ref ushort dl = ref *((ushort*)(&edx) + 0); ref ushort dh = ref *((ushort*)(&edx) + 1);
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
byte *realaddr1 = null;
uint memcache_esp_0x0_pin = 0x7fffffff; uint memcache_esp_0x0_data = 0xcafebeef;
uint memcache_esp_0xc_pin = 0x7fffffff; uint memcache_esp_0xc_data = 0xcafebeef;
uint memcache_esp_0x10_pin = 0x7fffffff; uint memcache_esp_0x10_data = 0xcafebeef;
uint memcache_esp_0x18_pin = 0x7fffffff; uint memcache_esp_0x18_data = 0xcafebeef;


L_START:
switch (next_ip)
{
case 0xa70: goto L_a70;
case 0xad0: goto L_ad0;
case 0xb40: goto L_b40;
case 0xba0: goto L_ba0;
default:
    exception_string = "Invalid jump target.";
    exception_address = next_ip;
    goto L_RETURN;
}

L_RET_FROM_CALL:
switch (next_return)
{
case CallRetAddress._MagicReturn: goto L_RETURN;
case CallRetAddress._0xb60: goto L_b60;
case CallRetAddress._0xbb5: goto L_bb5;
default:
    exception_string = "Invalid call return target.";
    exception_address = next_ip;
    goto L_RETURN;
}

// function test_target1();
// a70 push %esi
L_a70:
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xa70;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = esi;

}

// a71 push %ebx
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xa71;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ebx;

}

// a72 xor %esi,%esi
{
esi = 0;
}

// a74 mov $0x3,%ebx
{
ebx = ( +0x3);
}

// a79 sub $0x10,%esp
{
esp -= ( +0x10);
compare_result = esp;
}

// a7c movl $0x4e20,0xc(%esp)
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xa7c;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ( +0x4e20);

}

// a84 mov 0xc(%esp),%eax
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xa84;
    goto L_RETURN;
}
#endif // !NO_CHECK
eax= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// a88 cmp $0x2,%eax
{
compare_result = (uint)(eax - ( +0x2));
}

// a8b jbe ac7 <test_target1+0x57>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_ac7;
}
}

// a8d lea 0x0(%esi),%esi
{
esi = esi;
}

// a90 cmp $0x2,%ebx
L_a90:
{
compare_result = (uint)(ebx - ( +0x2));
}

// a93 jbe ab9 <test_target1+0x49>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_ab9;
}
}

// a95 test $0x1,%bl
{
compare_result = (uint)(bl & ( +0x1));
}

// a98 je abc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_abc;
}
}

// a9a mov $0x2,%ecx
{
ecx = ( +0x2);
}

// a9f jmp ab2 <test_target1+0x42>
{
if (true) {
    goto L_ab2;
}
}

// aa1 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// aa8 xor %edx,%edx
L_aa8:
{
edx = 0;
}

// aaa mov %ebx,%eax
{
eax = ebx;
}

// aac div %ecx
{
if (edx != 0) {
ulong tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
ulong tmp2 = ecx;
eax = (uint)(tmp1 / tmp2);
edx = (uint)(tmp1 - tmp2 * eax);
} else
{ 
uint tmp1 = eax;
uint tmp2 = ecx;
eax = tmp1 / tmp2;
edx = tmp1 - tmp2 * eax;
}
}

// aae test %edx,%edx
{
compare_result = (uint)(edx);
}

// ab0 je abc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_abc;
}
}

// ab2 add $0x1,%ecx
L_ab2:
{
ecx += ( +0x1);
compare_result = ecx;
}

// ab5 cmp %ebx,%ecx
{
compare_result = (uint)(ecx - ebx);
}

// ab7 jne aa8 <test_target1+0x38>
{
if (compare_result != 0) {
    goto L_aa8;
}
}

// ab9 add $0x1,%esi
L_ab9:
{
esi += ( +0x1);
compare_result = esi;
}

// abc mov 0xc(%esp),%eax
L_abc:
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xabc;
    goto L_RETURN;
}
#endif // !NO_CHECK
eax= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// ac0 add $0x1,%ebx
{
ebx += ( +0x1);
compare_result = ebx;
}

// ac3 cmp %ebx,%eax
{
compare_result = (uint)(eax - ebx);
}

// ac5 jae a90 <test_target1+0x20>
{
if (compare_result <= 0x80000000) {
    goto L_a90;
}
}

// ac7 add $0x10,%esp
L_ac7:
{
esp += ( +0x10);
compare_result = esp;
}

// aca mov %esi,%eax
{
eax = esi;
}

// acc pop %ebx
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xacc;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// acd pop %esi
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xacd;
    goto L_RETURN;
}
#endif // !NO_CHECK
esi= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// ace ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xace;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// acf nop 
{
}

// function test_target2();
// ad0 push %esi
L_ad0:
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xad0;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = esi;

}

// ad1 push %ebx
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xad1;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ebx;

}

// ad2 sub $0x1f50,%esp
{
esp -= ( +0x1f50);
compare_result = esp;
}

// ad8 movl $0x7d0,0xc(%esp)
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xad8;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ( +0x7d0);

}

// ae0 mov 0xc(%esp),%eax
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xae0;
    goto L_RETURN;
}
#endif // !NO_CHECK
eax= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// ae4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// ae6 je afe <test_target2+0x2e>
{
if (compare_result == 0) {
    goto L_afe;
}
}

// ae8 lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// aec xor %eax,%eax
{
eax = 0;
}

// aee xchg %ax,%ax
{
}

// af0 mov 0xc(%esp),%edx
L_af0:
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xaf0;
    goto L_RETURN;
}
#endif // !NO_CHECK
edx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// af4 mov %eax,(%ebx,%eax,4)
{
vaddr = (ebx + eax * 0x4);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xaf4;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = eax;

}

// af7 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// afa cmp %eax,%edx
{
compare_result = (uint)(edx - eax);
}

// afc ja af0 <test_target2+0x20>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_af0;
}
}

// afe mov $0xc350,%esi
L_afe:
{
esi = ( +0xc350);
}

// b03 xor %eax,%eax
{
eax = 0;
}

// b05 lea 0x0(%esi),%esi
{
esi = esi;
}

// b08 mov 0xc(%esp),%ecx
L_b08:
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb08;
    goto L_RETURN;
}
#endif // !NO_CHECK
ecx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// b0c xor %edx,%edx
{
edx = 0;
}

// b0e lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// b12 test %ecx,%ecx
{
compare_result = (uint)(ecx);
}

// b14 je b2e <test_target2+0x5e>
{
if (compare_result == 0) {
    goto L_b2e;
}
}

// b16 lea 0x0(%esi),%esi
{
esi = esi;
}

// b19 lea 0x0(%edi,%eiz,1),%edi
{
edi = (edi + eiz * 0x1);
}

// b20 mov 0xc(%esp),%ecx
L_b20:
{
vaddr = (esp +0xc);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb20;
    goto L_RETURN;
}
#endif // !NO_CHECK
ecx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// b24 add (%ebx,%edx,4),%eax
{
vaddr = (ebx + edx * 0x4);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb24;
    goto L_RETURN;
}
#endif // !NO_CHECK
eax+= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

compare_result = eax;
}

// b27 add $0x1,%edx
{
edx += ( +0x1);
compare_result = edx;
}

// b2a cmp %edx,%ecx
{
compare_result = (uint)(ecx - edx);
}

// b2c ja b20 <test_target2+0x50>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_b20;
}
}

// b2e sub $0x1,%esi
L_b2e:
{
esi -= ( +0x1);
compare_result = esi;
}

// b31 jne b08 <test_target2+0x38>
{
if (compare_result != 0) {
    goto L_b08;
}
}

// b33 add $0x1f50,%esp
{
esp += ( +0x1f50);
compare_result = esp;
}

// b39 pop %ebx
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb39;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b3a pop %esi
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb3a;
    goto L_RETURN;
}
#endif // !NO_CHECK
esi= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b3b ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb3b;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// b3c lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// function test_target4();
// b40 push %esi
L_b40:
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb40;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = esi;

}

// b41 push %ebx
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb41;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ebx;

}

// b42 sub $0x4,%esp
{
esp -= ( +0x4);
compare_result = esp;
}

// b45 mov 0x10(%esp),%ebx
{
vaddr = (esp +0x10);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb45;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// b49 test %ebx,%ebx
{
compare_result = (uint)(ebx);
}

// b4b je b80 <test_target4+0x40>
{
if (compare_result == 0) {
    goto L_b80;
}
}

// b4d cmp $0x1,%ebx
{
compare_result = (uint)(ebx - ( +0x1));
}

// b50 je b90 <test_target4+0x50>
{
if (compare_result == 0) {
    goto L_b90;
}
}

// b52 xor %esi,%esi
{
esi = 0;
}

// b54 lea -0x1(%ebx),%eax
L_b54:
{
eax = (ebx -0x1);
}

// b57 sub $0xc,%esp
{
esp -= ( +0xc);
compare_result = esp;
}

// b5a push %eax
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb5a;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = eax;

}

// b5b call b40 <test_target4>
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb5b;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = (uint)CallRetAddress._0xb60;

if (true) {
    goto L_b40;
}
}

// b60 add $0x10,%esp
L_b60:
{
esp += ( +0x10);
compare_result = esp;
}

// b63 add %eax,%esi
{
esi += eax;
compare_result = esi;
}

// b65 sub $0x2,%ebx
{
ebx -= ( +0x2);
compare_result = ebx;
}

// b68 je b72 <test_target4+0x32>
{
if (compare_result == 0) {
    goto L_b72;
}
}

// b6a cmp $0x1,%ebx
{
compare_result = (uint)(ebx - ( +0x1));
}

// b6d jne b54 <test_target4+0x14>
{
if (compare_result != 0) {
    goto L_b54;
}
}

// b6f add $0x1,%esi
{
esi += ( +0x1);
compare_result = esi;
}

// b72 add $0x4,%esp
L_b72:
{
esp += ( +0x4);
compare_result = esp;
}

// b75 mov %esi,%eax
{
eax = esi;
}

// b77 pop %ebx
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb77;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b78 pop %esi
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb78;
    goto L_RETURN;
}
#endif // !NO_CHECK
esi= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b79 ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb79;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// b7a lea 0x0(%esi),%esi
{
esi = esi;
}

// b80 xor %esi,%esi
L_b80:
{
esi = 0;
}

// b82 add $0x4,%esp
{
esp += ( +0x4);
compare_result = esp;
}

// b85 mov %esi,%eax
{
eax = esi;
}

// b87 pop %ebx
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb87;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b88 pop %esi
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb88;
    goto L_RETURN;
}
#endif // !NO_CHECK
esi= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b89 ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb89;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// b8a lea 0x0(%esi),%esi
{
esi = esi;
}

// b90 mov $0x1,%esi
L_b90:
{
esi = ( +0x1);
}

// b95 add $0x4,%esp
{
esp += ( +0x4);
compare_result = esp;
}

// b98 mov %esi,%eax
{
eax = esi;
}

// b9a pop %ebx
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb9a;
    goto L_RETURN;
}
#endif // !NO_CHECK
ebx= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b9b pop %esi
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb9b;
    goto L_RETURN;
}
#endif // !NO_CHECK
esi= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
}

// b9c ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xb9c;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// b9d lea 0x0(%esi),%esi
{
esi = esi;
}

// function test_target3();
// ba0 sub $0x28,%esp
L_ba0:
{
esp -= ( +0x28);
compare_result = esp;
}

// ba3 movl $0x22,0x18(%esp)
{
vaddr = (esp +0x18);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xba3;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = ( +0x22);

}

// bab mov 0x18(%esp),%eax
{
vaddr = (esp +0x18);
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xbab;
    goto L_RETURN;
}
#endif // !NO_CHECK
eax= (uint)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

}

// baf push %eax
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xbaf;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = eax;

}

// bb0 call b40 <test_target4>
{
esp -= 4;
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xbb0;
    goto L_RETURN;
}
#endif // !NO_CHECK
*((uint*)(byte*)(cont_memory_minus_start + vaddr)) = (uint)CallRetAddress._0xbb5;

if (true) {
    goto L_b40;
}
}

// bb5 add $0x2c,%esp
L_bb5:
{
esp += ( +0x2c);
compare_result = esp;
}

// bb8 ret 
{
vaddr = esp;
#if !NO_CHECK
if (vaddr < cont_start || vaddr >= cont_end){
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0xbb8;
    goto L_RETURN;
}
#endif // !NO_CHECK
next_return= (CallRetAddress)(*((uint*)(byte*)(cont_memory_minus_start + vaddr)) );

esp += 4;
goto L_RET_FROM_CALL;
}

// bb9 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}

public enum FunctionTable
{
    test_target1 = 0xa70,
    test_target2 = 0xad0,
    test_target4 = 0xb40,
    test_target3 = 0xba0,
}

}

