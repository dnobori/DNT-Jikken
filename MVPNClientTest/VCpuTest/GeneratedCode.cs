// Auto generated by IPA Box Test
using System;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219, CS1717, CS0162, CS0168

public static unsafe class VCode
{
public static void Iam_The_IntelCPU_HaHaHa(VCpuState state, uint ip)
{
uint eax = state.Eax; ref ushort al = ref *((ushort*)(&eax) + 0); ref ushort ah = ref *((ushort*)(&eax) + 1);
uint ebx = state.Ebx; ref ushort bl = ref *((ushort*)(&ebx) + 0); ref ushort bh = ref *((ushort*)(&ebx) + 1);
uint ecx = state.Ecx; ref ushort cl = ref *((ushort*)(&ecx) + 0); ref ushort ch = ref *((ushort*)(&ecx) + 1);
uint edx = state.Edx; ref ushort dl = ref *((ushort*)(&edx) + 0); ref ushort dh = ref *((ushort*)(&edx) + 1);
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint esp = state.Esp; 
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
uint compare_result = 0;
uint cache_last_page1 = 0xffffffff;
uint last_used_cache = 0;
byte *cache_last_realaddr1 = null;
uint cache_last_page2 = 0xffffffff;
byte *cache_last_realaddr2 = null;
uint vaddr = 0, vaddr1_index = 0, vaddr1_offset = 0;
uint write_tmp = 0, read_tmp = 0;
byte *realaddr1 = null;
VMemory Memory = state.Memory;
VPageTableEntry* pte = Memory.PageTableEntry;
uint next_ip = ip;
uint memcache_esp_0x0_pin = 0x7fffffff; uint memcache_esp_0x0_data = 0xcafebeef;
uint memcache_esp_0xc_pin = 0x7fffffff; uint memcache_esp_0xc_data = 0xcafebeef;
uint memcache_esp_0x20_pin = 0x7fffffff; uint memcache_esp_0x20_data = 0xcafebeef;
uint memcache_esp_0x1c_pin = 0x7fffffff; uint memcache_esp_0x1c_data = 0xcafebeef;

L_START:
switch (next_ip)
{
case 0x8048740: goto L_8048740;
case 0x8048760: goto L_8048760;
case 0x8048778: goto L_8048778;
case 0x8048782: goto L_8048782;
case 0x8048789: goto L_8048789;
case 0x804878c: goto L_804878c;
case 0x8048797: goto L_8048797;
case 0x80487a0: goto L_80487a0;
case 0x80487c0: goto L_80487c0;
case 0x80487ce: goto L_80487ce;
case 0x80487d8: goto L_80487d8;
case 0x80487e8: goto L_80487e8;
case 0x80487f6: goto L_80487f6;
case 0x8048810: goto L_8048810;
case 0x8048828: goto L_8048828;
case 0x804882d: goto L_804882d;
case 0x804883f: goto L_804883f;
case 0x8048848: goto L_8048848;
case 0x8048853: goto L_8048853;
case 0x8048857: goto L_8048857;
case 0x8048860: goto L_8048860;
default:
    exception_string = "Invalid jump target.";
    exception_address = next_ip;
    goto L_RETURN;
}

L_RET_FROM_CALL:
switch (next_ip)
{
case 0x8048838: goto L_8048838;
case 0x8048877: goto L_8048877;
case 0xdeadbeef: goto L_RETURN;
default:
    exception_string = "Invalid call return target.";
    exception_address = next_ip;
    goto L_RETURN;
}

// function test_target1();
// 8048740 push %esi
L_8048740:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048740;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048741 xor %esi,%esi
{
esi = 0;
}

// 8048743 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048743;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048744 sub $0x10,%esp
{
esp -= ( +0x10);
compare_result = esp;
}

// 8048747 movl $0x4e20,0xc(%esp)
{
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048747;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 804874f mov 0xc(%esp),%eax
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804874f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048753 cmp $0x2,%eax
{
compare_result = (uint)(eax - ( +0x2));
}

// 8048756 jbe 8048797 <test_target1+0x57>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048797;
}
}

// 8048758 mov $0x3,%ebx
{
ebx = ( +0x3);
}

// 804875d lea 0x0(%esi),%esi
{
esi = esi;
}

// 8048760 cmp $0x2,%ebx
L_8048760:
{
compare_result = (uint)(ebx - ( +0x2));
}

// 8048763 jbe 8048789 <test_target1+0x49>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048789;
}
}

// 8048765 test $0x1,%bl
{
compare_result = (uint)(bl & ( +0x1));
}

// 8048768 je 804878c <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_804878c;
}
}

// 804876a mov $0x2,%ecx
{
ecx = ( +0x2);
}

// 804876f jmp 8048782 <test_target1+0x42>
{
if (true) {
    goto L_8048782;
}
}

// 8048771 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 8048778 xor %edx,%edx
L_8048778:
{
edx = 0;
}

// 804877a mov %ebx,%eax
{
eax = ebx;
}

// 804877c div %ecx
{
if (edx != 0) {
ulong tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
ulong tmp2 = ecx;
eax = (uint)(tmp1 / tmp2);
edx = (uint)(tmp1 - tmp2 * eax);
} else
{ 
uint tmp1 = eax;
uint tmp2 = ecx;
eax = tmp1 / tmp2;
edx = tmp1 - tmp2 * eax;
}
}

// 804877e test %edx,%edx
{
compare_result = (uint)(edx);
}

// 8048780 je 804878c <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_804878c;
}
}

// 8048782 add $0x1,%ecx
L_8048782:
{
ecx += ( +0x1);
compare_result = ecx;
}

// 8048785 cmp %ebx,%ecx
{
compare_result = (uint)(ecx - ebx);
}

// 8048787 jne 8048778 <test_target1+0x38>
{
if (compare_result != 0) {
    goto L_8048778;
}
}

// 8048789 add $0x1,%esi
L_8048789:
{
esi += ( +0x1);
compare_result = esi;
}

// 804878c mov 0xc(%esp),%eax
L_804878c:
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804878c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048790 add $0x1,%ebx
{
ebx += ( +0x1);
compare_result = ebx;
}

// 8048793 cmp %ebx,%eax
{
compare_result = (uint)(eax - ebx);
}

// 8048795 jae 8048760 <test_target1+0x20>
{
if (compare_result <= 0x80000000) {
    goto L_8048760;
}
}

// 8048797 add $0x10,%esp
L_8048797:
{
esp += ( +0x10);
compare_result = esp;
}

// 804879a mov %esi,%eax
{
eax = esi;
}

// 804879c pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804879d pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804879e ret 
{
if (memcache_esp_0x0_pin == esp) next_ip= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_ip=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 804879f nop 
{
}

// function test_target2();
// 80487a0 push %esi
L_80487a0:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80487a1 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80487a2 sub $0x1f50,%esp
{
esp -= ( +0x1f50);
compare_result = esp;
}

// 80487a8 movl $0x7d0,0xc(%esp)
{
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80487b0 mov 0xc(%esp),%eax
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80487b4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80487b6 je 80487ce <test_target2+0x2e>
{
if (compare_result == 0) {
    goto L_80487ce;
}
}

// 80487b8 xor %eax,%eax
{
eax = 0;
}

// 80487ba lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// 80487be xchg %ax,%ax
{
}

// 80487c0 mov 0xc(%esp),%edx
L_80487c0:
{
if (memcache_esp_0xc_pin == (esp +0xc)) edx= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80487c4 mov %eax,(%ebx,%eax,4)
{
{
vaddr = (ebx + eax * 0x4);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487c4;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
}
}

}

// 80487c7 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80487ca cmp %eax,%edx
{
compare_result = (uint)(edx - eax);
}

// 80487cc ja 80487c0 <test_target2+0x20>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_80487c0;
}
}

// 80487ce mov $0xc350,%esi
L_80487ce:
{
esi = ( +0xc350);
}

// 80487d3 xor %eax,%eax
{
eax = 0;
}

// 80487d5 lea 0x0(%esi),%esi
{
esi = esi;
}

// 80487d8 mov 0xc(%esp),%edx
L_80487d8:
{
if (memcache_esp_0xc_pin == (esp +0xc)) edx= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80487dc test %edx,%edx
{
compare_result = (uint)(edx);
}

// 80487de je 80487f6 <test_target2+0x56>
{
if (compare_result == 0) {
    goto L_80487f6;
}
}

// 80487e0 xor %edx,%edx
{
edx = 0;
}

// 80487e2 lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// 80487e6 xchg %ax,%ax
{
}

// 80487e8 mov 0xc(%esp),%ecx
L_80487e8:
{
if (memcache_esp_0xc_pin == (esp +0xc)) ecx= memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ecx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    ecx=     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487e8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ecx=     memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80487ec add (%ebx,%edx,4),%eax
{
{
vaddr = (ebx + edx * 0x4);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax+=  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
}
else if (vaddr1_index == cache_last_page2)
{
    eax+=  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487ec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax+=  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
}
}

compare_result = eax;
}

// 80487ef add $0x1,%edx
{
edx += ( +0x1);
compare_result = edx;
}

// 80487f2 cmp %edx,%ecx
{
compare_result = (uint)(ecx - edx);
}

// 80487f4 ja 80487e8 <test_target2+0x48>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_80487e8;
}
}

// 80487f6 sub $0x1,%esi
L_80487f6:
{
esi -= ( +0x1);
compare_result = esi;
}

// 80487f9 jne 80487d8 <test_target2+0x38>
{
if (compare_result != 0) {
    goto L_80487d8;
}
}

// 80487fb add $0x1f50,%esp
{
esp += ( +0x1f50);
compare_result = esp;
}

// 8048801 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048801;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048802 pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048802;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048803 ret 
{
if (memcache_esp_0x0_pin == esp) next_ip= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048803;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_ip=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 8048804 lea 0x0(%esi),%esi
{
esi = esi;
}

// 804880a lea 0x0(%edi),%edi
{
edi = edi;
}

// function test_target4();
// 8048810 push %esi
L_8048810:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048810;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048811 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048811;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048812 sub $0x14,%esp
{
esp -= ( +0x14);
compare_result = esp;
}

// 8048815 mov 0x20(%esp),%ebx
{
if (memcache_esp_0x20_pin == (esp +0x20)) ebx= memcache_esp_0x20_data; else 
{
vaddr = (esp +0x20);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx=     memcache_esp_0x20_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x20_pin = (esp +0x20);
}
else if (vaddr1_index == cache_last_page2)
{
    ebx=     memcache_esp_0x20_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x20_pin = (esp +0x20);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048815;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx=     memcache_esp_0x20_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x20_pin = (esp +0x20);
}
}

}

// 8048819 test %ebx,%ebx
{
compare_result = (uint)(ebx);
}

// 804881b je 8048853 <test_target4+0x43>
{
if (compare_result == 0) {
    goto L_8048853;
}
}

// 804881d cmp $0x1,%ebx
{
compare_result = (uint)(ebx - ( +0x1));
}

// 8048820 je 8048857 <test_target4+0x47>
{
if (compare_result == 0) {
    goto L_8048857;
}
}

// 8048822 xor %esi,%esi
{
esi = 0;
}

// 8048824 jmp 804882d <test_target4+0x1d>
{
if (true) {
    goto L_804882d;
}
}

// 8048826 xchg %ax,%ax
{
}

// 8048828 cmp $0x1,%ebx
L_8048828:
{
compare_result = (uint)(ebx - ( +0x1));
}

// 804882b je 8048848 <test_target4+0x38>
{
if (compare_result == 0) {
    goto L_8048848;
}
}

// 804882d lea -0x1(%ebx),%eax
L_804882d:
{
eax = (ebx -0x1);
}

// 8048830 mov %eax,(%esp)
{
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048830;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048833 call 8048810 <test_target4>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x8048838;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x8048838;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048833;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x8048838;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048810;
}
}

// 8048838 add %eax,%esi
L_8048838:
{
esi += eax;
compare_result = esi;
}

// 804883a sub $0x2,%ebx
{
ebx -= ( +0x2);
compare_result = ebx;
}

// 804883d jne 8048828 <test_target4+0x18>
{
if (compare_result != 0) {
    goto L_8048828;
}
}

// 804883f add $0x14,%esp
L_804883f:
{
esp += ( +0x14);
compare_result = esp;
}

// 8048842 mov %esi,%eax
{
eax = esi;
}

// 8048844 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048844;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048845 pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048845;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048846 ret 
{
if (memcache_esp_0x0_pin == esp) next_ip= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048846;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_ip=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 8048847 nop 
{
}

// 8048848 add $0x1,%esi
L_8048848:
{
esi += ( +0x1);
compare_result = esi;
}

// 804884b add $0x14,%esp
{
esp += ( +0x14);
compare_result = esp;
}

// 804884e mov %esi,%eax
{
eax = esi;
}

// 8048850 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048850;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048851 pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048851;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8048852 ret 
{
if (memcache_esp_0x0_pin == esp) next_ip= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048852;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_ip=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 8048853 xor %esi,%esi
L_8048853:
{
esi = 0;
}

// 8048855 jmp 804883f <test_target4+0x2f>
{
if (true) {
    goto L_804883f;
}
}

// 8048857 mov $0x1,%esi
L_8048857:
{
esi = ( +0x1);
}

// 804885c jmp 804883f <test_target4+0x2f>
{
if (true) {
    goto L_804883f;
}
}

// 804885e xchg %ax,%ax
{
}

// function test_target3();
// 8048860 sub $0x2c,%esp
L_8048860:
{
esp -= ( +0x2c);
compare_result = esp;
}

// 8048863 movl $0x22,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048863;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x22);
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804886b mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax=     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax=     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804886b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax=     memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804886f mov %eax,(%esp)
{
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804886f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048872 call 8048810 <test_target4>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x8048877;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x8048877;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048872;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x8048877;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048810;
}
}

// 8048877 add $0x2c,%esp
L_8048877:
{
esp += ( +0x2c);
compare_result = esp;
}

// 804887a ret 
{
if (memcache_esp_0x0_pin == esp) next_ip= memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_ip=     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset));
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804887a;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_ip=     memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset)));
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 804887b nop 
{
}

// 804887c lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}

public enum FunctionTable
{
    test_target1 = 0x8048740,
    test_target2 = 0x80487a0,
    test_target4 = 0x8048810,
    test_target3 = 0x8048860,
}

}

