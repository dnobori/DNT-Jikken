// Auto generated by IPA Box Test
using System;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219, CS1717

public static unsafe class VCode
{
public static void Iam_The_IntelCPU_HaHaHa(VCpuState state, uint ip)
{
uint eax = state.Eax; ref ushort al = ref *((ushort*)(&eax) + 0); ref ushort ah = ref *((ushort*)(&eax) + 1);
uint ebx = state.Ebx; ref ushort bl = ref *((ushort*)(&ebx) + 0); ref ushort bh = ref *((ushort*)(&ebx) + 1);
uint ecx = state.Ecx; ref ushort cl = ref *((ushort*)(&ecx) + 0); ref ushort ch = ref *((ushort*)(&ecx) + 1);
uint edx = state.Edx; ref ushort dl = ref *((ushort*)(&edx) + 0); ref ushort dh = ref *((ushort*)(&edx) + 1);
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint esp = state.Esp; 
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
uint compare_result = 0;
uint cache_last_page = 0xffffffff;
byte *cache_last_realaddr = null;
VMemory Memory = state.Memory;
VPageTableEntry* pte = Memory.PageTableEntry;
uint next_ip = ip;

L_START:
switch (next_ip)
{
case 0x8048890: goto L_8048890;
case 0x80488b0: goto L_80488b0;
case 0x80488c8: goto L_80488c8;
case 0x80488d2: goto L_80488d2;
case 0x80488d9: goto L_80488d9;
case 0x80488dc: goto L_80488dc;
case 0x80488e7: goto L_80488e7;
case 0xdeadbeef: goto L_RETURN;
default:
    exception_string = "Invalid jump target.";
    exception_address = next_ip;
    goto L_RETURN;
}

// 8048890 push %esi
L_8048890:
{
esp -= 4;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset)) = esi;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048890;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x8048890;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = esi;
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = esi;
}
}

}

// 8048891 push %ebx
{
esp -= 4;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset)) = ebx;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048891;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x8048891;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = ebx;
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = ebx;
}
}

}

// 8048892 xor %esi,%esi
{
esi ^= esi;
}

// 8048894 mov $0x3,%ebx
{
ebx = ( +0x3);
}

// 8048899 sub $0x10,%esp
{
esp -= ( +0x10);
}

// 804889c movl $0x4e20,0xc(%esp)
{
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset)) = ( +0x4e20);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804889c;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanWrite == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x804889c;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint set_value = ( +0x4e20);
    byte *set_ptr = (byte *)set_value;
    if (size1 == 1) { realaddr1[0] = set_ptr[0]; realaddr2[0] = set_ptr[1]; realaddr2[1] = set_ptr[2]; realaddr2[2] = set_ptr[3]; }
    else if (size1 == 2) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr2[0] = set_ptr[2]; realaddr2[1] = set_ptr[3]; }
    else if (size1 == 3) { realaddr1[0] = set_ptr[0]; realaddr1[1] = set_ptr[1]; realaddr1[2] = set_ptr[2]; realaddr2[0] = set_ptr[3]; }
}
else
{
    *((uint *)realaddr1) = ( +0x4e20);
}
}

}

// 80488a4 mov 0xc(%esp),%eax
{
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    eax = *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset));
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488a4;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x80488a4;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    eax = get_value;
}
else
{
    eax = *((uint *)realaddr1);
}
}

}

// 80488a8 cmp $0x2,%eax
{
compare_result = (uint)(eax - ( +0x2));
}

// 80488ab jbe 80488e7 <test_target1+0x57>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_80488e7;
}
}

// 80488ad lea 0x0(%esi),%esi
{
esi = esi;
}

// 80488b0 cmp $0x2,%ebx
L_80488b0:
{
compare_result = (uint)(ebx - ( +0x2));
}

// 80488b3 jbe 80488d9 <test_target1+0x49>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_80488d9;
}
}

// 80488b5 test $0x1,%bl
{
compare_result = (uint)(bl & ( +0x1));
}

// 80488b8 je 80488dc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_80488dc;
}
}

// 80488ba mov $0x2,%ecx
{
ecx = ( +0x2);
}

// 80488bf jmp 80488d2 <test_target1+0x42>
{
if (true) {
    goto L_80488d2;
}
}

// 80488c1 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 80488c8 xor %edx,%edx
L_80488c8:
{
edx ^= edx;
}

// 80488ca mov %ebx,%eax
{
eax = ebx;
}

// 80488cc div %ecx
{
uint tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
uint tmp2 = ecx;
eax = (tmp1 / tmp2);
edx = (tmp1 % tmp2);
}

// 80488ce test %edx,%edx
{
compare_result = (uint)(edx & edx);
}

// 80488d0 je 80488dc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_80488dc;
}
}

// 80488d2 add $0x1,%ecx
L_80488d2:
{
ecx += ( +0x1);
}

// 80488d5 cmp %ebx,%ecx
{
compare_result = (uint)(ecx - ebx);
}

// 80488d7 jne 80488c8 <test_target1+0x38>
{
if (compare_result != 0) {
    goto L_80488c8;
}
}

// 80488d9 add $0x1,%esi
L_80488d9:
{
esi += ( +0x1);
}

// 80488dc mov 0xc(%esp),%eax
L_80488dc:
{
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    eax = *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset));
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488dc;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x80488dc;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    eax = get_value;
}
else
{
    eax = *((uint *)realaddr1);
}
}

}

// 80488e0 add $0x1,%ebx
{
ebx += ( +0x1);
}

// 80488e3 cmp %ebx,%eax
{
compare_result = (uint)(eax - ebx);
}

// 80488e5 jae 80488b0 <test_target1+0x20>
{
if (compare_result <= 0x80000000) {
    goto L_80488b0;
}
}

// 80488e7 add $0x10,%esp
L_80488e7:
{
esp += ( +0x10);
}

// 80488ea mov %esi,%eax
{
eax = esi;
}

// 80488ec pop %ebx
{
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    ebx = *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset));
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488ec;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x80488ec;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    ebx = get_value;
}
else
{
    ebx = *((uint *)realaddr1);
}
}

esp += 4;
}

// 80488ed pop %esi
{
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    esi = *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset));
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488ed;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x80488ed;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    esi = get_value;
}
else
{
    esi = *((uint *)realaddr1);
}
}

esp += 4;
}

// 80488ee ret 
{
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page)
{
    next_ip = *((uint *)(((byte *)cache_last_realaddr) + vaddr1_offset));
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488ee;
    goto L_RETURN;
}
cache_last_page = vaddr1_index;
cache_last_realaddr = pte[vaddr1_index].RealMemory;
byte *realaddr1 = (byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset);
if ((vaddr1_offset + 4) > VConsts.PageSize)
{
    uint size1 = VConsts.PageSize - vaddr1_offset;
    uint size2 = 4 - size1;
    uint vaddr2 = vaddr + size1;
    uint vaddr2_index = vaddr2 / VConsts.PageSize;
    if (pte[vaddr2_index].CanRead == false)
    {
        exception_string = $"Access violation to 0x{vaddr2:x}.";
        exception_address = 0x80488ee;
        goto L_RETURN;
    }
    byte *realaddr2 = (byte *)(pte[vaddr2_index].RealMemory);
    uint get_value = 0;
    byte *get_ptr = (byte *)get_value;
    if (size1 == 1) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr2[0]; get_ptr[2] = realaddr2[1]; get_ptr[3] = realaddr2[2]; }
    else if (size1 == 2) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr2[0]; get_ptr[3] = realaddr2[1]; }
    else if (size1 == 3) { get_ptr[0] = realaddr1[0]; get_ptr[1] = realaddr1[1]; get_ptr[2] = realaddr1[2]; get_ptr[3] = realaddr2[0]; }
    next_ip = get_value;
}
else
{
    next_ip = *((uint *)realaddr1);
}
}

esp += 4;
goto L_START;
}

// 80488ef nop 
{
}

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}

public enum FunctionTable
{
    test_target1 = 0x8048890,
}

}

