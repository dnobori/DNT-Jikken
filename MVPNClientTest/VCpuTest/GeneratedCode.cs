// Auto generated by IPA Box Test
using System;
using System.Runtime.CompilerServices;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219, CS1717, CS0162, CS0168

public static unsafe class VCode
{
public enum CallRetAddress {
    _MagicReturn,
}

public static void Iam_The_IntelCPU_HaHaHa(VCpuState state, uint ip)
{
uint eax = state.Eax;
uint ebx = state.Ebx;
uint ecx = state.Ecx;
uint edx = state.Edx;
uint esp = state.Esp; 
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint cache_last_page1 = 0xffffffff;
uint last_used_cache = 0;
byte *cache_last_realaddr1 = null;
uint cache_last_page2 = 0xffffffff;
byte *cache_last_realaddr2 = null;
uint compare_result = 0;
VPageTableEntry* pte = state.Memory.PageTableEntry;
uint next_ip = ip;
CallRetAddress next_return = (CallRetAddress)0x7fffffff;
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
byte *realaddr1 = null;
uint memcache_esp_0x0_pin = 0x7fffffff; uint memcache_esp_0x0_data = 0xcafebeef;
uint memcache_esp_0xc_pin = 0x7fffffff; uint memcache_esp_0xc_data = 0xcafebeef;

L_START:
if (false) { } 
else if (next_ip == 0x8048740) goto L_8048740;
 else {
    exception_string = "Invalid jump target.";
    exception_address = next_ip;
    goto L_RETURN;
 } 

L_RET_FROM_CALL:
if (next_return == CallRetAddress._MagicReturn)  
goto L_RETURN;
 else {
    exception_string = "Invalid call return target.";
    exception_address = next_ip;
    goto L_RETURN;
}

// function test_target1();
// 8048740 push %esi
L_8048740:
esp -= 4;
{
uint write_tmp = 0;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048740;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
}
}


// 8048741 xor %esi,%esi
esi = 0;

// 8048743 push %ebx
esp -= 4;
{
uint write_tmp = 0;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048743;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
}
}


// 8048744 sub $0x10,%esp
esp -= ( +0x10);
compare_result = esp;

// 8048747 movl $0x4e20,0xc(%esp)
{
uint write_tmp = 0;
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x4e20);
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x4e20);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048747;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x4e20);
}
}


// 804874f mov 0xc(%esp),%eax
{
uint read_tmp = 0;
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804874f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}


// 8048753 cmp $0x2,%eax
compare_result = (uint)(eax - ( +0x2));

// 8048756 jbe 8048797 <test_target1+0x57>
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048797;
}

// 8048758 mov $0x3,%ebx
ebx = ( +0x3);

// 804875d lea 0x0(%esi),%esi
esi = esi;

// 8048760 cmp $0x2,%ebx
L_8048760:
compare_result = (uint)(ebx - ( +0x2));

// 8048763 jbe 8048789 <test_target1+0x49>
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048789;
}

// 8048765 test $0x1,%bl
compare_result = (uint)(((ebx) & 0xffff) & ( +0x1));

// 8048768 je 804878c <test_target1+0x4c>
if (compare_result == 0) {
    goto L_804878c;
}

// 804876a mov $0x2,%ecx
ecx = ( +0x2);

// 804876f jmp 8048782 <test_target1+0x42>
if (true) {
    goto L_8048782;
}

// 8048771 lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// 8048778 xor %edx,%edx
L_8048778:
edx = 0;

// 804877a mov %ebx,%eax
eax = ebx;

// 804877c div %ecx
if (edx != 0) {
ulong tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
ulong tmp2 = ecx;
eax = (uint)(tmp1 / tmp2);
edx = (uint)(tmp1 - tmp2 * eax);
} else
{ 
uint tmp1 = eax;
uint tmp2 = ecx;
eax = tmp1 / tmp2;
edx = tmp1 - tmp2 * eax;
}

// 804877e test %edx,%edx
compare_result = (uint)(edx);

// 8048780 je 804878c <test_target1+0x4c>
if (compare_result == 0) {
    goto L_804878c;
}

// 8048782 add $0x1,%ecx
L_8048782:
ecx += ( +0x1);
compare_result = ecx;

// 8048785 cmp %ebx,%ecx
compare_result = (uint)(ecx - ebx);

// 8048787 jne 8048778 <test_target1+0x38>
if (compare_result != 0) {
    goto L_8048778;
}

// 8048789 add $0x1,%esi
L_8048789:
esi += ( +0x1);
compare_result = esi;

// 804878c mov 0xc(%esp),%eax
L_804878c:
{
uint read_tmp = 0;
uint vaddr = (esp +0xc);
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804878c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}


// 8048790 add $0x1,%ebx
ebx += ( +0x1);
compare_result = ebx;

// 8048793 cmp %ebx,%eax
compare_result = (uint)(eax - ebx);

// 8048795 jae 8048760 <test_target1+0x20>
if (compare_result <= 0x80000000) {
    goto L_8048760;
}

// 8048797 add $0x10,%esp
L_8048797:
esp += ( +0x10);
compare_result = esp;

// 804879a mov %esi,%eax
eax = esi;

// 804879c pop %ebx
{
uint read_tmp = 0;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}

esp += 4;

// 804879d pop %esi
{
uint read_tmp = 0;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}

esp += 4;

// 804879e ret 
{
uint read_tmp = 0;
uint vaddr = esp;
uint vaddr1_index = vaddr / VConsts.PageSize;
uint vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 804879f nop 

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}

public enum FunctionTable
{
    test_target1 = 0x8048740,
}

}

