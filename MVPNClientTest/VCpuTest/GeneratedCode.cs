// Auto generated by IPA Box Test
using System;
using System.Runtime.CompilerServices;
using SoftEther.WebSocket.Helper;

#pragma warning disable CS0164, CS0219, CS1717, CS0162, CS0168

public static unsafe class VCode
{
public enum CallRetAddress {
    _MagicReturn,
    _0x8048841,
    _0x8048885,
    _0x80488e1,
    _0x80488fe,
    _0x804892e,
    _0x804895e,
    _0x804898e,
    _0x80489be,
    _0x80489ee,
    _0x8048a1e,
    _0x8048a4e,
    _0x8048a7e,
    _0x8048aa6,
    _0x8048abb,
    _0x8048ac8,
    _0x8048ad7,
    _0x8048b1f,
}

public static void Iam_The_IntelCPU_HaHaHa(VCpuState state, uint ip)
{
uint eax = state.Eax;
uint ebx = state.Ebx;
uint ecx = state.Ecx;
uint edx = state.Edx;
uint esp = state.Esp; 
uint esi = state.Esi; 
uint edi = state.Edi; 
uint ebp = state.Ebp; 
uint cache_last_page1 = 0xffffffff;
uint last_used_cache = 0;
byte *cache_last_realaddr1 = null;
uint cache_last_page2 = 0xffffffff;
byte *cache_last_realaddr2 = null;
uint vaddr = 0, vaddr1_index = 0, vaddr1_offset = 0;
uint write_tmp = 0, read_tmp = 0;
uint compare_result = 0;
VMemory Memory = state.Memory;
VPageTableEntry* pte = Memory.PageTableEntry;
uint next_ip = ip;
CallRetAddress next_return = (CallRetAddress)0x7fffffff;
ref ushort al = ref *((ushort*)(&eax) + 0); ref ushort ah = ref *((ushort*)(&eax) + 1);
ref ushort bl = ref *((ushort*)(&ebx) + 0); ref ushort bh = ref *((ushort*)(&ebx) + 1);
ref ushort cl = ref *((ushort*)(&ecx) + 0); ref ushort ch = ref *((ushort*)(&ecx) + 1);
ref ushort dl = ref *((ushort*)(&edx) + 0); ref ushort dh = ref *((ushort*)(&edx) + 1);
const uint eiz = 0; 
string exception_string = null;
uint exception_address = 0;
byte *realaddr1 = null;
uint memcache_esp_0x0_pin = 0x7fffffff; uint memcache_esp_0x0_data = 0xcafebeef;
uint memcache_esp_0xc_pin = 0x7fffffff; uint memcache_esp_0xc_data = 0xcafebeef;
uint memcache_esp_0x10_pin = 0x7fffffff; uint memcache_esp_0x10_data = 0xcafebeef;
uint memcache_esp_0x18_pin = 0x7fffffff; uint memcache_esp_0x18_data = 0xcafebeef;
uint memcache_esp_0x40_pin = 0x7fffffff; uint memcache_esp_0x40_data = 0xcafebeef;
uint memcache_esp_0x44_pin = 0x7fffffff; uint memcache_esp_0x44_data = 0xcafebeef;
uint memcache_esp_0x48_pin = 0x7fffffff; uint memcache_esp_0x48_data = 0xcafebeef;
uint memcache_esp_0x1c_pin = 0x7fffffff; uint memcache_esp_0x1c_data = 0xcafebeef;
uint memcache_esp_0x8_pin = 0x7fffffff; uint memcache_esp_0x8_data = 0xcafebeef;

L_START:
switch (next_ip)
{
case 0x8048740: goto L_8048740;
case 0x80487a0: goto L_80487a0;
case 0x8048810: goto L_8048810;
case 0x8048870: goto L_8048870;
case 0x8048890: goto L_8048890;
case 0x8048af0: goto L_8048af0;
default:
    exception_string = "Invalid jump target.";
    exception_address = next_ip;
    goto L_RETURN;
}

L_RET_FROM_CALL:
switch (next_return)
{
case CallRetAddress._MagicReturn: goto L_RETURN;
case CallRetAddress._0x8048841: goto L_8048841;
case CallRetAddress._0x8048885: goto L_8048885;
case CallRetAddress._0x80488e1: goto L_80488e1;
case CallRetAddress._0x80488fe: goto L_80488fe;
case CallRetAddress._0x804892e: goto L_804892e;
case CallRetAddress._0x804895e: goto L_804895e;
case CallRetAddress._0x804898e: goto L_804898e;
case CallRetAddress._0x80489be: goto L_80489be;
case CallRetAddress._0x80489ee: goto L_80489ee;
case CallRetAddress._0x8048a1e: goto L_8048a1e;
case CallRetAddress._0x8048a4e: goto L_8048a4e;
case CallRetAddress._0x8048a7e: goto L_8048a7e;
case CallRetAddress._0x8048aa6: goto L_8048aa6;
case CallRetAddress._0x8048abb: goto L_8048abb;
case CallRetAddress._0x8048ac8: goto L_8048ac8;
case CallRetAddress._0x8048ad7: goto L_8048ad7;
case CallRetAddress._0x8048b1f: goto L_8048b1f;
default:
    exception_string = "Invalid call return target.";
    exception_address = next_ip;
    goto L_RETURN;
}

// function test_target1();
// 8048740 push %esi
L_8048740:
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048740;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048741 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048741;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048742 xor %esi,%esi
esi = 0;

// 8048744 mov $0x3,%ebx
ebx = ( +0x3);

// 8048749 sub $0x10,%esp
esp -= ( +0x10);
compare_result = esp;

// 804874c movl $0x4e20,0xc(%esp)
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804874c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 8048754 mov 0xc(%esp),%eax
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048754;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 8048758 cmp $0x2,%eax
compare_result = (uint)(eax - ( +0x2));

// 804875b jbe 8048797 <test_target1+0x57>
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048797;
}

// 804875d lea 0x0(%esi),%esi
esi = esi;

// 8048760 cmp $0x2,%ebx
L_8048760:
compare_result = (uint)(ebx - ( +0x2));

// 8048763 jbe 8048789 <test_target1+0x49>
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048789;
}

// 8048765 test $0x1,%bl
compare_result = (uint)(bl & ( +0x1));

// 8048768 je 804878c <test_target1+0x4c>
if (compare_result == 0) {
    goto L_804878c;
}

// 804876a mov $0x2,%ecx
ecx = ( +0x2);

// 804876f jmp 8048782 <test_target1+0x42>
if (true) {
    goto L_8048782;
}

// 8048771 lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// 8048778 xor %edx,%edx
L_8048778:
edx = 0;

// 804877a mov %ebx,%eax
eax = ebx;

// 804877c div %ecx
if (edx != 0) {
ulong tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
ulong tmp2 = ecx;
eax = (uint)(tmp1 / tmp2);
edx = (uint)(tmp1 - tmp2 * eax);
} else
{ 
uint tmp1 = eax;
uint tmp2 = ecx;
eax = tmp1 / tmp2;
edx = tmp1 - tmp2 * eax;
}

// 804877e test %edx,%edx
compare_result = (uint)(edx);

// 8048780 je 804878c <test_target1+0x4c>
if (compare_result == 0) {
    goto L_804878c;
}

// 8048782 add $0x1,%ecx
L_8048782:
ecx += ( +0x1);
compare_result = ecx;

// 8048785 cmp %ebx,%ecx
compare_result = (uint)(ecx - ebx);

// 8048787 jne 8048778 <test_target1+0x38>
if (compare_result != 0) {
    goto L_8048778;
}

// 8048789 add $0x1,%esi
L_8048789:
esi += ( +0x1);
compare_result = esi;

// 804878c mov 0xc(%esp),%eax
L_804878c:
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804878c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 8048790 add $0x1,%ebx
ebx += ( +0x1);
compare_result = ebx;

// 8048793 cmp %ebx,%eax
compare_result = (uint)(eax - ebx);

// 8048795 jae 8048760 <test_target1+0x20>
if (compare_result <= 0x80000000) {
    goto L_8048760;
}

// 8048797 add $0x10,%esp
L_8048797:
esp += ( +0x10);
compare_result = esp;

// 804879a mov %esi,%eax
eax = esi;

// 804879c pop %ebx
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 804879d pop %esi
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 804879e ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804879e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 804879f nop 

// function test_target2();
// 80487a0 push %esi
L_80487a0:
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 80487a1 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 80487a2 sub $0x1f50,%esp
esp -= ( +0x1f50);
compare_result = esp;

// 80487a8 movl $0x7d0,0xc(%esp)
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 80487b0 mov 0xc(%esp),%eax
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 80487b4 test %eax,%eax
compare_result = (uint)(eax);

// 80487b6 je 80487ce <test_target2+0x2e>
if (compare_result == 0) {
    goto L_80487ce;
}

// 80487b8 lea 0x10(%esp),%ebx
ebx = (esp +0x10);

// 80487bc xor %eax,%eax
eax = 0;

// 80487be xchg %ax,%ax

// 80487c0 mov 0xc(%esp),%edx
L_80487c0:
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 80487c4 mov %eax,(%ebx,%eax,4)
{
vaddr = (ebx + eax * 0x4);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487c4;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
}
}


// 80487c7 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 80487ca cmp %eax,%edx
compare_result = (uint)(edx - eax);

// 80487cc ja 80487c0 <test_target2+0x20>
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_80487c0;
}

// 80487ce mov $0xc350,%esi
L_80487ce:
esi = ( +0xc350);

// 80487d3 xor %eax,%eax
eax = 0;

// 80487d5 lea 0x0(%esi),%esi
esi = esi;

// 80487d8 mov 0xc(%esp),%edx
L_80487d8:
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 80487dc test %edx,%edx
compare_result = (uint)(edx);

// 80487de je 80487fe <test_target2+0x5e>
if (compare_result == 0) {
    goto L_80487fe;
}

// 80487e0 lea 0x10(%esp),%ebx
ebx = (esp +0x10);

// 80487e4 xor %edx,%edx
edx = 0;

// 80487e6 lea 0x0(%esi),%esi
esi = esi;

// 80487e9 lea 0x0(%edi,%eiz,1),%edi
edi = (edi + eiz * 0x1);

// 80487f0 mov 0xc(%esp),%ecx
L_80487f0:
if (memcache_esp_0xc_pin == (esp +0xc)) ecx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ecx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    ecx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ecx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 80487f4 add (%ebx,%edx,4),%eax
{
vaddr = (ebx + edx * 0x4);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax+= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    eax+= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80487f4;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax+= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}

compare_result = eax;

// 80487f7 add $0x1,%edx
edx += ( +0x1);
compare_result = edx;

// 80487fa cmp %edx,%ecx
compare_result = (uint)(ecx - edx);

// 80487fc ja 80487f0 <test_target2+0x50>
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_80487f0;
}

// 80487fe sub $0x1,%esi
L_80487fe:
esi -= ( +0x1);
compare_result = esi;

// 8048801 jne 80487d8 <test_target2+0x38>
if (compare_result != 0) {
    goto L_80487d8;
}

// 8048803 add $0x1f50,%esp
esp += ( +0x1f50);
compare_result = esp;

// 8048809 pop %ebx
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048809;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 804880a pop %esi
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804880a;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 804880b ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804880b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 804880c lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// function test_target4();
// 8048810 push %esi
L_8048810:
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048810;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048811 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048811;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048812 sub $0x4,%esp
esp -= ( +0x4);
compare_result = esp;

// 8048815 mov 0x10(%esp),%ebx
if (memcache_esp_0x10_pin == (esp +0x10)) ebx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048815;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}


// 8048819 test %ebx,%ebx
compare_result = (uint)(ebx);

// 804881b je 8048863 <test_target4+0x53>
if (compare_result == 0) {
    goto L_8048863;
}

// 804881d cmp $0x1,%ebx
compare_result = (uint)(ebx - ( +0x1));

// 8048820 je 8048867 <test_target4+0x57>
if (compare_result == 0) {
    goto L_8048867;
}

// 8048822 xor %esi,%esi
esi = 0;

// 8048824 jmp 8048835 <test_target4+0x25>
if (true) {
    goto L_8048835;
}

// 8048826 lea 0x0(%esi),%esi
esi = esi;

// 8048829 lea 0x0(%edi,%eiz,1),%edi
edi = (edi + eiz * 0x1);

// 8048830 cmp $0x1,%ebx
L_8048830:
compare_result = (uint)(ebx - ( +0x1));

// 8048833 je 8048858 <test_target4+0x48>
if (compare_result == 0) {
    goto L_8048858;
}

// 8048835 lea -0x1(%ebx),%eax
L_8048835:
eax = (ebx -0x1);

// 8048838 sub $0xc,%esp
esp -= ( +0xc);
compare_result = esp;

// 804883b push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804883b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 804883c call 8048810 <test_target4>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048841;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048841;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804883c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048841;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048810;
}

// 8048841 add $0x10,%esp
L_8048841:
esp += ( +0x10);
compare_result = esp;

// 8048844 add %eax,%esi
esi += eax;
compare_result = esi;

// 8048846 sub $0x2,%ebx
ebx -= ( +0x2);
compare_result = ebx;

// 8048849 jne 8048830 <test_target4+0x20>
if (compare_result != 0) {
    goto L_8048830;
}

// 804884b add $0x4,%esp
L_804884b:
esp += ( +0x4);
compare_result = esp;

// 804884e mov %esi,%eax
eax = esi;

// 8048850 pop %ebx
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048850;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048851 pop %esi
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048851;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048852 ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048852;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 8048853 nop 

// 8048854 lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// 8048858 add $0x1,%esi
L_8048858:
esi += ( +0x1);
compare_result = esi;

// 804885b add $0x4,%esp
esp += ( +0x4);
compare_result = esp;

// 804885e mov %esi,%eax
eax = esi;

// 8048860 pop %ebx
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048860;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048861 pop %esi
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048861;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048862 ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048862;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 8048863 xor %esi,%esi
L_8048863:
esi = 0;

// 8048865 jmp 804884b <test_target4+0x3b>
if (true) {
    goto L_804884b;
}

// 8048867 mov $0x1,%esi
L_8048867:
esi = ( +0x1);

// 804886c jmp 804884b <test_target4+0x3b>
if (true) {
    goto L_804884b;
}

// 804886e xchg %ax,%ax

// function test_target3();
// 8048870 sub $0x28,%esp
L_8048870:
esp -= ( +0x28);
compare_result = esp;

// 8048873 movl $0x22,0x18(%esp)
{
vaddr = (esp +0x18);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x18_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x18_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048873;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x18_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
}


// 804887b mov 0x18(%esp),%eax
if (memcache_esp_0x18_pin == (esp +0x18)) eax= (uint) memcache_esp_0x18_data; else 
{
vaddr = (esp +0x18);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x18_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x18_pin = (esp +0x18);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x18_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x18_pin = (esp +0x18);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804887b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x18_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x18_pin = (esp +0x18);
}
}


// 804887f push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804887f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 8048880 call 8048810 <test_target4>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048885;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048885;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048880;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048885;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048810;
}

// 8048885 add $0x2c,%esp
L_8048885:
esp += ( +0x2c);
compare_result = esp;

// 8048888 ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048888;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 8048889 lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// function test_target6();
// 8048890 push %ebp
L_8048890:
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048890;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebp;
    memcache_esp_0x0_pin = esp;
}
}


// 8048891 push %edi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048891;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048892 push %esi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048892;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048893 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048893;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048894 sub $0x2c,%esp
esp -= ( +0x2c);
compare_result = esp;

// 8048897 mov 0x40(%esp),%ebx
if (memcache_esp_0x40_pin == (esp +0x40)) ebx= (uint) memcache_esp_0x40_data; else 
{
vaddr = (esp +0x40);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x40_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x40_pin = (esp +0x40);
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x40_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x40_pin = (esp +0x40);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048897;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x40_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x40_pin = (esp +0x40);
}
}


// 804889b mov 0x44(%esp),%esi
if (memcache_esp_0x44_pin == (esp +0x44)) esi= (uint) memcache_esp_0x44_data; else 
{
vaddr = (esp +0x44);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x44_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x44_pin = (esp +0x44);
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x44_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x44_pin = (esp +0x44);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804889b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x44_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x44_pin = (esp +0x44);
}
}


// 804889f mov 0x48(%esp),%edi
if (memcache_esp_0x48_pin == (esp +0x48)) edi= (uint) memcache_esp_0x48_data; else 
{
vaddr = (esp +0x48);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edi= (uint)(     memcache_esp_0x48_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x48_pin = (esp +0x48);
}
else if (vaddr1_index == cache_last_page2)
{
    edi= (uint)(    memcache_esp_0x48_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x48_pin = (esp +0x48);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804889f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edi= (uint)(    memcache_esp_0x48_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x48_pin = (esp +0x48);
}
}


// 80488a3 cmp %esi,%ebx
compare_result = (uint)(ebx - esi);

// 80488a5 mov %edi,%eax
eax = edi;

// 80488a7 jle 8048ada <test_target6+0x24a>
if (compare_result == 0) {
    goto L_8048ada;
}

// 80488ad movl $0x0,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488ad;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488b5 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488b9 test %eax,%eax
compare_result = (uint)(eax);

// 80488bb jne 80488d3 <test_target6+0x43>
if (compare_result != 0) {
    goto L_80488d3;
}

// 80488bd jmp 8048910 <test_target6+0x80>
if (true) {
    goto L_8048910;
}

// 80488bf nop 

// 80488c0 mov 0x1c(%esp),%eax
L_80488c0:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488c4 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 80488c7 mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488c7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488cb mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488cb;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488cf test %eax,%eax
compare_result = (uint)(eax);

// 80488d1 je 8048910 <test_target6+0x80>
if (compare_result == 0) {
    goto L_8048910;
}

// 80488d3 sub $0x4,%esp
L_80488d3:
esp -= ( +0x4);
compare_result = esp;

// 80488d6 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488d6;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 80488d8 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 80488da push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488da;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 80488dc call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x80488e1;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x80488e1;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488dc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x80488e1;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 80488e1 add $0x10,%esp
L_80488e1:
esp += ( +0x10);
compare_result = esp;

// 80488e4 test %eax,%eax
compare_result = (uint)(eax);

// 80488e6 jne 80488c0 <test_target6+0x30>
if (compare_result != 0) {
    goto L_80488c0;
}

// 80488e8 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488e8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80488ec test %eax,%eax
compare_result = (uint)(eax);

// 80488ee je 8048940 <test_target6+0xb0>
if (compare_result == 0) {
    goto L_8048940;
}

// 80488f0 sub $0x4,%esp
L_80488f0:
esp -= ( +0x4);
compare_result = esp;

// 80488f3 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488f3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 80488f5 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 80488f7 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488f7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 80488f9 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x80488fe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x80488fe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80488f9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x80488fe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 80488fe add $0x10,%esp
L_80488fe:
esp += ( +0x10);
compare_result = esp;

// 8048901 test %eax,%eax
compare_result = (uint)(eax);

// 8048903 je 8048940 <test_target6+0xb0>
if (compare_result == 0) {
    goto L_8048940;
}

// 8048905 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048905;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048909 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 804890c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804890c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048910 mov 0x1c(%esp),%eax
L_8048910:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048910;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048914 test %eax,%eax
compare_result = (uint)(eax);

// 8048916 jne 80488f0 <test_target6+0x60>
if (compare_result != 0) {
    goto L_80488f0;
}

// 8048918 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048918;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 804891c test %eax,%eax
compare_result = (uint)(eax);

// 804891e je 8048970 <test_target6+0xe0>
if (compare_result == 0) {
    goto L_8048970;
}

// 8048920 sub $0x4,%esp
L_8048920:
esp -= ( +0x4);
compare_result = esp;

// 8048923 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048923;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048925 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048925;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048927 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048927;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048929 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x804892e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x804892e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048929;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x804892e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 804892e add $0x10,%esp
L_804892e:
esp += ( +0x10);
compare_result = esp;

// 8048931 test %eax,%eax
compare_result = (uint)(eax);

// 8048933 je 8048970 <test_target6+0xe0>
if (compare_result == 0) {
    goto L_8048970;
}

// 8048935 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048935;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048939 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 804893c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804893c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048940 mov 0x1c(%esp),%eax
L_8048940:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048940;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048944 test %eax,%eax
compare_result = (uint)(eax);

// 8048946 jne 8048920 <test_target6+0x90>
if (compare_result != 0) {
    goto L_8048920;
}

// 8048948 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048948;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 804894c test %eax,%eax
compare_result = (uint)(eax);

// 804894e je 80489a0 <test_target6+0x110>
if (compare_result == 0) {
    goto L_80489a0;
}

// 8048950 sub $0x4,%esp
L_8048950:
esp -= ( +0x4);
compare_result = esp;

// 8048953 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048953;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048955 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048955;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048957 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048957;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048959 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x804895e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x804895e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048959;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x804895e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 804895e add $0x10,%esp
L_804895e:
esp += ( +0x10);
compare_result = esp;

// 8048961 test %eax,%eax
compare_result = (uint)(eax);

// 8048963 je 80489a0 <test_target6+0x110>
if (compare_result == 0) {
    goto L_80489a0;
}

// 8048965 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048965;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048969 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 804896c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804896c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048970 mov 0x1c(%esp),%eax
L_8048970:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048970;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048974 test %eax,%eax
compare_result = (uint)(eax);

// 8048976 jne 8048950 <test_target6+0xc0>
if (compare_result != 0) {
    goto L_8048950;
}

// 8048978 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048978;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 804897c test %eax,%eax
compare_result = (uint)(eax);

// 804897e je 80489d0 <test_target6+0x140>
if (compare_result == 0) {
    goto L_80489d0;
}

// 8048980 sub $0x4,%esp
L_8048980:
esp -= ( +0x4);
compare_result = esp;

// 8048983 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048983;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048985 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048985;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048987 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048987;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048989 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x804898e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x804898e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048989;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x804898e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 804898e add $0x10,%esp
L_804898e:
esp += ( +0x10);
compare_result = esp;

// 8048991 test %eax,%eax
compare_result = (uint)(eax);

// 8048993 je 80489d0 <test_target6+0x140>
if (compare_result == 0) {
    goto L_80489d0;
}

// 8048995 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048995;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048999 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 804899c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x804899c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489a0 mov 0x1c(%esp),%eax
L_80489a0:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489a4 test %eax,%eax
compare_result = (uint)(eax);

// 80489a6 jne 8048980 <test_target6+0xf0>
if (compare_result != 0) {
    goto L_8048980;
}

// 80489a8 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489ac test %eax,%eax
compare_result = (uint)(eax);

// 80489ae je 8048a00 <test_target6+0x170>
if (compare_result == 0) {
    goto L_8048a00;
}

// 80489b0 sub $0x4,%esp
L_80489b0:
esp -= ( +0x4);
compare_result = esp;

// 80489b3 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489b3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 80489b5 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 80489b7 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489b7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 80489b9 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x80489be;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x80489be;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489b9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x80489be;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 80489be add $0x10,%esp
L_80489be:
esp += ( +0x10);
compare_result = esp;

// 80489c1 test %eax,%eax
compare_result = (uint)(eax);

// 80489c3 je 8048a00 <test_target6+0x170>
if (compare_result == 0) {
    goto L_8048a00;
}

// 80489c5 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489c9 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 80489cc mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489cc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489d0 mov 0x1c(%esp),%eax
L_80489d0:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489d0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489d4 test %eax,%eax
compare_result = (uint)(eax);

// 80489d6 jne 80489b0 <test_target6+0x120>
if (compare_result != 0) {
    goto L_80489b0;
}

// 80489d8 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489dc test %eax,%eax
compare_result = (uint)(eax);

// 80489de je 8048a30 <test_target6+0x1a0>
if (compare_result == 0) {
    goto L_8048a30;
}

// 80489e0 sub $0x4,%esp
L_80489e0:
esp -= ( +0x4);
compare_result = esp;

// 80489e3 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489e3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 80489e5 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 80489e7 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489e7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 80489e9 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x80489ee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x80489ee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489e9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x80489ee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 80489ee add $0x10,%esp
L_80489ee:
esp += ( +0x10);
compare_result = esp;

// 80489f1 test %eax,%eax
compare_result = (uint)(eax);

// 80489f3 je 8048a30 <test_target6+0x1a0>
if (compare_result == 0) {
    goto L_8048a30;
}

// 80489f5 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 80489f9 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 80489fc mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x80489fc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a00 mov 0x1c(%esp),%eax
L_8048a00:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a00;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a04 test %eax,%eax
compare_result = (uint)(eax);

// 8048a06 jne 80489e0 <test_target6+0x150>
if (compare_result != 0) {
    goto L_80489e0;
}

// 8048a08 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a08;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a0c test %eax,%eax
compare_result = (uint)(eax);

// 8048a0e je 8048a60 <test_target6+0x1d0>
if (compare_result == 0) {
    goto L_8048a60;
}

// 8048a10 sub $0x4,%esp
L_8048a10:
esp -= ( +0x4);
compare_result = esp;

// 8048a13 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a13;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a15 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a17 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a17;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a19 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a1e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a1e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a19;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048a1e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048a1e add $0x10,%esp
L_8048a1e:
esp += ( +0x10);
compare_result = esp;

// 8048a21 test %eax,%eax
compare_result = (uint)(eax);

// 8048a23 je 8048a60 <test_target6+0x1d0>
if (compare_result == 0) {
    goto L_8048a60;
}

// 8048a25 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a29 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 8048a2c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a2c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a30 mov 0x1c(%esp),%eax
L_8048a30:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a30;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a34 test %eax,%eax
compare_result = (uint)(eax);

// 8048a36 jne 8048a10 <test_target6+0x180>
if (compare_result != 0) {
    goto L_8048a10;
}

// 8048a38 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a38;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a3c test %eax,%eax
compare_result = (uint)(eax);

// 8048a3e je 8048a90 <test_target6+0x200>
if (compare_result == 0) {
    goto L_8048a90;
}

// 8048a40 sub $0x4,%esp
L_8048a40:
esp -= ( +0x4);
compare_result = esp;

// 8048a43 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a43;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a45 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a47 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a47;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a49 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a4e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a4e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a49;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048a4e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048a4e add $0x10,%esp
L_8048a4e:
esp += ( +0x10);
compare_result = esp;

// 8048a51 test %eax,%eax
compare_result = (uint)(eax);

// 8048a53 je 8048a90 <test_target6+0x200>
if (compare_result == 0) {
    goto L_8048a90;
}

// 8048a55 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a59 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 8048a5c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a5c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a60 mov 0x1c(%esp),%eax
L_8048a60:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a60;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a64 test %eax,%eax
compare_result = (uint)(eax);

// 8048a66 jne 8048a40 <test_target6+0x1b0>
if (compare_result != 0) {
    goto L_8048a40;
}

// 8048a68 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a68;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a6c test %eax,%eax
compare_result = (uint)(eax);

// 8048a6e je 8048a98 <test_target6+0x208>
if (compare_result == 0) {
    goto L_8048a98;
}

// 8048a70 sub $0x4,%esp
L_8048a70:
esp -= ( +0x4);
compare_result = esp;

// 8048a73 push $0x3
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a73;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a75 push $0x2
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a77 push $0x1
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a77;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}


// 8048a79 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a7e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048a7e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a79;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048a7e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048a7e add $0x10,%esp
L_8048a7e:
esp += ( +0x10);
compare_result = esp;

// 8048a81 test %eax,%eax
compare_result = (uint)(eax);

// 8048a83 je 8048a98 <test_target6+0x208>
if (compare_result == 0) {
    goto L_8048a98;
}

// 8048a85 mov 0x1c(%esp),%eax
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a89 add $0x1,%eax
eax += ( +0x1);
compare_result = eax;

// 8048a8c mov %eax,0x1c(%esp)
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a8c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a90 mov 0x1c(%esp),%eax
L_8048a90:
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a90;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048a94 test %eax,%eax
compare_result = (uint)(eax);

// 8048a96 jne 8048a70 <test_target6+0x1e0>
if (compare_result != 0) {
    goto L_8048a70;
}

// 8048a98 lea -0x1(%edi),%eax
L_8048a98:
eax = (edi -0x1);

// 8048a9b sub $0x4,%esp
esp -= ( +0x4);
compare_result = esp;

// 8048a9e push %esi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a9e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048a9f push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048a9f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048aa0 push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048aa0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 8048aa1 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048aa6;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048aa6;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048aa1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048aa6;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048aa6 mov %eax,0x1c(%esp)
L_8048aa6:
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048aa6;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}


// 8048aaa lea -0x1(%esi),%eax
eax = (esi -0x1);

// 8048aad add $0xc,%esp
esp += ( +0xc);
compare_result = esp;

// 8048ab0 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ab0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ab1 push %edi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ab1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ab2 sub $0x1,%ebx
ebx -= ( +0x1);
compare_result = ebx;

// 8048ab5 push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ab5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ab6 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048abb;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048abb;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ab6;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048abb;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048abb add $0xc,%esp
L_8048abb:
esp += ( +0xc);
compare_result = esp;

// 8048abe mov %eax,%ebp
ebp = eax;

// 8048ac0 push %edi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ac0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ac1 push %esi
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ac1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ac2 push %ebx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ac2;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ac3 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048ac8;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048ac8;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ac3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048ac8;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048ac8 add $0xc,%esp
L_8048ac8:
esp += ( +0xc);
compare_result = esp;

// 8048acb mov 0x10(%esp),%edx
if (memcache_esp_0x10_pin == (esp +0x10)) edx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048acb;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}


// 8048acf push %edx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048acf;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ad0 push %ebp
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ad0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebp;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ad1 push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ad1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 8048ad2 call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048ad7;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048ad7;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ad2;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048ad7;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048ad7 add $0x10,%esp
L_8048ad7:
esp += ( +0x10);
compare_result = esp;

// 8048ada add $0x2c,%esp
L_8048ada:
esp += ( +0x2c);
compare_result = esp;

// 8048add pop %ebx
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048add;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048ade pop %esi
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ade;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048adf pop %edi
if (memcache_esp_0x0_pin == esp) edi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    edi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048adf;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048ae0 pop %ebp
if (memcache_esp_0x0_pin == esp) ebp= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ebp= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebp= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ae0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebp= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;

// 8048ae1 ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048ae1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 8048ae2 lea 0x0(%esi,%eiz,1),%esi
esi = (esi + eiz * 0x1);

// 8048ae9 lea 0x0(%edi,%eiz,1),%edi
edi = (edi + eiz * 0x1);

// function test_target5();
// 8048af0 sub $0x20,%esp
L_8048af0:
esp -= ( +0x20);
compare_result = esp;

// 8048af3 movl $0x19,0x8(%esp)
{
vaddr = (esp +0x8);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x8_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x8_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048af3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x8_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
}


// 8048afb movl $0x7,0xc(%esp)
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048afb;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 8048b03 movl $0x0,0x10(%esp)
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x10_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x10_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b03;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x10_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
}


// 8048b0b mov 0x10(%esp),%ecx
if (memcache_esp_0x10_pin == (esp +0x10)) ecx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    ecx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    ecx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b0b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ecx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}


// 8048b0f mov 0xc(%esp),%edx
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b0f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}


// 8048b13 mov 0x8(%esp),%eax
if (memcache_esp_0x8_pin == (esp +0x8)) eax= (uint) memcache_esp_0x8_data; else 
{
vaddr = (esp +0x8);
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x8_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x8_pin = (esp +0x8);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x8_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x8_pin = (esp +0x8);
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b13;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x8_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x8_pin = (esp +0x8);
}
}


// 8048b17 push %ecx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ecx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ecx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b17;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ecx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048b18 push %edx
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b18;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edx;
    memcache_esp_0x0_pin = esp;
}
}


// 8048b19 push %eax
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b19;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}


// 8048b1a call 8048890 <test_target6>
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress._0x8048b1f;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress._0x8048b1f;
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanWrite == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b1a;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress._0x8048b1f;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048890;
}

// 8048b1f add $0x2c,%esp
L_8048b1f:
esp += ( +0x2c);
compare_result = esp;

// 8048b22 ret 
if (memcache_esp_0x0_pin == esp) next_return= (CallRetAddress) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / VConsts.PageSize;
vaddr1_offset = vaddr % VConsts.PageSize;
if (vaddr1_index == cache_last_page1)
{
    next_return= (CallRetAddress)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (false&&pte[vaddr1_index].CanRead == false)
{
    exception_string = $"Access violation to 0x{vaddr:x}.";
    exception_address = 0x8048b22;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (CallRetAddress)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;

// 8048b23 lea 0x0(%esi),%esi
esi = esi;

// 8048b29 lea 0x0(%edi,%eiz,1),%edi
edi = (edi + eiz * 0x1);

 // Restore CPU state
L_RETURN:
 state.Eax = eax;  state.Ebx = ebx;  state.Ecx = ecx;  state.Edx = edx; 
 state.Esi = esi;  state.Edi = edi;  state.Ebp = ebp;  state.Esp = esp; 
 state.ExceptionString = exception_string;
 state.ExceptionAddress = exception_address;
}

public enum FunctionTable
{
    test_target1 = 0x8048740,
    test_target2 = 0x80487a0,
    test_target4 = 0x8048810,
    test_target3 = 0x8048870,
    test_target6 = 0x8048890,
    test_target5 = 0x8048af0,
}

}

