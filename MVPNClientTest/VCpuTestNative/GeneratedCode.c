// Auto generated by IPA Box Test for C


#define GENERATED_CODE_C
#include "common.h"


enum CallRetAddress {
    CallRetAddress__MagicReturn,
    CallRetAddress__0x80489b1,
    CallRetAddress__0x80489f5,
    CallRetAddress__0x8048a51,
    CallRetAddress__0x8048a6e,
    CallRetAddress__0x8048a9e,
    CallRetAddress__0x8048ace,
    CallRetAddress__0x8048afe,
    CallRetAddress__0x8048b2e,
    CallRetAddress__0x8048b5e,
    CallRetAddress__0x8048b8e,
    CallRetAddress__0x8048bbe,
    CallRetAddress__0x8048bee,
    CallRetAddress__0x8048c26,
    CallRetAddress__0x8048c5e,
    CallRetAddress__0x8048c8e,
    CallRetAddress__0x8048cbe,
    CallRetAddress__0x8048cee,
    CallRetAddress__0x8048d1e,
    CallRetAddress__0x8048d4e,
    CallRetAddress__0x8048d7e,
    CallRetAddress__0x8048dae,
    CallRetAddress__0x8048dde,
    CallRetAddress__0x8048e0e,
    CallRetAddress__0x8048e3e,
    CallRetAddress__0x8048e6e,
    CallRetAddress__0x8048e9e,
    CallRetAddress__0x8048ece,
    CallRetAddress__0x8048efe,
    CallRetAddress__0x8048f2e,
    CallRetAddress__0x8048f5e,
    CallRetAddress__0x8048f8e,
    CallRetAddress__0x8048fbe,
    CallRetAddress__0x8048fee,
    CallRetAddress__0x804901e,
    CallRetAddress__0x804904e,
    CallRetAddress__0x804907e,
    CallRetAddress__0x80490ae,
    CallRetAddress__0x80490de,
    CallRetAddress__0x804910e,
    CallRetAddress__0x804913e,
    CallRetAddress__0x804916e,
    CallRetAddress__0x804919e,
    CallRetAddress__0x80491ce,
    CallRetAddress__0x80491fe,
    CallRetAddress__0x804922e,
    CallRetAddress__0x804925e,
    CallRetAddress__0x804928e,
    CallRetAddress__0x80492be,
    CallRetAddress__0x80492ee,
    CallRetAddress__0x804931e,
    CallRetAddress__0x804934e,
    CallRetAddress__0x804937e,
    CallRetAddress__0x80493ae,
    CallRetAddress__0x80493de,
    CallRetAddress__0x804940e,
    CallRetAddress__0x804943e,
    CallRetAddress__0x804946e,
    CallRetAddress__0x804949e,
    CallRetAddress__0x80494ce,
    CallRetAddress__0x80494fe,
    CallRetAddress__0x804952e,
    CallRetAddress__0x804955e,
    CallRetAddress__0x804958e,
    CallRetAddress__0x80495be,
    CallRetAddress__0x80495ee,
    CallRetAddress__0x804961e,
    CallRetAddress__0x804964e,
    CallRetAddress__0x804967e,
    CallRetAddress__0x80496ae,
    CallRetAddress__0x80496de,
    CallRetAddress__0x804970e,
    CallRetAddress__0x804973e,
    CallRetAddress__0x804976e,
    CallRetAddress__0x804979e,
    CallRetAddress__0x80497ce,
    CallRetAddress__0x80497fe,
    CallRetAddress__0x804982e,
    CallRetAddress__0x804985e,
    CallRetAddress__0x804988e,
    CallRetAddress__0x80498be,
    CallRetAddress__0x80498ee,
    CallRetAddress__0x804991e,
    CallRetAddress__0x804994e,
    CallRetAddress__0x804997e,
    CallRetAddress__0x80499ae,
    CallRetAddress__0x80499de,
    CallRetAddress__0x8049a0e,
    CallRetAddress__0x8049a3e,
    CallRetAddress__0x8049a6e,
    CallRetAddress__0x8049a9e,
    CallRetAddress__0x8049ace,
    CallRetAddress__0x8049afe,
    CallRetAddress__0x8049b2e,
    CallRetAddress__0x8049b5e,
    CallRetAddress__0x8049b8e,
    CallRetAddress__0x8049bbe,
    CallRetAddress__0x8049bee,
    CallRetAddress__0x8049c1e,
    CallRetAddress__0x8049c4e,
    CallRetAddress__0x8049c7e,
    CallRetAddress__0x8049cae,
    CallRetAddress__0x8049cde,
    CallRetAddress__0x8049d0e,
    CallRetAddress__0x8049d36,
    CallRetAddress__0x8049d4b,
    CallRetAddress__0x8049d58,
    CallRetAddress__0x8049d67,
    CallRetAddress__0x8049daf,
}
;

#ifndef  HEADER_ONLY
void Iam_The_IntelCPU_HaHaHa(VCpuState *state, uint ip)
{
uint eax = state->Eax;
uint ebx = state->Ebx;
uint ecx = state->Ecx;
uint edx = state->Edx;
uint esp = state->Esp; 
uint esi = state->Esi; 
uint edi = state->Edi; 
uint ebp = state->Ebp; 
uint cache_last_page1 = 0xffffffff;
uint last_used_cache = 0;
byte *cache_last_realaddr1 = null;
uint cache_last_page2 = 0xffffffff;
byte *cache_last_realaddr2 = null;
uint vaddr = 0, vaddr1_index = 0, vaddr1_offset = 0;
uint write_tmp = 0, read_tmp = 0;
uint compare_result = 0;
VMemory *Memory = state->Memory;
VPageTableEntry* pte = Memory->PageTableEntry;
byte *cont_memory = Memory->ContiguousMemory;
uint cont_start = Memory->ContiguousStart;
uint cont_end = Memory->ContiguousEnd;
uint cont_start2 = Memory->ContiguousStart;
uint cont_end2 = Memory->ContiguousEnd;
byte *cont_memory_minus_start = (byte *)(Memory->ContiguousMemory - cont_start);
uint next_ip = ip;
uint next_return = 0x7fffffff;
ushort *al = ((ushort*)(&eax) + 0); ushort *ah = ((ushort*)(&eax) + 1);
ushort *bl = ((ushort*)(&ebx) + 0); ushort *bh = ((ushort*)(&ebx) + 1);
ushort *cl = ((ushort*)(&ecx) + 0); ushort *ch = ((ushort*)(&ecx) + 1);
ushort *dl = ((ushort*)(&edx) + 0); ushort *dh = ((ushort*)(&edx) + 1);
const uint eiz = 0; 
char exception_string[256] = {0};
uint exception_address = 0;
byte *realaddr1 = null;
uint memcache_esp_0x0_pin = 0x7fffffff; uint memcache_esp_0x0_data = 0xcafebeef;
uint memcache_esp_0xc_pin = 0x7fffffff; uint memcache_esp_0xc_data = 0xcafebeef;
uint memcache_esp_0x10_pin = 0x7fffffff; uint memcache_esp_0x10_data = 0xcafebeef;
uint memcache_esp_0x18_pin = 0x7fffffff; uint memcache_esp_0x18_data = 0xcafebeef;
uint memcache_esp_0x40_pin = 0x7fffffff; uint memcache_esp_0x40_data = 0xcafebeef;
uint memcache_esp_0x44_pin = 0x7fffffff; uint memcache_esp_0x44_data = 0xcafebeef;
uint memcache_esp_0x48_pin = 0x7fffffff; uint memcache_esp_0x48_data = 0xcafebeef;
uint memcache_esp_0x1c_pin = 0x7fffffff; uint memcache_esp_0x1c_data = 0xcafebeef;
uint memcache_esp_0x8_pin = 0x7fffffff; uint memcache_esp_0x8_data = 0xcafebeef;

L_START:
switch (next_ip)
{
case 0x80488b0: goto L_80488b0;
case 0x8048910: goto L_8048910;
case 0x8048980: goto L_8048980;
case 0x80489e0: goto L_80489e0;
case 0x8048a00: goto L_8048a00;
case 0x8049d80: goto L_8049d80;
default:
    sprintf(exception_string, "Invalid jump target.");
    exception_address = next_ip;
    goto L_RETURN;
}

L_RET_FROM_CALL:
switch (next_return)
{
case CallRetAddress__MagicReturn: goto L_RETURN;
case CallRetAddress__0x80489b1: goto L_80489b1;
case CallRetAddress__0x80489f5: goto L_80489f5;
case CallRetAddress__0x8048a51: goto L_8048a51;
case CallRetAddress__0x8048a6e: goto L_8048a6e;
case CallRetAddress__0x8048a9e: goto L_8048a9e;
case CallRetAddress__0x8048ace: goto L_8048ace;
case CallRetAddress__0x8048afe: goto L_8048afe;
case CallRetAddress__0x8048b2e: goto L_8048b2e;
case CallRetAddress__0x8048b5e: goto L_8048b5e;
case CallRetAddress__0x8048b8e: goto L_8048b8e;
case CallRetAddress__0x8048bbe: goto L_8048bbe;
case CallRetAddress__0x8048bee: goto L_8048bee;
case CallRetAddress__0x8048c26: goto L_8048c26;
case CallRetAddress__0x8048c5e: goto L_8048c5e;
case CallRetAddress__0x8048c8e: goto L_8048c8e;
case CallRetAddress__0x8048cbe: goto L_8048cbe;
case CallRetAddress__0x8048cee: goto L_8048cee;
case CallRetAddress__0x8048d1e: goto L_8048d1e;
case CallRetAddress__0x8048d4e: goto L_8048d4e;
case CallRetAddress__0x8048d7e: goto L_8048d7e;
case CallRetAddress__0x8048dae: goto L_8048dae;
case CallRetAddress__0x8048dde: goto L_8048dde;
case CallRetAddress__0x8048e0e: goto L_8048e0e;
case CallRetAddress__0x8048e3e: goto L_8048e3e;
case CallRetAddress__0x8048e6e: goto L_8048e6e;
case CallRetAddress__0x8048e9e: goto L_8048e9e;
case CallRetAddress__0x8048ece: goto L_8048ece;
case CallRetAddress__0x8048efe: goto L_8048efe;
case CallRetAddress__0x8048f2e: goto L_8048f2e;
case CallRetAddress__0x8048f5e: goto L_8048f5e;
case CallRetAddress__0x8048f8e: goto L_8048f8e;
case CallRetAddress__0x8048fbe: goto L_8048fbe;
case CallRetAddress__0x8048fee: goto L_8048fee;
case CallRetAddress__0x804901e: goto L_804901e;
case CallRetAddress__0x804904e: goto L_804904e;
case CallRetAddress__0x804907e: goto L_804907e;
case CallRetAddress__0x80490ae: goto L_80490ae;
case CallRetAddress__0x80490de: goto L_80490de;
case CallRetAddress__0x804910e: goto L_804910e;
case CallRetAddress__0x804913e: goto L_804913e;
case CallRetAddress__0x804916e: goto L_804916e;
case CallRetAddress__0x804919e: goto L_804919e;
case CallRetAddress__0x80491ce: goto L_80491ce;
case CallRetAddress__0x80491fe: goto L_80491fe;
case CallRetAddress__0x804922e: goto L_804922e;
case CallRetAddress__0x804925e: goto L_804925e;
case CallRetAddress__0x804928e: goto L_804928e;
case CallRetAddress__0x80492be: goto L_80492be;
case CallRetAddress__0x80492ee: goto L_80492ee;
case CallRetAddress__0x804931e: goto L_804931e;
case CallRetAddress__0x804934e: goto L_804934e;
case CallRetAddress__0x804937e: goto L_804937e;
case CallRetAddress__0x80493ae: goto L_80493ae;
case CallRetAddress__0x80493de: goto L_80493de;
case CallRetAddress__0x804940e: goto L_804940e;
case CallRetAddress__0x804943e: goto L_804943e;
case CallRetAddress__0x804946e: goto L_804946e;
case CallRetAddress__0x804949e: goto L_804949e;
case CallRetAddress__0x80494ce: goto L_80494ce;
case CallRetAddress__0x80494fe: goto L_80494fe;
case CallRetAddress__0x804952e: goto L_804952e;
case CallRetAddress__0x804955e: goto L_804955e;
case CallRetAddress__0x804958e: goto L_804958e;
case CallRetAddress__0x80495be: goto L_80495be;
case CallRetAddress__0x80495ee: goto L_80495ee;
case CallRetAddress__0x804961e: goto L_804961e;
case CallRetAddress__0x804964e: goto L_804964e;
case CallRetAddress__0x804967e: goto L_804967e;
case CallRetAddress__0x80496ae: goto L_80496ae;
case CallRetAddress__0x80496de: goto L_80496de;
case CallRetAddress__0x804970e: goto L_804970e;
case CallRetAddress__0x804973e: goto L_804973e;
case CallRetAddress__0x804976e: goto L_804976e;
case CallRetAddress__0x804979e: goto L_804979e;
case CallRetAddress__0x80497ce: goto L_80497ce;
case CallRetAddress__0x80497fe: goto L_80497fe;
case CallRetAddress__0x804982e: goto L_804982e;
case CallRetAddress__0x804985e: goto L_804985e;
case CallRetAddress__0x804988e: goto L_804988e;
case CallRetAddress__0x80498be: goto L_80498be;
case CallRetAddress__0x80498ee: goto L_80498ee;
case CallRetAddress__0x804991e: goto L_804991e;
case CallRetAddress__0x804994e: goto L_804994e;
case CallRetAddress__0x804997e: goto L_804997e;
case CallRetAddress__0x80499ae: goto L_80499ae;
case CallRetAddress__0x80499de: goto L_80499de;
case CallRetAddress__0x8049a0e: goto L_8049a0e;
case CallRetAddress__0x8049a3e: goto L_8049a3e;
case CallRetAddress__0x8049a6e: goto L_8049a6e;
case CallRetAddress__0x8049a9e: goto L_8049a9e;
case CallRetAddress__0x8049ace: goto L_8049ace;
case CallRetAddress__0x8049afe: goto L_8049afe;
case CallRetAddress__0x8049b2e: goto L_8049b2e;
case CallRetAddress__0x8049b5e: goto L_8049b5e;
case CallRetAddress__0x8049b8e: goto L_8049b8e;
case CallRetAddress__0x8049bbe: goto L_8049bbe;
case CallRetAddress__0x8049bee: goto L_8049bee;
case CallRetAddress__0x8049c1e: goto L_8049c1e;
case CallRetAddress__0x8049c4e: goto L_8049c4e;
case CallRetAddress__0x8049c7e: goto L_8049c7e;
case CallRetAddress__0x8049cae: goto L_8049cae;
case CallRetAddress__0x8049cde: goto L_8049cde;
case CallRetAddress__0x8049d0e: goto L_8049d0e;
case CallRetAddress__0x8049d36: goto L_8049d36;
case CallRetAddress__0x8049d4b: goto L_8049d4b;
case CallRetAddress__0x8049d58: goto L_8049d58;
case CallRetAddress__0x8049d67: goto L_8049d67;
case CallRetAddress__0x8049daf: goto L_8049daf;
default:
    sprintf(exception_string, "Invalid call return target.");
    exception_address = next_ip;
    goto L_RETURN;
}

// function test_target1();
// 80488b0 push %esi
L_80488b0:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80488b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80488b1 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80488b1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80488b2 xor %esi,%esi
{
esi = 0;
}

// 80488b4 mov $0x3,%ebx
{
ebx = ( +0x3);
}

// 80488b9 sub $0x10,%esp
{
esp -= ( +0x10);
compare_result = esp;
}

// 80488bc movl $0x4e20,0xc(%esp)
{
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80488bc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x4e20);
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80488c4 mov 0xc(%esp),%eax
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80488c4;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 80488c8 cmp $0x2,%eax
{
compare_result = (uint)(eax - ( +0x2));
}

// 80488cb jbe 8048907 <test_target1+0x57>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_8048907;
}
}

// 80488cd lea 0x0(%esi),%esi
{
esi = esi;
}

// 80488d0 cmp $0x2,%ebx
L_80488d0:
{
compare_result = (uint)(ebx - ( +0x2));
}

// 80488d3 jbe 80488f9 <test_target1+0x49>
{
if (compare_result == 0 || compare_result >= 0x80000000) {
    goto L_80488f9;
}
}

// 80488d5 test $0x1,%bl
{
compare_result = (uint)(*bl & ( +0x1));
}

// 80488d8 je 80488fc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_80488fc;
}
}

// 80488da mov $0x2,%ecx
{
ecx = ( +0x2);
}

// 80488df jmp 80488f2 <test_target1+0x42>
{
if (true) {
    goto L_80488f2;
}
}

// 80488e1 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 80488e8 xor %edx,%edx
L_80488e8:
{
edx = 0;
}

// 80488ea mov %ebx,%eax
{
eax = ebx;
}

// 80488ec div %ecx
{
if (edx != 0) {
ulong tmp1 =  (uint)(((ulong)edx << 32) + (ulong)eax);
ulong tmp2 = ecx;
eax = (uint)(tmp1 / tmp2);
edx = (uint)(tmp1 - tmp2 * eax);
} else
{ 
uint tmp1 = eax;
uint tmp2 = ecx;
eax = tmp1 / tmp2;
edx = tmp1 - tmp2 * eax;
}
}

// 80488ee test %edx,%edx
{
compare_result = (uint)(edx);
}

// 80488f0 je 80488fc <test_target1+0x4c>
{
if (compare_result == 0) {
    goto L_80488fc;
}
}

// 80488f2 add $0x1,%ecx
L_80488f2:
{
ecx += ( +0x1);
compare_result = ecx;
}

// 80488f5 cmp %ebx,%ecx
{
compare_result = (uint)(ecx - ebx);
}

// 80488f7 jne 80488e8 <test_target1+0x38>
{
if (compare_result != 0) {
    goto L_80488e8;
}
}

// 80488f9 add $0x1,%esi
L_80488f9:
{
esi += ( +0x1);
compare_result = esi;
}

// 80488fc mov 0xc(%esp),%eax
L_80488fc:
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80488fc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048900 add $0x1,%ebx
{
ebx += ( +0x1);
compare_result = ebx;
}

// 8048903 cmp %ebx,%eax
{
compare_result = (uint)(eax - ebx);
}

// 8048905 jae 80488d0 <test_target1+0x20>
{
if (compare_result <= 0x80000000) {
    goto L_80488d0;
}
}

// 8048907 add $0x10,%esp
L_8048907:
{
esp += ( +0x10);
compare_result = esp;
}

// 804890a mov %esi,%eax
{
eax = esi;
}

// 804890c pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804890c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804890d pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804890d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804890e ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804890e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 804890f nop 
{
}

// function test_target2();
// 8048910 push %esi
L_8048910:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048910;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048911 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048911;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048912 sub $0x1f50,%esp
{
esp -= ( +0x1f50);
compare_result = esp;
}

// 8048918 movl $0x7d0,0xc(%esp)
{
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048918;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x7d0);
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048920 mov 0xc(%esp),%eax
{
if (memcache_esp_0xc_pin == (esp +0xc)) eax= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048920;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048924 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048926 je 804893e <test_target2+0x2e>
{
if (compare_result == 0) {
    goto L_804893e;
}
}

// 8048928 lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// 804892c xor %eax,%eax
{
eax = 0;
}

// 804892e xchg %ax,%ax
{
}

// 8048930 mov 0xc(%esp),%edx
L_8048930:
{
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048930;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048934 mov %eax,(%ebx,%eax,4)
{
{
vaddr = (ebx + eax * 0x4);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
}
else if (vaddr1_index == cache_last_page2)
{
    *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048934;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
}
}

}

// 8048937 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804893a cmp %eax,%edx
{
compare_result = (uint)(edx - eax);
}

// 804893c ja 8048930 <test_target2+0x20>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_8048930;
}
}

// 804893e mov $0xc350,%esi
L_804893e:
{
esi = ( +0xc350);
}

// 8048943 xor %eax,%eax
{
eax = 0;
}

// 8048945 lea 0x0(%esi),%esi
{
esi = esi;
}

// 8048948 mov 0xc(%esp),%edx
L_8048948:
{
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048948;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 804894c test %edx,%edx
{
compare_result = (uint)(edx);
}

// 804894e je 804896e <test_target2+0x5e>
{
if (compare_result == 0) {
    goto L_804896e;
}
}

// 8048950 lea 0x10(%esp),%ebx
{
ebx = (esp +0x10);
}

// 8048954 xor %edx,%edx
{
edx = 0;
}

// 8048956 lea 0x0(%esi),%esi
{
esi = esi;
}

// 8048959 lea 0x0(%edi,%eiz,1),%edi
{
edi = (edi + eiz * 0x1);
}

// 8048960 mov 0xc(%esp),%ecx
L_8048960:
{
if (memcache_esp_0xc_pin == (esp +0xc)) ecx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ecx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    ecx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048960;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ecx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8048964 add (%ebx,%edx,4),%eax
{
{
vaddr = (ebx + edx * 0x4);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax+= (uint)(  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
}
else if (vaddr1_index == cache_last_page2)
{
    eax+= (uint)( *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048964;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax+= (uint)( *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
}
}

compare_result = eax;
}

// 8048967 add $0x1,%edx
{
edx += ( +0x1);
compare_result = edx;
}

// 804896a cmp %edx,%ecx
{
compare_result = (uint)(ecx - edx);
}

// 804896c ja 8048960 <test_target2+0x50>
{
if (compare_result != 0 && compare_result <= 0x80000000) {
    goto L_8048960;
}
}

// 804896e sub $0x1,%esi
L_804896e:
{
esi -= ( +0x1);
compare_result = esi;
}

// 8048971 jne 8048948 <test_target2+0x38>
{
if (compare_result != 0) {
    goto L_8048948;
}
}

// 8048973 add $0x1f50,%esp
{
esp += ( +0x1f50);
compare_result = esp;
}

// 8048979 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048979;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804897a pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804897a;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 804897b ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804897b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 804897c lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// function test_target4();
// 8048980 push %esi
L_8048980:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048980;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048981 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048981;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048982 sub $0x4,%esp
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048985 mov 0x10(%esp),%ebx
{
if (memcache_esp_0x10_pin == (esp +0x10)) ebx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048985;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}

}

// 8048989 test %ebx,%ebx
{
compare_result = (uint)(ebx);
}

// 804898b je 80489d3 <test_target4+0x53>
{
if (compare_result == 0) {
    goto L_80489d3;
}
}

// 804898d cmp $0x1,%ebx
{
compare_result = (uint)(ebx - ( +0x1));
}

// 8048990 je 80489d7 <test_target4+0x57>
{
if (compare_result == 0) {
    goto L_80489d7;
}
}

// 8048992 xor %esi,%esi
{
esi = 0;
}

// 8048994 jmp 80489a5 <test_target4+0x25>
{
if (true) {
    goto L_80489a5;
}
}

// 8048996 lea 0x0(%esi),%esi
{
esi = esi;
}

// 8048999 lea 0x0(%edi,%eiz,1),%edi
{
edi = (edi + eiz * 0x1);
}

// 80489a0 cmp $0x1,%ebx
L_80489a0:
{
compare_result = (uint)(ebx - ( +0x1));
}

// 80489a3 je 80489c8 <test_target4+0x48>
{
if (compare_result == 0) {
    goto L_80489c8;
}
}

// 80489a5 lea -0x1(%ebx),%eax
L_80489a5:
{
eax = (ebx -0x1);
}

// 80489a8 sub $0xc,%esp
{
esp -= ( +0xc);
compare_result = esp;
}

// 80489ab push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489ab;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80489ac call 8048980 <test_target4>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80489b1;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80489b1;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489ac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80489b1;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048980;
}
}

// 80489b1 add $0x10,%esp
L_80489b1:
{
esp += ( +0x10);
compare_result = esp;
}

// 80489b4 add %eax,%esi
{
esi += eax;
compare_result = esi;
}

// 80489b6 sub $0x2,%ebx
{
ebx -= ( +0x2);
compare_result = ebx;
}

// 80489b9 jne 80489a0 <test_target4+0x20>
{
if (compare_result != 0) {
    goto L_80489a0;
}
}

// 80489bb add $0x4,%esp
L_80489bb:
{
esp += ( +0x4);
compare_result = esp;
}

// 80489be mov %esi,%eax
{
eax = esi;
}

// 80489c0 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 80489c1 pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489c1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 80489c2 ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489c2;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 80489c3 nop 
{
}

// 80489c4 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 80489c8 add $0x1,%esi
L_80489c8:
{
esi += ( +0x1);
compare_result = esi;
}

// 80489cb add $0x4,%esp
{
esp += ( +0x4);
compare_result = esp;
}

// 80489ce mov %esi,%eax
{
eax = esi;
}

// 80489d0 pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489d0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 80489d1 pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489d1;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 80489d2 ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489d2;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 80489d3 xor %esi,%esi
L_80489d3:
{
esi = 0;
}

// 80489d5 jmp 80489bb <test_target4+0x3b>
{
if (true) {
    goto L_80489bb;
}
}

// 80489d7 mov $0x1,%esi
L_80489d7:
{
esi = ( +0x1);
}

// 80489dc jmp 80489bb <test_target4+0x3b>
{
if (true) {
    goto L_80489bb;
}
}

// 80489de xchg %ax,%ax
{
}

// function test_target3();
// 80489e0 sub $0x28,%esp
L_80489e0:
{
esp -= ( +0x28);
compare_result = esp;
}

// 80489e3 movl $0x22,0x18(%esp)
{
{
vaddr = (esp +0x18);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x18_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x18_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489e3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x18_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x22);
    memcache_esp_0x18_pin = (esp +0x18);
}
}

}

// 80489eb mov 0x18(%esp),%eax
{
if (memcache_esp_0x18_pin == (esp +0x18)) eax= (uint) memcache_esp_0x18_data; else 
{
vaddr = (esp +0x18);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x18_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x18_pin = (esp +0x18);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x18_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x18_pin = (esp +0x18);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489eb;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x18_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x18_pin = (esp +0x18);
}
}

}

// 80489ef push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489ef;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 80489f0 call 8048980 <test_target4>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80489f5;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80489f5;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80489f5;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048980;
}
}

// 80489f5 add $0x2c,%esp
L_80489f5:
{
esp += ( +0x2c);
compare_result = esp;
}

// 80489f8 ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80489f8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 80489f9 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// function test_target6();
// 8048a00 push %ebp
L_8048a00:
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a00;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebp;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a01 push %edi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a01;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a02 push %esi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a02;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a03 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a03;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a04 sub $0x2c,%esp
{
esp -= ( +0x2c);
compare_result = esp;
}

// 8048a07 mov 0x40(%esp),%ebx
{
if (memcache_esp_0x40_pin == (esp +0x40)) ebx= (uint) memcache_esp_0x40_data; else 
{
vaddr = (esp +0x40);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x40_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x40_pin = (esp +0x40);
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x40_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x40_pin = (esp +0x40);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a07;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x40_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x40_pin = (esp +0x40);
}
}

}

// 8048a0b mov 0x44(%esp),%esi
{
if (memcache_esp_0x44_pin == (esp +0x44)) esi= (uint) memcache_esp_0x44_data; else 
{
vaddr = (esp +0x44);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x44_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x44_pin = (esp +0x44);
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x44_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x44_pin = (esp +0x44);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a0b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x44_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x44_pin = (esp +0x44);
}
}

}

// 8048a0f mov 0x48(%esp),%edi
{
if (memcache_esp_0x48_pin == (esp +0x48)) edi= (uint) memcache_esp_0x48_data; else 
{
vaddr = (esp +0x48);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edi= (uint)(     memcache_esp_0x48_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x48_pin = (esp +0x48);
}
else if (vaddr1_index == cache_last_page2)
{
    edi= (uint)(    memcache_esp_0x48_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x48_pin = (esp +0x48);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a0f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edi= (uint)(    memcache_esp_0x48_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x48_pin = (esp +0x48);
}
}

}

// 8048a13 cmp %esi,%ebx
{
compare_result = (uint)(ebx - esi);
}

// 8048a15 mov %edi,%eax
{
eax = edi;
}

// 8048a17 jle 8049d6a <test_target6+0x136a>
{
if (compare_result == 0) {
    goto L_8049d6a;
}
}

// 8048a1d movl $0x0,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a1d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x0;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a25 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a29 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a2b jne 8048a43 <test_target6+0x43>
{
if (compare_result != 0) {
    goto L_8048a43;
}
}

// 8048a2d jmp 8048a80 <test_target6+0x80>
{
if (true) {
    goto L_8048a80;
}
}

// 8048a2f nop 
{
}

// 8048a30 mov 0x1c(%esp),%eax
L_8048a30:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a30;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a34 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048a37 mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a37;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a3b mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a3b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a3f test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a41 je 8048a80 <test_target6+0x80>
{
if (compare_result == 0) {
    goto L_8048a80;
}
}

// 8048a43 sub $0x4,%esp
L_8048a43:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048a46 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a46;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a48 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a48;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a4a push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a4a;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a4c call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a51;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a51;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a4c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048a51;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048a51 add $0x10,%esp
L_8048a51:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048a54 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a56 jne 8048a30 <test_target6+0x30>
{
if (compare_result != 0) {
    goto L_8048a30;
}
}

// 8048a58 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a58;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a5c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a5e je 8048ab0 <test_target6+0xb0>
{
if (compare_result == 0) {
    goto L_8048ab0;
}
}

// 8048a60 sub $0x4,%esp
L_8048a60:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048a63 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a63;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a65 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a67 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a67;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a69 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a6e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a6e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a69;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048a6e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048a6e add $0x10,%esp
L_8048a6e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048a71 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a73 je 8048ab0 <test_target6+0xb0>
{
if (compare_result == 0) {
    goto L_8048ab0;
}
}

// 8048a75 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a79 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048a7c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a7c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a80 mov 0x1c(%esp),%eax
L_8048a80:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a80;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a84 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a86 jne 8048a60 <test_target6+0x60>
{
if (compare_result != 0) {
    goto L_8048a60;
}
}

// 8048a88 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a88;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048a8c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048a8e je 8048ae0 <test_target6+0xe0>
{
if (compare_result == 0) {
    goto L_8048ae0;
}
}

// 8048a90 sub $0x4,%esp
L_8048a90:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048a93 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a93;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a95 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a97 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a97;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048a99 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a9e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048a9e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048a99;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048a9e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048a9e add $0x10,%esp
L_8048a9e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048aa1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048aa3 je 8048ae0 <test_target6+0xe0>
{
if (compare_result == 0) {
    goto L_8048ae0;
}
}

// 8048aa5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048aa5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048aa9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048aac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048aac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ab0 mov 0x1c(%esp),%eax
L_8048ab0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ab0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ab4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ab6 jne 8048a90 <test_target6+0x90>
{
if (compare_result != 0) {
    goto L_8048a90;
}
}

// 8048ab8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ab8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048abc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048abe je 8048b10 <test_target6+0x110>
{
if (compare_result == 0) {
    goto L_8048b10;
}
}

// 8048ac0 sub $0x4,%esp
L_8048ac0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048ac3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ac3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ac5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ac5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ac7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ac7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ac9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048ace;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048ace;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ac9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048ace;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048ace add $0x10,%esp
L_8048ace:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048ad1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ad3 je 8048b10 <test_target6+0x110>
{
if (compare_result == 0) {
    goto L_8048b10;
}
}

// 8048ad5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ad5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ad9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048adc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048adc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ae0 mov 0x1c(%esp),%eax
L_8048ae0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ae0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ae4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ae6 jne 8048ac0 <test_target6+0xc0>
{
if (compare_result != 0) {
    goto L_8048ac0;
}
}

// 8048ae8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ae8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048aec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048aee je 8048b40 <test_target6+0x140>
{
if (compare_result == 0) {
    goto L_8048b40;
}
}

// 8048af0 sub $0x4,%esp
L_8048af0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048af3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048af3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048af5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048af5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048af7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048af7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048af9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048afe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048afe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048af9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048afe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048afe add $0x10,%esp
L_8048afe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048b01 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b03 je 8048b40 <test_target6+0x140>
{
if (compare_result == 0) {
    goto L_8048b40;
}
}

// 8048b05 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b09 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048b0c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b0c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b10 mov 0x1c(%esp),%eax
L_8048b10:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b10;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b14 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b16 jne 8048af0 <test_target6+0xf0>
{
if (compare_result != 0) {
    goto L_8048af0;
}
}

// 8048b18 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b18;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b1c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b1e je 8048b70 <test_target6+0x170>
{
if (compare_result == 0) {
    goto L_8048b70;
}
}

// 8048b20 sub $0x4,%esp
L_8048b20:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048b23 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b23;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b25 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b27 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b27;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b29 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b2e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b2e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b29;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048b2e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048b2e add $0x10,%esp
L_8048b2e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048b31 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b33 je 8048b70 <test_target6+0x170>
{
if (compare_result == 0) {
    goto L_8048b70;
}
}

// 8048b35 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b35;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b39 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048b3c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b3c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b40 mov 0x1c(%esp),%eax
L_8048b40:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b40;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b44 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b46 jne 8048b20 <test_target6+0x120>
{
if (compare_result != 0) {
    goto L_8048b20;
}
}

// 8048b48 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b48;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b4c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b4e je 8048ba0 <test_target6+0x1a0>
{
if (compare_result == 0) {
    goto L_8048ba0;
}
}

// 8048b50 sub $0x4,%esp
L_8048b50:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048b53 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b53;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b55 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b57 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b57;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b59 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b5e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b5e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b59;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048b5e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048b5e add $0x10,%esp
L_8048b5e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048b61 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b63 je 8048ba0 <test_target6+0x1a0>
{
if (compare_result == 0) {
    goto L_8048ba0;
}
}

// 8048b65 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b69 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048b6c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b6c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b70 mov 0x1c(%esp),%eax
L_8048b70:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b70;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b74 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b76 jne 8048b50 <test_target6+0x150>
{
if (compare_result != 0) {
    goto L_8048b50;
}
}

// 8048b78 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b78;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b7c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b7e je 8048bd0 <test_target6+0x1d0>
{
if (compare_result == 0) {
    goto L_8048bd0;
}
}

// 8048b80 sub $0x4,%esp
L_8048b80:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048b83 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b83;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b85 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b87 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b87;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048b89 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b8e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048b8e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b89;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048b8e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048b8e add $0x10,%esp
L_8048b8e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048b91 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048b93 je 8048bd0 <test_target6+0x1d0>
{
if (compare_result == 0) {
    goto L_8048bd0;
}
}

// 8048b95 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048b99 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048b9c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048b9c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ba0 mov 0x1c(%esp),%eax
L_8048ba0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ba0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ba4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ba6 jne 8048b80 <test_target6+0x180>
{
if (compare_result != 0) {
    goto L_8048b80;
}
}

// 8048ba8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ba8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048bae je 8048c00 <test_target6+0x200>
{
if (compare_result == 0) {
    goto L_8048c00;
}
}

// 8048bb0 sub $0x4,%esp
L_8048bb0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048bb3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bb3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048bb5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bb5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048bb7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bb7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048bb9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048bbe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048bbe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bb9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048bbe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048bbe add $0x10,%esp
L_8048bbe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048bc1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048bc3 je 8048c00 <test_target6+0x200>
{
if (compare_result == 0) {
    goto L_8048c00;
}
}

// 8048bc5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bc5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bc9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048bcc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bcc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bd0 mov 0x1c(%esp),%eax
L_8048bd0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bd0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bd4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048bd6 jne 8048bb0 <test_target6+0x1b0>
{
if (compare_result != 0) {
    goto L_8048bb0;
}
}

// 8048bd8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bd8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bdc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048bde je 8048c08 <test_target6+0x208>
{
if (compare_result == 0) {
    goto L_8048c08;
}
}

// 8048be0 sub $0x4,%esp
L_8048be0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048be3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048be3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048be5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048be5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048be7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048be7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048be9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048bee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048bee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048be9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048bee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048bee add $0x10,%esp
L_8048bee:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048bf1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048bf3 je 8048c08 <test_target6+0x208>
{
if (compare_result == 0) {
    goto L_8048c08;
}
}

// 8048bf5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bf5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048bf9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048bfc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048bfc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c00 mov 0x1c(%esp),%eax
L_8048c00:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c00;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c04 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c06 jne 8048be0 <test_target6+0x1e0>
{
if (compare_result != 0) {
    goto L_8048be0;
}
}

// 8048c08 mov 0x1c(%esp),%eax
L_8048c08:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c08;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c0c add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048c0f mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c0f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c13 jmp 8048c2d <test_target6+0x22d>
{
if (true) {
    goto L_8048c2d;
}
}

// 8048c15 lea 0x0(%esi),%esi
{
esi = esi;
}

// 8048c18 sub $0x4,%esp
L_8048c18:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048c1b push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c1b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c1d push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c1d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c1f push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c1f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c21 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c26;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c26;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c21;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048c26;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048c26 add $0x10,%esp
L_8048c26:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048c29 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c2b je 8048c70 <test_target6+0x270>
{
if (compare_result == 0) {
    goto L_8048c70;
}
}

// 8048c2d mov 0x1c(%esp),%eax
L_8048c2d:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c2d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c31 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048c34 mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c34;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c38 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c38;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c3c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c3e jne 8048c18 <test_target6+0x218>
{
if (compare_result != 0) {
    goto L_8048c18;
}
}

// 8048c40 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c40;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c44 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c46 je 8048ca0 <test_target6+0x2a0>
{
if (compare_result == 0) {
    goto L_8048ca0;
}
}

// 8048c48 nop 
{
}

// 8048c49 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 8048c50 sub $0x4,%esp
L_8048c50:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048c53 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c53;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c55 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c57 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c57;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c59 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c5e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c5e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c59;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048c5e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048c5e add $0x10,%esp
L_8048c5e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048c61 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c63 je 8048ca0 <test_target6+0x2a0>
{
if (compare_result == 0) {
    goto L_8048ca0;
}
}

// 8048c65 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c69 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048c6c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c6c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c70 mov 0x1c(%esp),%eax
L_8048c70:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c70;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c74 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c76 jne 8048c50 <test_target6+0x250>
{
if (compare_result != 0) {
    goto L_8048c50;
}
}

// 8048c78 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c78;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c7c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c7e je 8048cd0 <test_target6+0x2d0>
{
if (compare_result == 0) {
    goto L_8048cd0;
}
}

// 8048c80 sub $0x4,%esp
L_8048c80:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048c83 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c83;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c85 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c87 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c87;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048c89 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c8e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048c8e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c89;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048c8e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048c8e add $0x10,%esp
L_8048c8e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048c91 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048c93 je 8048cd0 <test_target6+0x2d0>
{
if (compare_result == 0) {
    goto L_8048cd0;
}
}

// 8048c95 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048c99 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048c9c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048c9c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ca0 mov 0x1c(%esp),%eax
L_8048ca0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ca0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ca4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ca6 jne 8048c80 <test_target6+0x280>
{
if (compare_result != 0) {
    goto L_8048c80;
}
}

// 8048ca8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ca8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048cae je 8048d00 <test_target6+0x300>
{
if (compare_result == 0) {
    goto L_8048d00;
}
}

// 8048cb0 sub $0x4,%esp
L_8048cb0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048cb3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cb3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048cb5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cb5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048cb7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cb7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048cb9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048cbe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048cbe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cb9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048cbe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048cbe add $0x10,%esp
L_8048cbe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048cc1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048cc3 je 8048d00 <test_target6+0x300>
{
if (compare_result == 0) {
    goto L_8048d00;
}
}

// 8048cc5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cc5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cc9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048ccc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ccc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cd0 mov 0x1c(%esp),%eax
L_8048cd0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cd0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cd4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048cd6 jne 8048cb0 <test_target6+0x2b0>
{
if (compare_result != 0) {
    goto L_8048cb0;
}
}

// 8048cd8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cd8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cdc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048cde je 8048d30 <test_target6+0x330>
{
if (compare_result == 0) {
    goto L_8048d30;
}
}

// 8048ce0 sub $0x4,%esp
L_8048ce0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048ce3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ce3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ce5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ce5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ce7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ce7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ce9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048cee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048cee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ce9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048cee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048cee add $0x10,%esp
L_8048cee:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048cf1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048cf3 je 8048d30 <test_target6+0x330>
{
if (compare_result == 0) {
    goto L_8048d30;
}
}

// 8048cf5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cf5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048cf9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048cfc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048cfc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d00 mov 0x1c(%esp),%eax
L_8048d00:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d00;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d04 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d06 jne 8048ce0 <test_target6+0x2e0>
{
if (compare_result != 0) {
    goto L_8048ce0;
}
}

// 8048d08 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d08;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d0c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d0e je 8048d60 <test_target6+0x360>
{
if (compare_result == 0) {
    goto L_8048d60;
}
}

// 8048d10 sub $0x4,%esp
L_8048d10:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048d13 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d13;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d15 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d17 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d17;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d19 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d1e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d1e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d19;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048d1e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048d1e add $0x10,%esp
L_8048d1e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048d21 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d23 je 8048d60 <test_target6+0x360>
{
if (compare_result == 0) {
    goto L_8048d60;
}
}

// 8048d25 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d29 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048d2c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d2c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d30 mov 0x1c(%esp),%eax
L_8048d30:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d30;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d34 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d36 jne 8048d10 <test_target6+0x310>
{
if (compare_result != 0) {
    goto L_8048d10;
}
}

// 8048d38 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d38;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d3c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d3e je 8048d90 <test_target6+0x390>
{
if (compare_result == 0) {
    goto L_8048d90;
}
}

// 8048d40 sub $0x4,%esp
L_8048d40:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048d43 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d43;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d45 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d47 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d47;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d49 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d4e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d4e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d49;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048d4e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048d4e add $0x10,%esp
L_8048d4e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048d51 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d53 je 8048d90 <test_target6+0x390>
{
if (compare_result == 0) {
    goto L_8048d90;
}
}

// 8048d55 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d59 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048d5c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d5c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d60 mov 0x1c(%esp),%eax
L_8048d60:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d60;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d64 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d66 jne 8048d40 <test_target6+0x340>
{
if (compare_result != 0) {
    goto L_8048d40;
}
}

// 8048d68 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d68;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d6c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d6e je 8048dc0 <test_target6+0x3c0>
{
if (compare_result == 0) {
    goto L_8048dc0;
}
}

// 8048d70 sub $0x4,%esp
L_8048d70:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048d73 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d73;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d75 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d77 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d77;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048d79 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d7e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048d7e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d79;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048d7e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048d7e add $0x10,%esp
L_8048d7e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048d81 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d83 je 8048dc0 <test_target6+0x3c0>
{
if (compare_result == 0) {
    goto L_8048dc0;
}
}

// 8048d85 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d89 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048d8c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d8c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d90 mov 0x1c(%esp),%eax
L_8048d90:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d90;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d94 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d96 jne 8048d70 <test_target6+0x370>
{
if (compare_result != 0) {
    goto L_8048d70;
}
}

// 8048d98 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048d98;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048d9c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048d9e je 8048df0 <test_target6+0x3f0>
{
if (compare_result == 0) {
    goto L_8048df0;
}
}

// 8048da0 sub $0x4,%esp
L_8048da0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048da3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048da3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048da5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048da5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048da7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048da7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048da9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048dae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048dae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048da9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048dae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048dae add $0x10,%esp
L_8048dae:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048db1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048db3 je 8048df0 <test_target6+0x3f0>
{
if (compare_result == 0) {
    goto L_8048df0;
}
}

// 8048db5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048db5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048db9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048dbc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dbc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048dc0 mov 0x1c(%esp),%eax
L_8048dc0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dc0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048dc4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048dc6 jne 8048da0 <test_target6+0x3a0>
{
if (compare_result != 0) {
    goto L_8048da0;
}
}

// 8048dc8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dc8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048dcc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048dce je 8048e20 <test_target6+0x420>
{
if (compare_result == 0) {
    goto L_8048e20;
}
}

// 8048dd0 sub $0x4,%esp
L_8048dd0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048dd3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dd3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048dd5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dd5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048dd7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dd7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048dd9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048dde;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048dde;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dd9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048dde;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048dde add $0x10,%esp
L_8048dde:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048de1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048de3 je 8048e20 <test_target6+0x420>
{
if (compare_result == 0) {
    goto L_8048e20;
}
}

// 8048de5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048de5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048de9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048dec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048dec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048df0 mov 0x1c(%esp),%eax
L_8048df0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048df0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048df4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048df6 jne 8048dd0 <test_target6+0x3d0>
{
if (compare_result != 0) {
    goto L_8048dd0;
}
}

// 8048df8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048df8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048dfc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048dfe je 8048e50 <test_target6+0x450>
{
if (compare_result == 0) {
    goto L_8048e50;
}
}

// 8048e00 sub $0x4,%esp
L_8048e00:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048e03 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e03;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e05 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e07 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e07;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e09 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e0e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e0e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e09;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048e0e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048e0e add $0x10,%esp
L_8048e0e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048e11 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e13 je 8048e50 <test_target6+0x450>
{
if (compare_result == 0) {
    goto L_8048e50;
}
}

// 8048e15 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e19 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048e1c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e1c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e20 mov 0x1c(%esp),%eax
L_8048e20:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e20;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e24 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e26 jne 8048e00 <test_target6+0x400>
{
if (compare_result != 0) {
    goto L_8048e00;
}
}

// 8048e28 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e28;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e2c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e2e je 8048e80 <test_target6+0x480>
{
if (compare_result == 0) {
    goto L_8048e80;
}
}

// 8048e30 sub $0x4,%esp
L_8048e30:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048e33 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e33;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e35 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e35;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e37 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e37;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e39 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e3e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e3e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e39;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048e3e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048e3e add $0x10,%esp
L_8048e3e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048e41 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e43 je 8048e80 <test_target6+0x480>
{
if (compare_result == 0) {
    goto L_8048e80;
}
}

// 8048e45 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e49 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048e4c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e4c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e50 mov 0x1c(%esp),%eax
L_8048e50:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e50;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e54 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e56 jne 8048e30 <test_target6+0x430>
{
if (compare_result != 0) {
    goto L_8048e30;
}
}

// 8048e58 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e58;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e5c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e5e je 8048eb0 <test_target6+0x4b0>
{
if (compare_result == 0) {
    goto L_8048eb0;
}
}

// 8048e60 sub $0x4,%esp
L_8048e60:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048e63 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e63;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e65 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e67 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e67;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e69 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e6e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e6e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e69;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048e6e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048e6e add $0x10,%esp
L_8048e6e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048e71 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e73 je 8048eb0 <test_target6+0x4b0>
{
if (compare_result == 0) {
    goto L_8048eb0;
}
}

// 8048e75 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e79 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048e7c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e7c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e80 mov 0x1c(%esp),%eax
L_8048e80:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e80;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e84 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e86 jne 8048e60 <test_target6+0x460>
{
if (compare_result != 0) {
    goto L_8048e60;
}
}

// 8048e88 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e88;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048e8c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048e8e je 8048ee0 <test_target6+0x4e0>
{
if (compare_result == 0) {
    goto L_8048ee0;
}
}

// 8048e90 sub $0x4,%esp
L_8048e90:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048e93 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e93;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e95 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e97 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e97;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048e99 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e9e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048e9e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048e99;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048e9e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048e9e add $0x10,%esp
L_8048e9e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048ea1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ea3 je 8048ee0 <test_target6+0x4e0>
{
if (compare_result == 0) {
    goto L_8048ee0;
}
}

// 8048ea5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ea5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ea9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048eac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048eac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048eb0 mov 0x1c(%esp),%eax
L_8048eb0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048eb0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048eb4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048eb6 jne 8048e90 <test_target6+0x490>
{
if (compare_result != 0) {
    goto L_8048e90;
}
}

// 8048eb8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048eb8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ebc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ebe je 8048f10 <test_target6+0x510>
{
if (compare_result == 0) {
    goto L_8048f10;
}
}

// 8048ec0 sub $0x4,%esp
L_8048ec0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048ec3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ec3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ec5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ec5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ec7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ec7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ec9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048ece;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048ece;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ec9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048ece;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048ece add $0x10,%esp
L_8048ece:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048ed1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ed3 je 8048f10 <test_target6+0x510>
{
if (compare_result == 0) {
    goto L_8048f10;
}
}

// 8048ed5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ed5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ed9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048edc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048edc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ee0 mov 0x1c(%esp),%eax
L_8048ee0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ee0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ee4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ee6 jne 8048ec0 <test_target6+0x4c0>
{
if (compare_result != 0) {
    goto L_8048ec0;
}
}

// 8048ee8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ee8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048eec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048eee je 8048f40 <test_target6+0x540>
{
if (compare_result == 0) {
    goto L_8048f40;
}
}

// 8048ef0 sub $0x4,%esp
L_8048ef0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048ef3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ef3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ef5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ef5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ef7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ef7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048ef9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048efe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048efe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ef9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048efe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048efe add $0x10,%esp
L_8048efe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048f01 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f03 je 8048f40 <test_target6+0x540>
{
if (compare_result == 0) {
    goto L_8048f40;
}
}

// 8048f05 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f09 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048f0c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f0c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f10 mov 0x1c(%esp),%eax
L_8048f10:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f10;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f14 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f16 jne 8048ef0 <test_target6+0x4f0>
{
if (compare_result != 0) {
    goto L_8048ef0;
}
}

// 8048f18 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f18;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f1c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f1e je 8048f70 <test_target6+0x570>
{
if (compare_result == 0) {
    goto L_8048f70;
}
}

// 8048f20 sub $0x4,%esp
L_8048f20:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048f23 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f23;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f25 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f27 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f27;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f29 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f2e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f2e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f29;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048f2e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048f2e add $0x10,%esp
L_8048f2e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048f31 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f33 je 8048f70 <test_target6+0x570>
{
if (compare_result == 0) {
    goto L_8048f70;
}
}

// 8048f35 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f35;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f39 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048f3c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f3c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f40 mov 0x1c(%esp),%eax
L_8048f40:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f40;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f44 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f46 jne 8048f20 <test_target6+0x520>
{
if (compare_result != 0) {
    goto L_8048f20;
}
}

// 8048f48 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f48;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f4c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f4e je 8048fa0 <test_target6+0x5a0>
{
if (compare_result == 0) {
    goto L_8048fa0;
}
}

// 8048f50 sub $0x4,%esp
L_8048f50:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048f53 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f53;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f55 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f57 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f57;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f59 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f5e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f5e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f59;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048f5e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048f5e add $0x10,%esp
L_8048f5e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048f61 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f63 je 8048fa0 <test_target6+0x5a0>
{
if (compare_result == 0) {
    goto L_8048fa0;
}
}

// 8048f65 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f69 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048f6c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f6c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f70 mov 0x1c(%esp),%eax
L_8048f70:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f70;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f74 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f76 jne 8048f50 <test_target6+0x550>
{
if (compare_result != 0) {
    goto L_8048f50;
}
}

// 8048f78 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f78;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f7c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f7e je 8048fd0 <test_target6+0x5d0>
{
if (compare_result == 0) {
    goto L_8048fd0;
}
}

// 8048f80 sub $0x4,%esp
L_8048f80:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048f83 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f83;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f85 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f87 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f87;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048f89 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f8e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048f8e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f89;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048f8e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048f8e add $0x10,%esp
L_8048f8e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048f91 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048f93 je 8048fd0 <test_target6+0x5d0>
{
if (compare_result == 0) {
    goto L_8048fd0;
}
}

// 8048f95 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048f99 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048f9c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048f9c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fa0 mov 0x1c(%esp),%eax
L_8048fa0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fa0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fa4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048fa6 jne 8048f80 <test_target6+0x580>
{
if (compare_result != 0) {
    goto L_8048f80;
}
}

// 8048fa8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fa8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048fae je 8049000 <test_target6+0x600>
{
if (compare_result == 0) {
    goto L_8049000;
}
}

// 8048fb0 sub $0x4,%esp
L_8048fb0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048fb3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fb3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fb5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fb5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fb7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fb7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fb9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048fbe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048fbe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fb9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048fbe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048fbe add $0x10,%esp
L_8048fbe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048fc1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048fc3 je 8049000 <test_target6+0x600>
{
if (compare_result == 0) {
    goto L_8049000;
}
}

// 8048fc5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fc5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fc9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048fcc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fcc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fd0 mov 0x1c(%esp),%eax
L_8048fd0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fd0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fd4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048fd6 jne 8048fb0 <test_target6+0x5b0>
{
if (compare_result != 0) {
    goto L_8048fb0;
}
}

// 8048fd8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fd8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048fdc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048fde je 8049030 <test_target6+0x630>
{
if (compare_result == 0) {
    goto L_8049030;
}
}

// 8048fe0 sub $0x4,%esp
L_8048fe0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8048fe3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fe3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fe5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fe5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fe7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fe7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8048fe9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8048fee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8048fee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048fe9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8048fee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8048fee add $0x10,%esp
L_8048fee:
{
esp += ( +0x10);
compare_result = esp;
}

// 8048ff1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8048ff3 je 8049030 <test_target6+0x630>
{
if (compare_result == 0) {
    goto L_8049030;
}
}

// 8048ff5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ff5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8048ff9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8048ffc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8048ffc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049000 mov 0x1c(%esp),%eax
L_8049000:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049000;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049004 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049006 jne 8048fe0 <test_target6+0x5e0>
{
if (compare_result != 0) {
    goto L_8048fe0;
}
}

// 8049008 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049008;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804900c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804900e je 8049060 <test_target6+0x660>
{
if (compare_result == 0) {
    goto L_8049060;
}
}

// 8049010 sub $0x4,%esp
L_8049010:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049013 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049013;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049015 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049015;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049017 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049017;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049019 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804901e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804901e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049019;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804901e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804901e add $0x10,%esp
L_804901e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049021 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049023 je 8049060 <test_target6+0x660>
{
if (compare_result == 0) {
    goto L_8049060;
}
}

// 8049025 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049025;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049029 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804902c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804902c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049030 mov 0x1c(%esp),%eax
L_8049030:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049030;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049034 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049036 jne 8049010 <test_target6+0x610>
{
if (compare_result != 0) {
    goto L_8049010;
}
}

// 8049038 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049038;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804903c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804903e je 8049090 <test_target6+0x690>
{
if (compare_result == 0) {
    goto L_8049090;
}
}

// 8049040 sub $0x4,%esp
L_8049040:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049043 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049043;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049045 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049045;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049047 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049047;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049049 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804904e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804904e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049049;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804904e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804904e add $0x10,%esp
L_804904e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049051 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049053 je 8049090 <test_target6+0x690>
{
if (compare_result == 0) {
    goto L_8049090;
}
}

// 8049055 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049055;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049059 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804905c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804905c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049060 mov 0x1c(%esp),%eax
L_8049060:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049060;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049064 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049066 jne 8049040 <test_target6+0x640>
{
if (compare_result != 0) {
    goto L_8049040;
}
}

// 8049068 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049068;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804906c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804906e je 80490c0 <test_target6+0x6c0>
{
if (compare_result == 0) {
    goto L_80490c0;
}
}

// 8049070 sub $0x4,%esp
L_8049070:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049073 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049073;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049075 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049075;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049077 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049077;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049079 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804907e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804907e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049079;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804907e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804907e add $0x10,%esp
L_804907e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049081 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049083 je 80490c0 <test_target6+0x6c0>
{
if (compare_result == 0) {
    goto L_80490c0;
}
}

// 8049085 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049085;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049089 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804908c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804908c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049090 mov 0x1c(%esp),%eax
L_8049090:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049090;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049094 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049096 jne 8049070 <test_target6+0x670>
{
if (compare_result != 0) {
    goto L_8049070;
}
}

// 8049098 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049098;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804909c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804909e je 80490f0 <test_target6+0x6f0>
{
if (compare_result == 0) {
    goto L_80490f0;
}
}

// 80490a0 sub $0x4,%esp
L_80490a0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80490a3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490a3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490a5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490a7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490a7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490a9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80490ae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80490ae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490a9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80490ae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80490ae add $0x10,%esp
L_80490ae:
{
esp += ( +0x10);
compare_result = esp;
}

// 80490b1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490b3 je 80490f0 <test_target6+0x6f0>
{
if (compare_result == 0) {
    goto L_80490f0;
}
}

// 80490b5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490b9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80490bc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490bc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490c0 mov 0x1c(%esp),%eax
L_80490c0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490c4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490c6 jne 80490a0 <test_target6+0x6a0>
{
if (compare_result != 0) {
    goto L_80490a0;
}
}

// 80490c8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490c8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490cc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490ce je 8049120 <test_target6+0x720>
{
if (compare_result == 0) {
    goto L_8049120;
}
}

// 80490d0 sub $0x4,%esp
L_80490d0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80490d3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490d3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490d5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490d7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490d7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80490d9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80490de;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80490de;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490d9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80490de;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80490de add $0x10,%esp
L_80490de:
{
esp += ( +0x10);
compare_result = esp;
}

// 80490e1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490e3 je 8049120 <test_target6+0x720>
{
if (compare_result == 0) {
    goto L_8049120;
}
}

// 80490e5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490e9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80490ec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490ec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490f0 mov 0x1c(%esp),%eax
L_80490f0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490f4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490f6 jne 80490d0 <test_target6+0x6d0>
{
if (compare_result != 0) {
    goto L_80490d0;
}
}

// 80490f8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80490f8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80490fc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80490fe je 8049150 <test_target6+0x750>
{
if (compare_result == 0) {
    goto L_8049150;
}
}

// 8049100 sub $0x4,%esp
L_8049100:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049103 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049103;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049105 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049105;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049107 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049107;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049109 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804910e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804910e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049109;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804910e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804910e add $0x10,%esp
L_804910e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049111 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049113 je 8049150 <test_target6+0x750>
{
if (compare_result == 0) {
    goto L_8049150;
}
}

// 8049115 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049115;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049119 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804911c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804911c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049120 mov 0x1c(%esp),%eax
L_8049120:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049120;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049124 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049126 jne 8049100 <test_target6+0x700>
{
if (compare_result != 0) {
    goto L_8049100;
}
}

// 8049128 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049128;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804912c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804912e je 8049180 <test_target6+0x780>
{
if (compare_result == 0) {
    goto L_8049180;
}
}

// 8049130 sub $0x4,%esp
L_8049130:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049133 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049133;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049135 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049135;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049137 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049137;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049139 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804913e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804913e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049139;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804913e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804913e add $0x10,%esp
L_804913e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049141 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049143 je 8049180 <test_target6+0x780>
{
if (compare_result == 0) {
    goto L_8049180;
}
}

// 8049145 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049145;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049149 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804914c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804914c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049150 mov 0x1c(%esp),%eax
L_8049150:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049150;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049154 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049156 jne 8049130 <test_target6+0x730>
{
if (compare_result != 0) {
    goto L_8049130;
}
}

// 8049158 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049158;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804915c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804915e je 80491b0 <test_target6+0x7b0>
{
if (compare_result == 0) {
    goto L_80491b0;
}
}

// 8049160 sub $0x4,%esp
L_8049160:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049163 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049163;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049165 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049165;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049167 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049167;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049169 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804916e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804916e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049169;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804916e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804916e add $0x10,%esp
L_804916e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049171 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049173 je 80491b0 <test_target6+0x7b0>
{
if (compare_result == 0) {
    goto L_80491b0;
}
}

// 8049175 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049175;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049179 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804917c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804917c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049180 mov 0x1c(%esp),%eax
L_8049180:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049180;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049184 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049186 jne 8049160 <test_target6+0x760>
{
if (compare_result != 0) {
    goto L_8049160;
}
}

// 8049188 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049188;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804918c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804918e je 80491e0 <test_target6+0x7e0>
{
if (compare_result == 0) {
    goto L_80491e0;
}
}

// 8049190 sub $0x4,%esp
L_8049190:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049193 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049193;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049195 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049195;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049197 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049197;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049199 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804919e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804919e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049199;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804919e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804919e add $0x10,%esp
L_804919e:
{
esp += ( +0x10);
compare_result = esp;
}

// 80491a1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491a3 je 80491e0 <test_target6+0x7e0>
{
if (compare_result == 0) {
    goto L_80491e0;
}
}

// 80491a5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491a9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80491ac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491ac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491b0 mov 0x1c(%esp),%eax
L_80491b0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491b4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491b6 jne 8049190 <test_target6+0x790>
{
if (compare_result != 0) {
    goto L_8049190;
}
}

// 80491b8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491b8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491bc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491be je 8049210 <test_target6+0x810>
{
if (compare_result == 0) {
    goto L_8049210;
}
}

// 80491c0 sub $0x4,%esp
L_80491c0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80491c3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491c3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491c5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491c7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491c7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491c9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80491ce;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80491ce;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491c9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80491ce;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80491ce add $0x10,%esp
L_80491ce:
{
esp += ( +0x10);
compare_result = esp;
}

// 80491d1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491d3 je 8049210 <test_target6+0x810>
{
if (compare_result == 0) {
    goto L_8049210;
}
}

// 80491d5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491d9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80491dc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491dc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491e0 mov 0x1c(%esp),%eax
L_80491e0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491e0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491e4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491e6 jne 80491c0 <test_target6+0x7c0>
{
if (compare_result != 0) {
    goto L_80491c0;
}
}

// 80491e8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491e8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80491ec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80491ee je 8049240 <test_target6+0x840>
{
if (compare_result == 0) {
    goto L_8049240;
}
}

// 80491f0 sub $0x4,%esp
L_80491f0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80491f3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491f3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491f5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491f7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491f7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80491f9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80491fe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80491fe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80491f9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80491fe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80491fe add $0x10,%esp
L_80491fe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049201 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049203 je 8049240 <test_target6+0x840>
{
if (compare_result == 0) {
    goto L_8049240;
}
}

// 8049205 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049205;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049209 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804920c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804920c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049210 mov 0x1c(%esp),%eax
L_8049210:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049210;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049214 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049216 jne 80491f0 <test_target6+0x7f0>
{
if (compare_result != 0) {
    goto L_80491f0;
}
}

// 8049218 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049218;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804921c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804921e je 8049270 <test_target6+0x870>
{
if (compare_result == 0) {
    goto L_8049270;
}
}

// 8049220 sub $0x4,%esp
L_8049220:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049223 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049223;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049225 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049225;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049227 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049227;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049229 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804922e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804922e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049229;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804922e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804922e add $0x10,%esp
L_804922e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049231 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049233 je 8049270 <test_target6+0x870>
{
if (compare_result == 0) {
    goto L_8049270;
}
}

// 8049235 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049235;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049239 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804923c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804923c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049240 mov 0x1c(%esp),%eax
L_8049240:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049240;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049244 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049246 jne 8049220 <test_target6+0x820>
{
if (compare_result != 0) {
    goto L_8049220;
}
}

// 8049248 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049248;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804924c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804924e je 80492a0 <test_target6+0x8a0>
{
if (compare_result == 0) {
    goto L_80492a0;
}
}

// 8049250 sub $0x4,%esp
L_8049250:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049253 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049253;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049255 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049255;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049257 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049257;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049259 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804925e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804925e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049259;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804925e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804925e add $0x10,%esp
L_804925e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049261 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049263 je 80492a0 <test_target6+0x8a0>
{
if (compare_result == 0) {
    goto L_80492a0;
}
}

// 8049265 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049265;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049269 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804926c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804926c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049270 mov 0x1c(%esp),%eax
L_8049270:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049270;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049274 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049276 jne 8049250 <test_target6+0x850>
{
if (compare_result != 0) {
    goto L_8049250;
}
}

// 8049278 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049278;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804927c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804927e je 80492d0 <test_target6+0x8d0>
{
if (compare_result == 0) {
    goto L_80492d0;
}
}

// 8049280 sub $0x4,%esp
L_8049280:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049283 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049283;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049285 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049285;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049287 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049287;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049289 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804928e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804928e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049289;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804928e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804928e add $0x10,%esp
L_804928e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049291 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049293 je 80492d0 <test_target6+0x8d0>
{
if (compare_result == 0) {
    goto L_80492d0;
}
}

// 8049295 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049295;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049299 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804929c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804929c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492a0 mov 0x1c(%esp),%eax
L_80492a0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492a4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492a6 jne 8049280 <test_target6+0x880>
{
if (compare_result != 0) {
    goto L_8049280;
}
}

// 80492a8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492ac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492ae je 8049300 <test_target6+0x900>
{
if (compare_result == 0) {
    goto L_8049300;
}
}

// 80492b0 sub $0x4,%esp
L_80492b0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80492b3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492b3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492b5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492b7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492b7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492b9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80492be;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80492be;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492b9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80492be;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80492be add $0x10,%esp
L_80492be:
{
esp += ( +0x10);
compare_result = esp;
}

// 80492c1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492c3 je 8049300 <test_target6+0x900>
{
if (compare_result == 0) {
    goto L_8049300;
}
}

// 80492c5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492c9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80492cc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492cc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492d0 mov 0x1c(%esp),%eax
L_80492d0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492d0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492d4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492d6 jne 80492b0 <test_target6+0x8b0>
{
if (compare_result != 0) {
    goto L_80492b0;
}
}

// 80492d8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492dc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492de je 8049330 <test_target6+0x930>
{
if (compare_result == 0) {
    goto L_8049330;
}
}

// 80492e0 sub $0x4,%esp
L_80492e0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80492e3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492e3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492e5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492e7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492e7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80492e9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80492ee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80492ee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492e9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80492ee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80492ee add $0x10,%esp
L_80492ee:
{
esp += ( +0x10);
compare_result = esp;
}

// 80492f1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80492f3 je 8049330 <test_target6+0x930>
{
if (compare_result == 0) {
    goto L_8049330;
}
}

// 80492f5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80492f9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80492fc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80492fc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049300 mov 0x1c(%esp),%eax
L_8049300:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049300;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049304 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049306 jne 80492e0 <test_target6+0x8e0>
{
if (compare_result != 0) {
    goto L_80492e0;
}
}

// 8049308 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049308;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804930c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804930e je 8049360 <test_target6+0x960>
{
if (compare_result == 0) {
    goto L_8049360;
}
}

// 8049310 sub $0x4,%esp
L_8049310:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049313 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049313;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049315 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049315;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049317 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049317;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049319 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804931e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804931e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049319;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804931e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804931e add $0x10,%esp
L_804931e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049321 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049323 je 8049360 <test_target6+0x960>
{
if (compare_result == 0) {
    goto L_8049360;
}
}

// 8049325 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049325;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049329 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804932c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804932c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049330 mov 0x1c(%esp),%eax
L_8049330:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049330;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049334 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049336 jne 8049310 <test_target6+0x910>
{
if (compare_result != 0) {
    goto L_8049310;
}
}

// 8049338 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049338;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804933c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804933e je 8049390 <test_target6+0x990>
{
if (compare_result == 0) {
    goto L_8049390;
}
}

// 8049340 sub $0x4,%esp
L_8049340:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049343 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049343;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049345 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049345;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049347 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049347;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049349 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804934e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804934e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049349;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804934e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804934e add $0x10,%esp
L_804934e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049351 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049353 je 8049390 <test_target6+0x990>
{
if (compare_result == 0) {
    goto L_8049390;
}
}

// 8049355 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049355;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049359 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804935c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804935c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049360 mov 0x1c(%esp),%eax
L_8049360:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049360;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049364 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049366 jne 8049340 <test_target6+0x940>
{
if (compare_result != 0) {
    goto L_8049340;
}
}

// 8049368 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049368;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804936c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804936e je 80493c0 <test_target6+0x9c0>
{
if (compare_result == 0) {
    goto L_80493c0;
}
}

// 8049370 sub $0x4,%esp
L_8049370:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049373 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049373;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049375 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049375;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049377 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049377;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049379 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804937e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804937e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049379;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804937e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804937e add $0x10,%esp
L_804937e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049381 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049383 je 80493c0 <test_target6+0x9c0>
{
if (compare_result == 0) {
    goto L_80493c0;
}
}

// 8049385 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049385;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049389 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804938c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804938c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049390 mov 0x1c(%esp),%eax
L_8049390:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049390;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049394 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049396 jne 8049370 <test_target6+0x970>
{
if (compare_result != 0) {
    goto L_8049370;
}
}

// 8049398 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049398;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804939c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804939e je 80493f0 <test_target6+0x9f0>
{
if (compare_result == 0) {
    goto L_80493f0;
}
}

// 80493a0 sub $0x4,%esp
L_80493a0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80493a3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493a3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493a5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493a7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493a7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493a9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80493ae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80493ae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493a9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80493ae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80493ae add $0x10,%esp
L_80493ae:
{
esp += ( +0x10);
compare_result = esp;
}

// 80493b1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493b3 je 80493f0 <test_target6+0x9f0>
{
if (compare_result == 0) {
    goto L_80493f0;
}
}

// 80493b5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493b9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80493bc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493bc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493c0 mov 0x1c(%esp),%eax
L_80493c0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493c4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493c6 jne 80493a0 <test_target6+0x9a0>
{
if (compare_result != 0) {
    goto L_80493a0;
}
}

// 80493c8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493c8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493cc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493ce je 8049420 <test_target6+0xa20>
{
if (compare_result == 0) {
    goto L_8049420;
}
}

// 80493d0 sub $0x4,%esp
L_80493d0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80493d3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493d3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493d5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493d7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493d7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80493d9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80493de;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80493de;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493d9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80493de;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80493de add $0x10,%esp
L_80493de:
{
esp += ( +0x10);
compare_result = esp;
}

// 80493e1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493e3 je 8049420 <test_target6+0xa20>
{
if (compare_result == 0) {
    goto L_8049420;
}
}

// 80493e5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493e9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80493ec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493ec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493f0 mov 0x1c(%esp),%eax
L_80493f0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493f4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493f6 jne 80493d0 <test_target6+0x9d0>
{
if (compare_result != 0) {
    goto L_80493d0;
}
}

// 80493f8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80493f8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80493fc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80493fe je 8049450 <test_target6+0xa50>
{
if (compare_result == 0) {
    goto L_8049450;
}
}

// 8049400 sub $0x4,%esp
L_8049400:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049403 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049403;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049405 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049405;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049407 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049407;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049409 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804940e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804940e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049409;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804940e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804940e add $0x10,%esp
L_804940e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049411 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049413 je 8049450 <test_target6+0xa50>
{
if (compare_result == 0) {
    goto L_8049450;
}
}

// 8049415 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049415;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049419 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804941c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804941c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049420 mov 0x1c(%esp),%eax
L_8049420:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049420;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049424 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049426 jne 8049400 <test_target6+0xa00>
{
if (compare_result != 0) {
    goto L_8049400;
}
}

// 8049428 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049428;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804942c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804942e je 8049480 <test_target6+0xa80>
{
if (compare_result == 0) {
    goto L_8049480;
}
}

// 8049430 sub $0x4,%esp
L_8049430:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049433 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049433;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049435 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049435;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049437 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049437;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049439 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804943e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804943e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049439;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804943e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804943e add $0x10,%esp
L_804943e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049441 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049443 je 8049480 <test_target6+0xa80>
{
if (compare_result == 0) {
    goto L_8049480;
}
}

// 8049445 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049445;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049449 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804944c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804944c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049450 mov 0x1c(%esp),%eax
L_8049450:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049450;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049454 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049456 jne 8049430 <test_target6+0xa30>
{
if (compare_result != 0) {
    goto L_8049430;
}
}

// 8049458 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049458;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804945c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804945e je 80494b0 <test_target6+0xab0>
{
if (compare_result == 0) {
    goto L_80494b0;
}
}

// 8049460 sub $0x4,%esp
L_8049460:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049463 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049463;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049465 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049465;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049467 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049467;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049469 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804946e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804946e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049469;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804946e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804946e add $0x10,%esp
L_804946e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049471 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049473 je 80494b0 <test_target6+0xab0>
{
if (compare_result == 0) {
    goto L_80494b0;
}
}

// 8049475 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049475;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049479 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804947c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804947c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049480 mov 0x1c(%esp),%eax
L_8049480:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049480;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049484 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049486 jne 8049460 <test_target6+0xa60>
{
if (compare_result != 0) {
    goto L_8049460;
}
}

// 8049488 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049488;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804948c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804948e je 80494e0 <test_target6+0xae0>
{
if (compare_result == 0) {
    goto L_80494e0;
}
}

// 8049490 sub $0x4,%esp
L_8049490:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049493 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049493;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049495 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049495;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049497 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049497;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049499 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804949e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804949e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049499;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804949e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804949e add $0x10,%esp
L_804949e:
{
esp += ( +0x10);
compare_result = esp;
}

// 80494a1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494a3 je 80494e0 <test_target6+0xae0>
{
if (compare_result == 0) {
    goto L_80494e0;
}
}

// 80494a5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494a9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80494ac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494ac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494b0 mov 0x1c(%esp),%eax
L_80494b0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494b4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494b6 jne 8049490 <test_target6+0xa90>
{
if (compare_result != 0) {
    goto L_8049490;
}
}

// 80494b8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494b8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494bc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494be je 8049510 <test_target6+0xb10>
{
if (compare_result == 0) {
    goto L_8049510;
}
}

// 80494c0 sub $0x4,%esp
L_80494c0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80494c3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494c3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494c5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494c7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494c7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494c9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80494ce;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80494ce;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494c9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80494ce;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80494ce add $0x10,%esp
L_80494ce:
{
esp += ( +0x10);
compare_result = esp;
}

// 80494d1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494d3 je 8049510 <test_target6+0xb10>
{
if (compare_result == 0) {
    goto L_8049510;
}
}

// 80494d5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494d9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80494dc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494dc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494e0 mov 0x1c(%esp),%eax
L_80494e0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494e0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494e4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494e6 jne 80494c0 <test_target6+0xac0>
{
if (compare_result != 0) {
    goto L_80494c0;
}
}

// 80494e8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494e8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80494ec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80494ee je 8049540 <test_target6+0xb40>
{
if (compare_result == 0) {
    goto L_8049540;
}
}

// 80494f0 sub $0x4,%esp
L_80494f0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80494f3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494f3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494f5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494f7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494f7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80494f9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80494fe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80494fe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80494f9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80494fe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80494fe add $0x10,%esp
L_80494fe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049501 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049503 je 8049540 <test_target6+0xb40>
{
if (compare_result == 0) {
    goto L_8049540;
}
}

// 8049505 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049505;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049509 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804950c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804950c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049510 mov 0x1c(%esp),%eax
L_8049510:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049510;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049514 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049516 jne 80494f0 <test_target6+0xaf0>
{
if (compare_result != 0) {
    goto L_80494f0;
}
}

// 8049518 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049518;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804951c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804951e je 8049570 <test_target6+0xb70>
{
if (compare_result == 0) {
    goto L_8049570;
}
}

// 8049520 sub $0x4,%esp
L_8049520:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049523 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049523;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049525 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049525;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049527 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049527;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049529 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804952e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804952e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049529;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804952e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804952e add $0x10,%esp
L_804952e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049531 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049533 je 8049570 <test_target6+0xb70>
{
if (compare_result == 0) {
    goto L_8049570;
}
}

// 8049535 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049535;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049539 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804953c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804953c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049540 mov 0x1c(%esp),%eax
L_8049540:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049540;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049544 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049546 jne 8049520 <test_target6+0xb20>
{
if (compare_result != 0) {
    goto L_8049520;
}
}

// 8049548 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049548;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804954c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804954e je 80495a0 <test_target6+0xba0>
{
if (compare_result == 0) {
    goto L_80495a0;
}
}

// 8049550 sub $0x4,%esp
L_8049550:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049553 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049553;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049555 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049555;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049557 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049557;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049559 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804955e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804955e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049559;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804955e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804955e add $0x10,%esp
L_804955e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049561 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049563 je 80495a0 <test_target6+0xba0>
{
if (compare_result == 0) {
    goto L_80495a0;
}
}

// 8049565 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049565;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049569 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804956c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804956c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049570 mov 0x1c(%esp),%eax
L_8049570:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049570;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049574 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049576 jne 8049550 <test_target6+0xb50>
{
if (compare_result != 0) {
    goto L_8049550;
}
}

// 8049578 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049578;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804957c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804957e je 80495d0 <test_target6+0xbd0>
{
if (compare_result == 0) {
    goto L_80495d0;
}
}

// 8049580 sub $0x4,%esp
L_8049580:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049583 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049583;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049585 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049585;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049587 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049587;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049589 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804958e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804958e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049589;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804958e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804958e add $0x10,%esp
L_804958e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049591 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049593 je 80495d0 <test_target6+0xbd0>
{
if (compare_result == 0) {
    goto L_80495d0;
}
}

// 8049595 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049595;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049599 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804959c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804959c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495a0 mov 0x1c(%esp),%eax
L_80495a0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495a4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495a6 jne 8049580 <test_target6+0xb80>
{
if (compare_result != 0) {
    goto L_8049580;
}
}

// 80495a8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495ac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495ae je 8049600 <test_target6+0xc00>
{
if (compare_result == 0) {
    goto L_8049600;
}
}

// 80495b0 sub $0x4,%esp
L_80495b0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80495b3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495b3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495b5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495b7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495b7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495b9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80495be;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80495be;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495b9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80495be;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80495be add $0x10,%esp
L_80495be:
{
esp += ( +0x10);
compare_result = esp;
}

// 80495c1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495c3 je 8049600 <test_target6+0xc00>
{
if (compare_result == 0) {
    goto L_8049600;
}
}

// 80495c5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495c9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80495cc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495cc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495d0 mov 0x1c(%esp),%eax
L_80495d0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495d0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495d4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495d6 jne 80495b0 <test_target6+0xbb0>
{
if (compare_result != 0) {
    goto L_80495b0;
}
}

// 80495d8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495dc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495de je 8049630 <test_target6+0xc30>
{
if (compare_result == 0) {
    goto L_8049630;
}
}

// 80495e0 sub $0x4,%esp
L_80495e0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80495e3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495e3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495e5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495e7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495e7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80495e9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80495ee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80495ee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495e9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80495ee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80495ee add $0x10,%esp
L_80495ee:
{
esp += ( +0x10);
compare_result = esp;
}

// 80495f1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80495f3 je 8049630 <test_target6+0xc30>
{
if (compare_result == 0) {
    goto L_8049630;
}
}

// 80495f5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80495f9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80495fc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80495fc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049600 mov 0x1c(%esp),%eax
L_8049600:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049600;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049604 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049606 jne 80495e0 <test_target6+0xbe0>
{
if (compare_result != 0) {
    goto L_80495e0;
}
}

// 8049608 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049608;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804960c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804960e je 8049660 <test_target6+0xc60>
{
if (compare_result == 0) {
    goto L_8049660;
}
}

// 8049610 sub $0x4,%esp
L_8049610:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049613 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049613;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049615 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049615;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049617 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049617;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049619 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804961e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804961e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049619;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804961e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804961e add $0x10,%esp
L_804961e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049621 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049623 je 8049660 <test_target6+0xc60>
{
if (compare_result == 0) {
    goto L_8049660;
}
}

// 8049625 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049625;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049629 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804962c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804962c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049630 mov 0x1c(%esp),%eax
L_8049630:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049630;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049634 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049636 jne 8049610 <test_target6+0xc10>
{
if (compare_result != 0) {
    goto L_8049610;
}
}

// 8049638 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049638;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804963c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804963e je 8049690 <test_target6+0xc90>
{
if (compare_result == 0) {
    goto L_8049690;
}
}

// 8049640 sub $0x4,%esp
L_8049640:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049643 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049643;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049645 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049645;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049647 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049647;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049649 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804964e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804964e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049649;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804964e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804964e add $0x10,%esp
L_804964e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049651 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049653 je 8049690 <test_target6+0xc90>
{
if (compare_result == 0) {
    goto L_8049690;
}
}

// 8049655 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049655;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049659 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804965c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804965c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049660 mov 0x1c(%esp),%eax
L_8049660:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049660;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049664 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049666 jne 8049640 <test_target6+0xc40>
{
if (compare_result != 0) {
    goto L_8049640;
}
}

// 8049668 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049668;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804966c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804966e je 80496c0 <test_target6+0xcc0>
{
if (compare_result == 0) {
    goto L_80496c0;
}
}

// 8049670 sub $0x4,%esp
L_8049670:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049673 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049673;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049675 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049675;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049677 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049677;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049679 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804967e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804967e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049679;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804967e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804967e add $0x10,%esp
L_804967e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049681 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049683 je 80496c0 <test_target6+0xcc0>
{
if (compare_result == 0) {
    goto L_80496c0;
}
}

// 8049685 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049685;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049689 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804968c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804968c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049690 mov 0x1c(%esp),%eax
L_8049690:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049690;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049694 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049696 jne 8049670 <test_target6+0xc70>
{
if (compare_result != 0) {
    goto L_8049670;
}
}

// 8049698 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049698;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804969c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804969e je 80496f0 <test_target6+0xcf0>
{
if (compare_result == 0) {
    goto L_80496f0;
}
}

// 80496a0 sub $0x4,%esp
L_80496a0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80496a3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496a3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496a5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496a7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496a7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496a9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80496ae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80496ae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496a9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80496ae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80496ae add $0x10,%esp
L_80496ae:
{
esp += ( +0x10);
compare_result = esp;
}

// 80496b1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496b3 je 80496f0 <test_target6+0xcf0>
{
if (compare_result == 0) {
    goto L_80496f0;
}
}

// 80496b5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496b9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80496bc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496bc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496c0 mov 0x1c(%esp),%eax
L_80496c0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496c4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496c6 jne 80496a0 <test_target6+0xca0>
{
if (compare_result != 0) {
    goto L_80496a0;
}
}

// 80496c8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496c8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496cc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496ce je 8049720 <test_target6+0xd20>
{
if (compare_result == 0) {
    goto L_8049720;
}
}

// 80496d0 sub $0x4,%esp
L_80496d0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80496d3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496d3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496d5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496d7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496d7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80496d9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80496de;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80496de;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496d9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80496de;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80496de add $0x10,%esp
L_80496de:
{
esp += ( +0x10);
compare_result = esp;
}

// 80496e1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496e3 je 8049720 <test_target6+0xd20>
{
if (compare_result == 0) {
    goto L_8049720;
}
}

// 80496e5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496e9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80496ec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496ec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496f0 mov 0x1c(%esp),%eax
L_80496f0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496f4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496f6 jne 80496d0 <test_target6+0xcd0>
{
if (compare_result != 0) {
    goto L_80496d0;
}
}

// 80496f8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80496f8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80496fc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80496fe je 8049750 <test_target6+0xd50>
{
if (compare_result == 0) {
    goto L_8049750;
}
}

// 8049700 sub $0x4,%esp
L_8049700:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049703 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049703;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049705 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049705;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049707 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049707;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049709 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804970e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804970e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049709;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804970e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804970e add $0x10,%esp
L_804970e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049711 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049713 je 8049750 <test_target6+0xd50>
{
if (compare_result == 0) {
    goto L_8049750;
}
}

// 8049715 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049715;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049719 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804971c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804971c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049720 mov 0x1c(%esp),%eax
L_8049720:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049720;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049724 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049726 jne 8049700 <test_target6+0xd00>
{
if (compare_result != 0) {
    goto L_8049700;
}
}

// 8049728 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049728;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804972c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804972e je 8049780 <test_target6+0xd80>
{
if (compare_result == 0) {
    goto L_8049780;
}
}

// 8049730 sub $0x4,%esp
L_8049730:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049733 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049733;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049735 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049735;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049737 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049737;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049739 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804973e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804973e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049739;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804973e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804973e add $0x10,%esp
L_804973e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049741 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049743 je 8049780 <test_target6+0xd80>
{
if (compare_result == 0) {
    goto L_8049780;
}
}

// 8049745 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049745;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049749 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804974c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804974c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049750 mov 0x1c(%esp),%eax
L_8049750:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049750;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049754 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049756 jne 8049730 <test_target6+0xd30>
{
if (compare_result != 0) {
    goto L_8049730;
}
}

// 8049758 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049758;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804975c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804975e je 80497b0 <test_target6+0xdb0>
{
if (compare_result == 0) {
    goto L_80497b0;
}
}

// 8049760 sub $0x4,%esp
L_8049760:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049763 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049763;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049765 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049765;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049767 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049767;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049769 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804976e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804976e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049769;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804976e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804976e add $0x10,%esp
L_804976e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049771 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049773 je 80497b0 <test_target6+0xdb0>
{
if (compare_result == 0) {
    goto L_80497b0;
}
}

// 8049775 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049775;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049779 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804977c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804977c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049780 mov 0x1c(%esp),%eax
L_8049780:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049780;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049784 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049786 jne 8049760 <test_target6+0xd60>
{
if (compare_result != 0) {
    goto L_8049760;
}
}

// 8049788 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049788;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804978c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804978e je 80497e0 <test_target6+0xde0>
{
if (compare_result == 0) {
    goto L_80497e0;
}
}

// 8049790 sub $0x4,%esp
L_8049790:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049793 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049793;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049795 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049795;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049797 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049797;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049799 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804979e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804979e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049799;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804979e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804979e add $0x10,%esp
L_804979e:
{
esp += ( +0x10);
compare_result = esp;
}

// 80497a1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497a3 je 80497e0 <test_target6+0xde0>
{
if (compare_result == 0) {
    goto L_80497e0;
}
}

// 80497a5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497a9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80497ac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497ac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497b0 mov 0x1c(%esp),%eax
L_80497b0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497b0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497b4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497b6 jne 8049790 <test_target6+0xd90>
{
if (compare_result != 0) {
    goto L_8049790;
}
}

// 80497b8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497b8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497bc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497be je 8049810 <test_target6+0xe10>
{
if (compare_result == 0) {
    goto L_8049810;
}
}

// 80497c0 sub $0x4,%esp
L_80497c0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80497c3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497c3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497c5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497c7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497c7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497c9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80497ce;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80497ce;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497c9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80497ce;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80497ce add $0x10,%esp
L_80497ce:
{
esp += ( +0x10);
compare_result = esp;
}

// 80497d1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497d3 je 8049810 <test_target6+0xe10>
{
if (compare_result == 0) {
    goto L_8049810;
}
}

// 80497d5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497d9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80497dc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497dc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497e0 mov 0x1c(%esp),%eax
L_80497e0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497e0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497e4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497e6 jne 80497c0 <test_target6+0xdc0>
{
if (compare_result != 0) {
    goto L_80497c0;
}
}

// 80497e8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497e8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80497ec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80497ee je 8049840 <test_target6+0xe40>
{
if (compare_result == 0) {
    goto L_8049840;
}
}

// 80497f0 sub $0x4,%esp
L_80497f0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80497f3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497f3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497f5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497f7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497f7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80497f9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80497fe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80497fe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80497f9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80497fe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80497fe add $0x10,%esp
L_80497fe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049801 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049803 je 8049840 <test_target6+0xe40>
{
if (compare_result == 0) {
    goto L_8049840;
}
}

// 8049805 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049805;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049809 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804980c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804980c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049810 mov 0x1c(%esp),%eax
L_8049810:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049810;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049814 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049816 jne 80497f0 <test_target6+0xdf0>
{
if (compare_result != 0) {
    goto L_80497f0;
}
}

// 8049818 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049818;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804981c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804981e je 8049870 <test_target6+0xe70>
{
if (compare_result == 0) {
    goto L_8049870;
}
}

// 8049820 sub $0x4,%esp
L_8049820:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049823 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049823;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049825 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049825;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049827 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049827;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049829 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804982e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804982e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049829;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804982e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804982e add $0x10,%esp
L_804982e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049831 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049833 je 8049870 <test_target6+0xe70>
{
if (compare_result == 0) {
    goto L_8049870;
}
}

// 8049835 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049835;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049839 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804983c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804983c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049840 mov 0x1c(%esp),%eax
L_8049840:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049840;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049844 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049846 jne 8049820 <test_target6+0xe20>
{
if (compare_result != 0) {
    goto L_8049820;
}
}

// 8049848 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049848;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804984c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804984e je 80498a0 <test_target6+0xea0>
{
if (compare_result == 0) {
    goto L_80498a0;
}
}

// 8049850 sub $0x4,%esp
L_8049850:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049853 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049853;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049855 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049855;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049857 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049857;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049859 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804985e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804985e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049859;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804985e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804985e add $0x10,%esp
L_804985e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049861 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049863 je 80498a0 <test_target6+0xea0>
{
if (compare_result == 0) {
    goto L_80498a0;
}
}

// 8049865 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049865;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049869 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804986c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804986c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049870 mov 0x1c(%esp),%eax
L_8049870:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049870;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049874 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049876 jne 8049850 <test_target6+0xe50>
{
if (compare_result != 0) {
    goto L_8049850;
}
}

// 8049878 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049878;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804987c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804987e je 80498d0 <test_target6+0xed0>
{
if (compare_result == 0) {
    goto L_80498d0;
}
}

// 8049880 sub $0x4,%esp
L_8049880:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049883 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049883;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049885 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049885;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049887 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049887;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049889 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804988e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804988e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049889;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804988e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804988e add $0x10,%esp
L_804988e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049891 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049893 je 80498d0 <test_target6+0xed0>
{
if (compare_result == 0) {
    goto L_80498d0;
}
}

// 8049895 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049895;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049899 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804989c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804989c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498a0 mov 0x1c(%esp),%eax
L_80498a0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498a0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498a4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498a6 jne 8049880 <test_target6+0xe80>
{
if (compare_result != 0) {
    goto L_8049880;
}
}

// 80498a8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498a8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498ac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498ae je 8049900 <test_target6+0xf00>
{
if (compare_result == 0) {
    goto L_8049900;
}
}

// 80498b0 sub $0x4,%esp
L_80498b0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80498b3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498b3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498b5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498b7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498b7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498b9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80498be;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80498be;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498b9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80498be;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80498be add $0x10,%esp
L_80498be:
{
esp += ( +0x10);
compare_result = esp;
}

// 80498c1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498c3 je 8049900 <test_target6+0xf00>
{
if (compare_result == 0) {
    goto L_8049900;
}
}

// 80498c5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498c5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498c9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80498cc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498cc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498d0 mov 0x1c(%esp),%eax
L_80498d0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498d0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498d4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498d6 jne 80498b0 <test_target6+0xeb0>
{
if (compare_result != 0) {
    goto L_80498b0;
}
}

// 80498d8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498d8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498dc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498de je 8049930 <test_target6+0xf30>
{
if (compare_result == 0) {
    goto L_8049930;
}
}

// 80498e0 sub $0x4,%esp
L_80498e0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80498e3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498e3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498e5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498e7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498e7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80498e9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80498ee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80498ee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498e9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80498ee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80498ee add $0x10,%esp
L_80498ee:
{
esp += ( +0x10);
compare_result = esp;
}

// 80498f1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80498f3 je 8049930 <test_target6+0xf30>
{
if (compare_result == 0) {
    goto L_8049930;
}
}

// 80498f5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498f5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80498f9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80498fc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80498fc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049900 mov 0x1c(%esp),%eax
L_8049900:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049900;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049904 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049906 jne 80498e0 <test_target6+0xee0>
{
if (compare_result != 0) {
    goto L_80498e0;
}
}

// 8049908 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049908;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804990c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804990e je 8049960 <test_target6+0xf60>
{
if (compare_result == 0) {
    goto L_8049960;
}
}

// 8049910 sub $0x4,%esp
L_8049910:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049913 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049913;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049915 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049915;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049917 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049917;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049919 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804991e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804991e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049919;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804991e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804991e add $0x10,%esp
L_804991e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049921 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049923 je 8049960 <test_target6+0xf60>
{
if (compare_result == 0) {
    goto L_8049960;
}
}

// 8049925 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049925;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049929 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804992c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804992c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049930 mov 0x1c(%esp),%eax
L_8049930:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049930;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049934 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049936 jne 8049910 <test_target6+0xf10>
{
if (compare_result != 0) {
    goto L_8049910;
}
}

// 8049938 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049938;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804993c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804993e je 8049990 <test_target6+0xf90>
{
if (compare_result == 0) {
    goto L_8049990;
}
}

// 8049940 sub $0x4,%esp
L_8049940:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049943 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049943;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049945 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049945;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049947 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049947;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049949 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804994e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804994e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049949;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804994e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804994e add $0x10,%esp
L_804994e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049951 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049953 je 8049990 <test_target6+0xf90>
{
if (compare_result == 0) {
    goto L_8049990;
}
}

// 8049955 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049955;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049959 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804995c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804995c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049960 mov 0x1c(%esp),%eax
L_8049960:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049960;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049964 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049966 jne 8049940 <test_target6+0xf40>
{
if (compare_result != 0) {
    goto L_8049940;
}
}

// 8049968 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049968;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804996c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804996e je 80499c0 <test_target6+0xfc0>
{
if (compare_result == 0) {
    goto L_80499c0;
}
}

// 8049970 sub $0x4,%esp
L_8049970:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049973 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049973;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049975 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049975;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049977 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049977;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049979 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x804997e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x804997e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049979;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x804997e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 804997e add $0x10,%esp
L_804997e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049981 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049983 je 80499c0 <test_target6+0xfc0>
{
if (compare_result == 0) {
    goto L_80499c0;
}
}

// 8049985 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049985;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049989 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 804998c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x804998c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049990 mov 0x1c(%esp),%eax
L_8049990:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049990;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049994 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049996 jne 8049970 <test_target6+0xf70>
{
if (compare_result != 0) {
    goto L_8049970;
}
}

// 8049998 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049998;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 804999c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 804999e je 80499f0 <test_target6+0xff0>
{
if (compare_result == 0) {
    goto L_80499f0;
}
}

// 80499a0 sub $0x4,%esp
L_80499a0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80499a3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499a3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499a5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499a5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499a7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499a7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499a9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80499ae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80499ae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499a9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80499ae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80499ae add $0x10,%esp
L_80499ae:
{
esp += ( +0x10);
compare_result = esp;
}

// 80499b1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499b3 je 80499f0 <test_target6+0xff0>
{
if (compare_result == 0) {
    goto L_80499f0;
}
}

// 80499b5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499b5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499b9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80499bc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499bc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499c0 mov 0x1c(%esp),%eax
L_80499c0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499c0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499c4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499c6 jne 80499a0 <test_target6+0xfa0>
{
if (compare_result != 0) {
    goto L_80499a0;
}
}

// 80499c8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499c8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499cc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499ce je 8049a20 <test_target6+0x1020>
{
if (compare_result == 0) {
    goto L_8049a20;
}
}

// 80499d0 sub $0x4,%esp
L_80499d0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 80499d3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499d3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499d5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499d5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499d7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499d7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 80499d9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x80499de;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x80499de;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499d9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x80499de;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 80499de add $0x10,%esp
L_80499de:
{
esp += ( +0x10);
compare_result = esp;
}

// 80499e1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499e3 je 8049a20 <test_target6+0x1020>
{
if (compare_result == 0) {
    goto L_8049a20;
}
}

// 80499e5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499e5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499e9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 80499ec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499ec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499f0 mov 0x1c(%esp),%eax
L_80499f0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499f0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499f4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499f6 jne 80499d0 <test_target6+0xfd0>
{
if (compare_result != 0) {
    goto L_80499d0;
}
}

// 80499f8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x80499f8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 80499fc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 80499fe je 8049a50 <test_target6+0x1050>
{
if (compare_result == 0) {
    goto L_8049a50;
}
}

// 8049a00 sub $0x4,%esp
L_8049a00:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049a03 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a03;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a05 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a07 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a07;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a09 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a0e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a0e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a09;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049a0e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049a0e add $0x10,%esp
L_8049a0e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049a11 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a13 je 8049a50 <test_target6+0x1050>
{
if (compare_result == 0) {
    goto L_8049a50;
}
}

// 8049a15 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a19 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049a1c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a1c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a20 mov 0x1c(%esp),%eax
L_8049a20:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a20;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a24 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a26 jne 8049a00 <test_target6+0x1000>
{
if (compare_result != 0) {
    goto L_8049a00;
}
}

// 8049a28 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a28;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a2c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a2e je 8049a80 <test_target6+0x1080>
{
if (compare_result == 0) {
    goto L_8049a80;
}
}

// 8049a30 sub $0x4,%esp
L_8049a30:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049a33 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a33;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a35 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a35;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a37 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a37;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a39 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a3e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a3e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a39;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049a3e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049a3e add $0x10,%esp
L_8049a3e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049a41 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a43 je 8049a80 <test_target6+0x1080>
{
if (compare_result == 0) {
    goto L_8049a80;
}
}

// 8049a45 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a49 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049a4c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a4c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a50 mov 0x1c(%esp),%eax
L_8049a50:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a50;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a54 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a56 jne 8049a30 <test_target6+0x1030>
{
if (compare_result != 0) {
    goto L_8049a30;
}
}

// 8049a58 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a58;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a5c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a5e je 8049ab0 <test_target6+0x10b0>
{
if (compare_result == 0) {
    goto L_8049ab0;
}
}

// 8049a60 sub $0x4,%esp
L_8049a60:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049a63 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a63;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a65 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a67 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a67;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a69 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a6e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a6e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a69;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049a6e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049a6e add $0x10,%esp
L_8049a6e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049a71 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a73 je 8049ab0 <test_target6+0x10b0>
{
if (compare_result == 0) {
    goto L_8049ab0;
}
}

// 8049a75 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a79 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049a7c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a7c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a80 mov 0x1c(%esp),%eax
L_8049a80:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a80;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a84 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a86 jne 8049a60 <test_target6+0x1060>
{
if (compare_result != 0) {
    goto L_8049a60;
}
}

// 8049a88 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a88;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049a8c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049a8e je 8049ae0 <test_target6+0x10e0>
{
if (compare_result == 0) {
    goto L_8049ae0;
}
}

// 8049a90 sub $0x4,%esp
L_8049a90:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049a93 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a93;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a95 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a97 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a97;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049a99 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a9e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049a9e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049a99;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049a9e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049a9e add $0x10,%esp
L_8049a9e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049aa1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049aa3 je 8049ae0 <test_target6+0x10e0>
{
if (compare_result == 0) {
    goto L_8049ae0;
}
}

// 8049aa5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049aa5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049aa9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049aac mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049aac;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ab0 mov 0x1c(%esp),%eax
L_8049ab0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ab0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ab4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049ab6 jne 8049a90 <test_target6+0x1090>
{
if (compare_result != 0) {
    goto L_8049a90;
}
}

// 8049ab8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ab8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049abc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049abe je 8049b10 <test_target6+0x1110>
{
if (compare_result == 0) {
    goto L_8049b10;
}
}

// 8049ac0 sub $0x4,%esp
L_8049ac0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049ac3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ac3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ac5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ac5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ac7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ac7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ac9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049ace;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049ace;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ac9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049ace;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049ace add $0x10,%esp
L_8049ace:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049ad1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049ad3 je 8049b10 <test_target6+0x1110>
{
if (compare_result == 0) {
    goto L_8049b10;
}
}

// 8049ad5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ad5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ad9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049adc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049adc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ae0 mov 0x1c(%esp),%eax
L_8049ae0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ae0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ae4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049ae6 jne 8049ac0 <test_target6+0x10c0>
{
if (compare_result != 0) {
    goto L_8049ac0;
}
}

// 8049ae8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ae8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049aec test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049aee je 8049b40 <test_target6+0x1140>
{
if (compare_result == 0) {
    goto L_8049b40;
}
}

// 8049af0 sub $0x4,%esp
L_8049af0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049af3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049af3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049af5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049af5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049af7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049af7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049af9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049afe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049afe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049af9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049afe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049afe add $0x10,%esp
L_8049afe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049b01 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b03 je 8049b40 <test_target6+0x1140>
{
if (compare_result == 0) {
    goto L_8049b40;
}
}

// 8049b05 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b09 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049b0c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b0c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b10 mov 0x1c(%esp),%eax
L_8049b10:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b10;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b14 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b16 jne 8049af0 <test_target6+0x10f0>
{
if (compare_result != 0) {
    goto L_8049af0;
}
}

// 8049b18 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b18;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b1c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b1e je 8049b70 <test_target6+0x1170>
{
if (compare_result == 0) {
    goto L_8049b70;
}
}

// 8049b20 sub $0x4,%esp
L_8049b20:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049b23 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b23;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b25 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b27 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b27;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b29 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b2e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b2e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b29;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049b2e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049b2e add $0x10,%esp
L_8049b2e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049b31 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b33 je 8049b70 <test_target6+0x1170>
{
if (compare_result == 0) {
    goto L_8049b70;
}
}

// 8049b35 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b35;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b39 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049b3c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b3c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b40 mov 0x1c(%esp),%eax
L_8049b40:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b40;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b44 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b46 jne 8049b20 <test_target6+0x1120>
{
if (compare_result != 0) {
    goto L_8049b20;
}
}

// 8049b48 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b48;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b4c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b4e je 8049ba0 <test_target6+0x11a0>
{
if (compare_result == 0) {
    goto L_8049ba0;
}
}

// 8049b50 sub $0x4,%esp
L_8049b50:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049b53 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b53;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b55 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b57 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b57;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b59 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b5e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b5e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b59;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049b5e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049b5e add $0x10,%esp
L_8049b5e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049b61 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b63 je 8049ba0 <test_target6+0x11a0>
{
if (compare_result == 0) {
    goto L_8049ba0;
}
}

// 8049b65 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b65;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b69 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049b6c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b6c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b70 mov 0x1c(%esp),%eax
L_8049b70:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b70;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b74 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b76 jne 8049b50 <test_target6+0x1150>
{
if (compare_result != 0) {
    goto L_8049b50;
}
}

// 8049b78 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b78;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b7c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b7e je 8049bd0 <test_target6+0x11d0>
{
if (compare_result == 0) {
    goto L_8049bd0;
}
}

// 8049b80 sub $0x4,%esp
L_8049b80:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049b83 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b83;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b85 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b87 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b87;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049b89 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b8e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049b8e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b89;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049b8e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049b8e add $0x10,%esp
L_8049b8e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049b91 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049b93 je 8049bd0 <test_target6+0x11d0>
{
if (compare_result == 0) {
    goto L_8049bd0;
}
}

// 8049b95 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b95;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049b99 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049b9c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049b9c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ba0 mov 0x1c(%esp),%eax
L_8049ba0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ba0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ba4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049ba6 jne 8049b80 <test_target6+0x1180>
{
if (compare_result != 0) {
    goto L_8049b80;
}
}

// 8049ba8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ba8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bac test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049bae je 8049c00 <test_target6+0x1200>
{
if (compare_result == 0) {
    goto L_8049c00;
}
}

// 8049bb0 sub $0x4,%esp
L_8049bb0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049bb3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bb3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049bb5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bb5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049bb7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bb7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049bb9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049bbe;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049bbe;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bb9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049bbe;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049bbe add $0x10,%esp
L_8049bbe:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049bc1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049bc3 je 8049c00 <test_target6+0x1200>
{
if (compare_result == 0) {
    goto L_8049c00;
}
}

// 8049bc5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bc5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bc9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049bcc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bcc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bd0 mov 0x1c(%esp),%eax
L_8049bd0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bd0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bd4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049bd6 jne 8049bb0 <test_target6+0x11b0>
{
if (compare_result != 0) {
    goto L_8049bb0;
}
}

// 8049bd8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bd8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bdc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049bde je 8049c30 <test_target6+0x1230>
{
if (compare_result == 0) {
    goto L_8049c30;
}
}

// 8049be0 sub $0x4,%esp
L_8049be0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049be3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049be3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049be5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049be5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049be7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049be7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049be9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049bee;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049bee;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049be9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049bee;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049bee add $0x10,%esp
L_8049bee:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049bf1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049bf3 je 8049c30 <test_target6+0x1230>
{
if (compare_result == 0) {
    goto L_8049c30;
}
}

// 8049bf5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bf5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049bf9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049bfc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049bfc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c00 mov 0x1c(%esp),%eax
L_8049c00:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c00;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c04 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c06 jne 8049be0 <test_target6+0x11e0>
{
if (compare_result != 0) {
    goto L_8049be0;
}
}

// 8049c08 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c08;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c0c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c0e je 8049c60 <test_target6+0x1260>
{
if (compare_result == 0) {
    goto L_8049c60;
}
}

// 8049c10 sub $0x4,%esp
L_8049c10:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049c13 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c13;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c15 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c17 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c17;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c19 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c1e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c1e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c19;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049c1e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049c1e add $0x10,%esp
L_8049c1e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049c21 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c23 je 8049c60 <test_target6+0x1260>
{
if (compare_result == 0) {
    goto L_8049c60;
}
}

// 8049c25 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c25;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c29 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049c2c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c2c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c30 mov 0x1c(%esp),%eax
L_8049c30:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c30;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c34 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c36 jne 8049c10 <test_target6+0x1210>
{
if (compare_result != 0) {
    goto L_8049c10;
}
}

// 8049c38 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c38;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c3c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c3e je 8049c90 <test_target6+0x1290>
{
if (compare_result == 0) {
    goto L_8049c90;
}
}

// 8049c40 sub $0x4,%esp
L_8049c40:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049c43 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c43;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c45 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c47 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c47;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c49 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c4e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c4e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c49;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049c4e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049c4e add $0x10,%esp
L_8049c4e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049c51 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c53 je 8049c90 <test_target6+0x1290>
{
if (compare_result == 0) {
    goto L_8049c90;
}
}

// 8049c55 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c55;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c59 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049c5c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c5c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c60 mov 0x1c(%esp),%eax
L_8049c60:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c60;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c64 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c66 jne 8049c40 <test_target6+0x1240>
{
if (compare_result != 0) {
    goto L_8049c40;
}
}

// 8049c68 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c68;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c6c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c6e je 8049cc0 <test_target6+0x12c0>
{
if (compare_result == 0) {
    goto L_8049cc0;
}
}

// 8049c70 sub $0x4,%esp
L_8049c70:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049c73 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c73;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c75 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c75;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c77 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c77;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049c79 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c7e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049c7e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c79;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049c7e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049c7e add $0x10,%esp
L_8049c7e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049c81 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c83 je 8049cc0 <test_target6+0x12c0>
{
if (compare_result == 0) {
    goto L_8049cc0;
}
}

// 8049c85 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c85;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c89 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049c8c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c8c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c90 mov 0x1c(%esp),%eax
L_8049c90:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c90;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c94 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c96 jne 8049c70 <test_target6+0x1270>
{
if (compare_result != 0) {
    goto L_8049c70;
}
}

// 8049c98 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049c98;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049c9c test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049c9e je 8049cf0 <test_target6+0x12f0>
{
if (compare_result == 0) {
    goto L_8049cf0;
}
}

// 8049ca0 sub $0x4,%esp
L_8049ca0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049ca3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ca3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ca5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ca5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ca7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ca7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049ca9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049cae;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049cae;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ca9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049cae;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049cae add $0x10,%esp
L_8049cae:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049cb1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049cb3 je 8049cf0 <test_target6+0x12f0>
{
if (compare_result == 0) {
    goto L_8049cf0;
}
}

// 8049cb5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cb5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cb9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049cbc mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cbc;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cc0 mov 0x1c(%esp),%eax
L_8049cc0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cc0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cc4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049cc6 jne 8049ca0 <test_target6+0x12a0>
{
if (compare_result != 0) {
    goto L_8049ca0;
}
}

// 8049cc8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cc8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ccc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049cce je 8049d20 <test_target6+0x1320>
{
if (compare_result == 0) {
    goto L_8049d20;
}
}

// 8049cd0 sub $0x4,%esp
L_8049cd0:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049cd3 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cd3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049cd5 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cd5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049cd7 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cd7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049cd9 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049cde;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049cde;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cd9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049cde;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049cde add $0x10,%esp
L_8049cde:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049ce1 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049ce3 je 8049d20 <test_target6+0x1320>
{
if (compare_result == 0) {
    goto L_8049d20;
}
}

// 8049ce5 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049ce5;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049ce9 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049cec mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cec;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cf0 mov 0x1c(%esp),%eax
L_8049cf0:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cf0;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cf4 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049cf6 jne 8049cd0 <test_target6+0x12d0>
{
if (compare_result != 0) {
    goto L_8049cd0;
}
}

// 8049cf8 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049cf8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049cfc test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049cfe je 8049d28 <test_target6+0x1328>
{
if (compare_result == 0) {
    goto L_8049d28;
}
}

// 8049d00 sub $0x4,%esp
L_8049d00:
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049d03 push $0x3
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d03;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x3);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d05 push $0x2
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d05;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x2);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d07 push $0x1
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d07;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x1);
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d09 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d0e;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d0e;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d09;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049d0e;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049d0e add $0x10,%esp
L_8049d0e:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049d11 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049d13 je 8049d28 <test_target6+0x1328>
{
if (compare_result == 0) {
    goto L_8049d28;
}
}

// 8049d15 mov 0x1c(%esp),%eax
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d15;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049d19 add $0x1,%eax
{
eax += ( +0x1);
compare_result = eax;
}

// 8049d1c mov %eax,0x1c(%esp)
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d1c;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049d20 mov 0x1c(%esp),%eax
L_8049d20:
{
if (memcache_esp_0x1c_pin == (esp +0x1c)) eax= (uint) memcache_esp_0x1c_data; else 
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d20;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x1c_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049d24 test %eax,%eax
{
compare_result = (uint)(eax);
}

// 8049d26 jne 8049d00 <test_target6+0x1300>
{
if (compare_result != 0) {
    goto L_8049d00;
}
}

// 8049d28 lea -0x1(%edi),%eax
L_8049d28:
{
eax = (edi -0x1);
}

// 8049d2b sub $0x4,%esp
{
esp -= ( +0x4);
compare_result = esp;
}

// 8049d2e push %esi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d2e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d2f push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d2f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d30 push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d30;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d31 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d36;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d36;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d31;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049d36;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049d36 mov %eax,0x1c(%esp)
L_8049d36:
{
{
vaddr = (esp +0x1c);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x1c_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d36;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x1c_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x1c_pin = (esp +0x1c);
}
}

}

// 8049d3a lea -0x1(%esi),%eax
{
eax = (esi -0x1);
}

// 8049d3d add $0xc,%esp
{
esp += ( +0xc);
compare_result = esp;
}

// 8049d40 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d40;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d41 push %edi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d41;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d42 sub $0x1,%ebx
{
ebx -= ( +0x1);
compare_result = ebx;
}

// 8049d45 push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d45;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d46 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d4b;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d4b;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d46;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049d4b;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049d4b add $0xc,%esp
L_8049d4b:
{
esp += ( +0xc);
compare_result = esp;
}

// 8049d4e mov %eax,%ebp
{
ebp = eax;
}

// 8049d50 push %edi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d50;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d51 push %esi
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = esi;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d51;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = esi;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d52 push %ebx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d52;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d53 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d58;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d58;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d53;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049d58;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049d58 add $0xc,%esp
L_8049d58:
{
esp += ( +0xc);
compare_result = esp;
}

// 8049d5b mov 0x10(%esp),%edx
{
if (memcache_esp_0x10_pin == (esp +0x10)) edx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d5b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}

}

// 8049d5f push %edx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d5f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d60 push %ebp
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ebp;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d60;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ebp;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d61 push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d61;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049d62 call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d67;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049d67;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d62;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049d67;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049d67 add $0x10,%esp
L_8049d67:
{
esp += ( +0x10);
compare_result = esp;
}

// 8049d6a add $0x2c,%esp
L_8049d6a:
{
esp += ( +0x2c);
compare_result = esp;
}

// 8049d6d pop %ebx
{
if (memcache_esp_0x0_pin == esp) ebx= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebx= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d6d;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebx= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8049d6e pop %esi
{
if (memcache_esp_0x0_pin == esp) esi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    esi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d6e;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    esi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8049d6f pop %edi
{
if (memcache_esp_0x0_pin == esp) edi= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edi= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    edi= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d6f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edi= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8049d70 pop %ebp
{
if (memcache_esp_0x0_pin == esp) ebp= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ebp= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    ebp= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d70;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ebp= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
}

// 8049d71 ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d71;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 8049d72 lea 0x0(%esi,%eiz,1),%esi
{
esi = (esi + eiz * 0x1);
}

// 8049d79 lea 0x0(%edi,%eiz,1),%edi
{
edi = (edi + eiz * 0x1);
}

// function test_target5();
// 8049d80 sub $0x20,%esp
L_8049d80:
{
esp -= ( +0x20);
compare_result = esp;
}

// 8049d83 movl $0x19,0x8(%esp)
{
{
vaddr = (esp +0x8);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x8_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x8_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d83;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x8_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x19);
    memcache_esp_0x8_pin = (esp +0x8);
}
}

}

// 8049d8b movl $0x7,0xc(%esp)
{
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0xc_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d8b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0xc_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ( +0x7);
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8049d93 movl $0x0,0x10(%esp)
{
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x10_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x10_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d93;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x10_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = 0x0;
    memcache_esp_0x10_pin = (esp +0x10);
}
}

}

// 8049d9b mov 0x10(%esp),%ecx
{
if (memcache_esp_0x10_pin == (esp +0x10)) ecx= (uint) memcache_esp_0x10_data; else 
{
vaddr = (esp +0x10);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    ecx= (uint)(     memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else if (vaddr1_index == cache_last_page2)
{
    ecx= (uint)(    memcache_esp_0x10_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x10_pin = (esp +0x10);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d9b;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    ecx= (uint)(    memcache_esp_0x10_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x10_pin = (esp +0x10);
}
}

}

// 8049d9f mov 0xc(%esp),%edx
{
if (memcache_esp_0xc_pin == (esp +0xc)) edx= (uint) memcache_esp_0xc_data; else 
{
vaddr = (esp +0xc);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    edx= (uint)(     memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else if (vaddr1_index == cache_last_page2)
{
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0xc_pin = (esp +0xc);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049d9f;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    edx= (uint)(    memcache_esp_0xc_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0xc_pin = (esp +0xc);
}
}

}

// 8049da3 mov 0x8(%esp),%eax
{
if (memcache_esp_0x8_pin == (esp +0x8)) eax= (uint) memcache_esp_0x8_data; else 
{
vaddr = (esp +0x8);
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    eax= (uint)(     memcache_esp_0x8_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x8_pin = (esp +0x8);
}
else if (vaddr1_index == cache_last_page2)
{
    eax= (uint)(    memcache_esp_0x8_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x8_pin = (esp +0x8);
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049da3;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    eax= (uint)(    memcache_esp_0x8_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x8_pin = (esp +0x8);
}
}

}

// 8049da7 push %ecx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = ecx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = ecx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049da7;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = ecx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049da8 push %edx
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = edx;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049da8;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = edx;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049da9 push %eax
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = eax;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049da9;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = eax;
    memcache_esp_0x0_pin = esp;
}
}

}

// 8049daa call 8048a00 <test_target6>
{
esp -= 4;
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) = (uint)CallRetAddress__0x8049daf;
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    memcache_esp_0x0_data =     *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) = (uint)CallRetAddress__0x8049daf;
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanWrite == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049daa;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    memcache_esp_0x0_data =     *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) = (uint)CallRetAddress__0x8049daf;
    memcache_esp_0x0_pin = esp;
}
}

if (true) {
    goto L_8048a00;
}
}

// 8049daf add $0x2c,%esp
L_8049daf:
{
esp += ( +0x2c);
compare_result = esp;
}

// 8049db2 ret 
{
if (memcache_esp_0x0_pin == esp) next_return= (uint) memcache_esp_0x0_data; else 
{
vaddr = esp;
vaddr1_index = vaddr / 4096;
vaddr1_offset = vaddr % 4096;
if (vaddr1_index == cache_last_page1)
{
    next_return= (uint)(     memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr1) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else if (vaddr1_index == cache_last_page2)
{
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)(((byte *)cache_last_realaddr2) + vaddr1_offset)) );
    memcache_esp_0x0_pin = esp;
}
else
{
if (pte[vaddr1_index].CanRead == false)
{
    sprintf(exception_string, "Access violation to 0x%x.", vaddr);
    exception_address = 0x8049db2;
    goto L_RETURN;
}
if (((last_used_cache++) % 2) == 0)
{
    cache_last_page1 = vaddr1_index;
    cache_last_realaddr1 = pte[vaddr1_index].RealMemory;
} else {
    cache_last_page2 = vaddr1_index;
    cache_last_realaddr2 = pte[vaddr1_index].RealMemory;
}
    next_return= (uint)(    memcache_esp_0x0_data =  *((uint *)((byte *)(pte[vaddr1_index].RealMemory + vaddr1_offset))) );
    memcache_esp_0x0_pin = esp;
}
}

esp += 4;
goto L_RET_FROM_CALL;
}

// 8049db3 lea 0x0(%esi),%esi
{
esi = esi;
}

// 8049db9 lea 0x0(%edi,%eiz,1),%edi
{
edi = (edi + eiz * 0x1);
}

 // Restore CPU state
L_RETURN:
 state->Eax = eax;  state->Ebx = ebx;  state->Ecx = ecx;  state->Edx = edx; 
 state->Esi = esi;  state->Edi = edi;  state->Ebp = ebp;  state->Esp = esp; 
 strcpy(state->ExceptionString, exception_string);
 state->ExceptionAddress = exception_address;
}
#endif

enum FunctionTable
{
    FunctionTable_test_target1 = 0x80488b0,
    FunctionTable_test_target2 = 0x8048910,
    FunctionTable_test_target4 = 0x8048980,
    FunctionTable_test_target3 = 0x80489e0,
    FunctionTable_test_target6 = 0x8048a00,
    FunctionTable_test_target5 = 0x8049d80,
}
;


