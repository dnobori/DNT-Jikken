using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Ionic.BZip2;
using Ionic.Crc;
using Ionic.Zlib;

namespace Ionic.Zip
{
    // Token: 0x0200003D RID: 61
    internal enum AddOrUpdateAction
    {
        // Token: 0x04000193 RID: 403
        AddOnly,
        // Token: 0x04000194 RID: 404
        AddOrUpdate
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the progress of a Add operation.
    /// </summary>
    // Token: 0x02000030 RID: 48
    public class AddProgressEventArgs : ZipProgressEventArgs
    {
        // Token: 0x0600016F RID: 367 RVA: 0x00007F33 File Offset: 0x00006133
        internal AddProgressEventArgs()
        {
        }

        // Token: 0x06000170 RID: 368 RVA: 0x00007F3E File Offset: 0x0000613E
        private AddProgressEventArgs(string archiveName, ZipProgressEventType flavor) : base(archiveName, flavor)
        {
        }

        // Token: 0x06000171 RID: 369 RVA: 0x00007F4C File Offset: 0x0000614C
        internal static AddProgressEventArgs AfterEntry(string archiveName, ZipEntry entry, int entriesTotal)
        {
            return new AddProgressEventArgs(archiveName, ZipProgressEventType.Adding_AfterAddEntry)
            {
                EntriesTotal = entriesTotal,
                CurrentEntry = entry
            };
        }

        // Token: 0x06000172 RID: 370 RVA: 0x00007F78 File Offset: 0x00006178
        internal static AddProgressEventArgs Started(string archiveName)
        {
            return new AddProgressEventArgs(archiveName, ZipProgressEventType.Adding_Started);
        }

        // Token: 0x06000173 RID: 371 RVA: 0x00007F94 File Offset: 0x00006194
        internal static AddProgressEventArgs Completed(string archiveName)
        {
            return new AddProgressEventArgs(archiveName, ZipProgressEventType.Adding_Completed);
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Issued when an CRC check fails upon extracting an entry from a zip archive.
    /// </summary>
    // Token: 0x02000021 RID: 33
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00009")]
    [Serializable]
    public class BadCrcException : ZipException
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x06000104 RID: 260 RVA: 0x00006AF7 File Offset: 0x00004CF7
        public BadCrcException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x06000105 RID: 261 RVA: 0x00006B02 File Offset: 0x00004D02
        public BadCrcException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x06000106 RID: 262 RVA: 0x00006B0E File Offset: 0x00004D0E
        protected BadCrcException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
    /// with an incorrect password.
    /// </summary>
    // Token: 0x0200001F RID: 31
    [Guid("ebc25cf6-9120-4283-b972-0e5520d0000B")]
    [Serializable]
    public class BadPasswordException : ZipException
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x060000FC RID: 252 RVA: 0x00006A95 File Offset: 0x00004C95
        public BadPasswordException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x060000FD RID: 253 RVA: 0x00006AA0 File Offset: 0x00004CA0
        public BadPasswordException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        /// <param name="innerException">The innerException for this exception.</param>
        // Token: 0x060000FE RID: 254 RVA: 0x00006AAC File Offset: 0x00004CAC
        public BadPasswordException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x060000FF RID: 255 RVA: 0x00006AB9 File Offset: 0x00004CB9
        protected BadPasswordException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Indicates that a read was attempted on a stream, and bad or incomplete data was
    /// received.
    /// </summary>
    // Token: 0x02000020 RID: 32
    [Guid("ebc25cf6-9120-4283-b972-0e5520d0000A")]
    [Serializable]
    public class BadReadException : ZipException
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x06000100 RID: 256 RVA: 0x00006AC6 File Offset: 0x00004CC6
        public BadReadException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x06000101 RID: 257 RVA: 0x00006AD1 File Offset: 0x00004CD1
        public BadReadException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        /// <param name="innerException">The innerException for this exception.</param>
        // Token: 0x06000102 RID: 258 RVA: 0x00006ADD File Offset: 0x00004CDD
        public BadReadException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x06000103 RID: 259 RVA: 0x00006AEA File Offset: 0x00004CEA
        protected BadReadException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Indicates that an operation was attempted on a ZipFile which was not possible
    /// given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
    /// which has no filename set, you can get this exception.
    /// </summary>
    // Token: 0x02000023 RID: 35
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00007")]
    [Serializable]
    public class BadStateException : ZipException
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x0600010A RID: 266 RVA: 0x00006B3F File Offset: 0x00004D3F
        public BadStateException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x0600010B RID: 267 RVA: 0x00006B4A File Offset: 0x00004D4A
        public BadStateException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        /// <param name="innerException">The innerException for this exception.</param>
        // Token: 0x0600010C RID: 268 RVA: 0x00006B56 File Offset: 0x00004D56
        public BadStateException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x0600010D RID: 269 RVA: 0x00006B63 File Offset: 0x00004D63
        protected BadStateException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   Delegate in which the application closes the stream, just-in-time, for the named entry.
    /// </summary>
    ///
    /// <param name="entryName">
    /// The name of the ZipEntry that the application should close the stream for.
    /// </param>
    ///
    /// <param name="stream">The stream to be closed.</param>
    ///
    /// <remarks>
    ///   When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />, the application code provides the logic that
    ///   opens and closes the stream for the given ZipEntry.
    /// </remarks>
    ///
    /// <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
    // Token: 0x0200002B RID: 43
    // (Invoke) Token: 0x06000151 RID: 337
    public delegate void CloseDelegate(string entryName, Stream stream);
}

namespace Ionic.Zip
{
    /// <summary>
    /// This class exposes a set of COM-accessible wrappers for static
    /// methods available on the ZipFile class.  You don't need this
    /// class unless you are using DotNetZip from a COM environment.
    /// </summary>
    // Token: 0x02000008 RID: 8
    [ComVisible(true)]
    [Guid("ebc25cf6-9120-4283-b972-0e5520d0000F")]
    [ClassInterface(ClassInterfaceType.AutoDispatch)]
    public class ComHelper
    {
        /// <summary>
        ///  A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">ZipFile.IsZipFile(string)</see>
        /// </summary>
        /// <param name="filename">The filename to of the zip file to check.</param>
        /// <returns>true if the file contains a valid zip file.</returns>
        // Token: 0x06000081 RID: 129 RVA: 0x00003DA8 File Offset: 0x00001FA8
        public bool IsZipFile(string filename)
        {
            return ZipFile.IsZipFile(filename);
        }

        /// <summary>
        ///  A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">ZipFile.IsZipFile(string, bool)</see>
        /// </summary>
        /// <remarks>
        /// We cannot use "overloaded" Method names in COM interop.
        /// So, here, we use a unique name.
        /// </remarks>
        /// <param name="filename">The filename to of the zip file to check.</param>
        /// <returns>true if the file contains a valid zip file.</returns>
        // Token: 0x06000082 RID: 130 RVA: 0x00003DC0 File Offset: 0x00001FC0
        public bool IsZipFileWithExtract(string filename)
        {
            return ZipFile.IsZipFile(filename, true);
        }

        /// <summary>
        ///  A wrapper for <see cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)">ZipFile.CheckZip(string)</see>
        /// </summary>
        /// <param name="filename">The filename to of the zip file to check.</param>
        ///
        /// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        // Token: 0x06000083 RID: 131 RVA: 0x00003DDC File Offset: 0x00001FDC
        public bool CheckZip(string filename)
        {
            return ZipFile.CheckZip(filename);
        }

        /// <summary>
        ///  A COM-friendly wrapper for the static method <see cref="M:Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)" />.
        /// </summary>
        ///
        /// <param name="filename">The filename to of the zip file to check.</param>
        ///
        /// <param name="password">The password to check.</param>
        ///
        /// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        // Token: 0x06000084 RID: 132 RVA: 0x00003DF4 File Offset: 0x00001FF4
        public bool CheckZipPassword(string filename, string password)
        {
            return ZipFile.CheckZipPassword(filename, password);
        }

        /// <summary>
        ///  A wrapper for <see cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">ZipFile.FixZipDirectory(string)</see>
        /// </summary>
        /// <param name="filename">The filename to of the zip file to fix.</param>
        // Token: 0x06000085 RID: 133 RVA: 0x00003E0D File Offset: 0x0000200D
        public void FixZipDirectory(string filename)
        {
            ZipFile.FixZipDirectory(filename);
        }

        /// <summary>
        ///  A wrapper for <see cref="P:Ionic.Zip.ZipFile.LibraryVersion">ZipFile.LibraryVersion</see>
        /// </summary>
        /// <returns>
        ///  the version number on the DotNetZip assembly, formatted as a string.
        /// </returns>
        // Token: 0x06000086 RID: 134 RVA: 0x00003E18 File Offset: 0x00002018
        public string GetZipLibraryVersion()
        {
            return ZipFile.LibraryVersion.ToString();
        }
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   The method of compression to use for a particular ZipEntry.
    /// </summary>
    ///
    /// <remarks>
    ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
    ///   ZIP Specification</see> describes a number of distinct
    ///   cmopression methods that can be used within a zip
    ///   file. DotNetZip supports a subset of them.
    /// </remarks>
    // Token: 0x02000038 RID: 56
    public enum CompressionMethod
    {
        /// <summary>
        /// No compression at all. For COM environments, the value is 0 (zero).
        /// </summary>
        // Token: 0x04000142 RID: 322
        None,
        /// <summary>
        ///   DEFLATE compression, as described in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
        ///   1951</see>.  This is the "normal" compression used in zip
        ///   files. For COM environments, the value is 8.
        /// </summary>
        // Token: 0x04000143 RID: 323
        Deflate = 8,
        /// <summary>
        ///   BZip2 compression, a compression algorithm developed by Julian Seward.
        ///   For COM environments, the value is 12.
        /// </summary>
        // Token: 0x04000144 RID: 324
        BZip2 = 12
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   A decorator stream. It wraps another stream, and performs bookkeeping
    ///   to keep track of the stream Position.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     In some cases, it is not possible to get the Position of a stream, let's
    ///     say, on a write-only output stream like ASP.NET's
    ///     <c>Response.OutputStream</c>, or on a different write-only stream
    ///     provided as the destination for the zip by the application.  In this
    ///     case, programmers can use this counting stream to count the bytes read
    ///     or written.
    ///   </para>
    ///   <para>
    ///     Consider the scenario of an application that saves a self-extracting
    ///     archive (SFX), that uses a custom SFX stub.
    ///   </para>
    ///   <para>
    ///     Saving to a filesystem file, the application would open the
    ///     filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
    ///     into it, and then call <c>ZipFile.Save()</c>, specifying the same
    ///     FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
    ///     offsets, by inquiring the Position of the <c>FileStream</c> before writing
    ///     any data, and then adding that initial offset into any ZipEntry
    ///     offsets in the zip directory. Everything works fine.
    ///   </para>
    ///   <para>
    ///     Now suppose the application is an ASPNET application and it saves
    ///     directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
    ///     inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
    ///   </para>
    ///   <para>
    ///     The workaround is for the application to use this class to wrap
    ///     <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
    ///     into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
    ///     <c>Position</c>, it will then do the right thing with the offsets.
    ///   </para>
    /// </remarks>
    // Token: 0x02000025 RID: 37
    public class CountingStream : Stream
    {
        /// <summary>
        /// The constructor.
        /// </summary>
        /// <param name="stream">The underlying stream</param>
        // Token: 0x06000123 RID: 291 RVA: 0x000075D8 File Offset: 0x000057D8
        public CountingStream(Stream stream)
        {
            this._s = stream;
            try
            {
                this._initialOffset = this._s.Position;
            }
            catch
            {
                this._initialOffset = 0L;
            }
        }

        /// <summary>
        ///   Gets the wrapped stream.
        /// </summary>
        // Token: 0x17000055 RID: 85
        // (get) Token: 0x06000124 RID: 292 RVA: 0x00007628 File Offset: 0x00005828
        public Stream WrappedStream
        {
            get
            {
                return this._s;
            }
        }

        /// <summary>
        ///   The count of bytes written out to the stream.
        /// </summary>
        // Token: 0x17000056 RID: 86
        // (get) Token: 0x06000125 RID: 293 RVA: 0x00007640 File Offset: 0x00005840
        public long BytesWritten
        {
            get
            {
                return this._bytesWritten;
            }
        }

        /// <summary>
        ///   the count of bytes that have been read from the stream.
        /// </summary>
        // Token: 0x17000057 RID: 87
        // (get) Token: 0x06000126 RID: 294 RVA: 0x00007658 File Offset: 0x00005858
        public long BytesRead
        {
            get
            {
                return this._bytesRead;
            }
        }

        /// <summary>
        ///    Adjust the byte count on the stream.
        /// </summary>
        ///
        /// <param name="delta">
        ///   the number of bytes to subtract from the count.
        /// </param>
        ///
        /// <remarks>
        ///   <para>
        ///     Subtract delta from the count of bytes written to the stream.
        ///     This is necessary when seeking back, and writing additional data,
        ///     as happens in some cases when saving Zip files.
        ///   </para>
        /// </remarks>
        // Token: 0x06000127 RID: 295 RVA: 0x00007670 File Offset: 0x00005870
        public void Adjust(long delta)
        {
            this._bytesWritten -= delta;
            if (this._bytesWritten < 0L)
            {
                throw new InvalidOperationException();
            }
            if (this._s is CountingStream)
            {
                ((CountingStream)this._s).Adjust(delta);
            }
        }

        /// <summary>
        ///   The read method.
        /// </summary>
        /// <param name="buffer">The buffer to hold the data read from the stream.</param>
        /// <param name="offset">the offset within the buffer to copy the first byte read.</param>
        /// <param name="count">the number of bytes to read.</param>
        /// <returns>the number of bytes read, after decryption and decompression.</returns>
        // Token: 0x06000128 RID: 296 RVA: 0x000076C8 File Offset: 0x000058C8
        public override int Read(byte[] buffer, int offset, int count)
        {
            int i = this._s.Read(buffer, offset, count);
            this._bytesRead += (long)i;
            return i;
        }

        /// <summary>
        ///   Write data into the stream.
        /// </summary>
        /// <param name="buffer">The buffer holding data to write to the stream.</param>
        /// <param name="offset">the offset within that data array to find the first byte to write.</param>
        /// <param name="count">the number of bytes to write.</param>
        // Token: 0x06000129 RID: 297 RVA: 0x000076FC File Offset: 0x000058FC
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (count != 0)
            {
                this._s.Write(buffer, offset, count);
                this._bytesWritten += (long)count;
            }
        }

        /// <summary>
        ///   Whether the stream can be read.
        /// </summary>
        // Token: 0x17000058 RID: 88
        // (get) Token: 0x0600012A RID: 298 RVA: 0x00007738 File Offset: 0x00005938
        public override bool CanRead
        {
            get
            {
                return this._s.CanRead;
            }
        }

        /// <summary>
        ///   Whether it is possible to call Seek() on the stream.
        /// </summary>
        // Token: 0x17000059 RID: 89
        // (get) Token: 0x0600012B RID: 299 RVA: 0x00007758 File Offset: 0x00005958
        public override bool CanSeek
        {
            get
            {
                return this._s.CanSeek;
            }
        }

        /// <summary>
        ///   Whether it is possible to call Write() on the stream.
        /// </summary>
        // Token: 0x1700005A RID: 90
        // (get) Token: 0x0600012C RID: 300 RVA: 0x00007778 File Offset: 0x00005978
        public override bool CanWrite
        {
            get
            {
                return this._s.CanWrite;
            }
        }

        /// <summary>
        ///   Flushes the underlying stream.
        /// </summary>
        // Token: 0x0600012D RID: 301 RVA: 0x00007795 File Offset: 0x00005995
        public override void Flush()
        {
            this._s.Flush();
        }

        /// <summary>
        ///   The length of the underlying stream.
        /// </summary>
        // Token: 0x1700005B RID: 91
        // (get) Token: 0x0600012E RID: 302 RVA: 0x000077A4 File Offset: 0x000059A4
        public override long Length
        {
            get
            {
                return this._s.Length;
            }
        }

        /// <summary>
        ///   Returns the sum of number of bytes written, plus the initial
        ///   offset before writing.
        /// </summary>
        // Token: 0x1700005C RID: 92
        // (get) Token: 0x0600012F RID: 303 RVA: 0x000077C4 File Offset: 0x000059C4
        public long ComputedPosition
        {
            get
            {
                return this._initialOffset + this._bytesWritten;
            }
        }

        /// <summary>
        ///   The Position of the stream.
        /// </summary>
        // Token: 0x1700005D RID: 93
        // (get) Token: 0x06000130 RID: 304 RVA: 0x000077E4 File Offset: 0x000059E4
        // (set) Token: 0x06000131 RID: 305 RVA: 0x00007801 File Offset: 0x00005A01
        public override long Position
        {
            get
            {
                return this._s.Position;
            }
            set
            {
                this._s.Seek(value, SeekOrigin.Begin);
            }
        }

        /// <summary>
        ///   Seek in the stream.
        /// </summary>
        /// <param name="offset">the offset point to seek to</param>
        /// <param name="origin">the reference point from which to seek</param>
        /// <returns>The new position</returns>
        // Token: 0x06000132 RID: 306 RVA: 0x00007814 File Offset: 0x00005A14
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this._s.Seek(offset, origin);
        }

        /// <summary>
        ///   Set the length of the underlying stream.  Be careful with this!
        /// </summary>
        ///
        /// <param name="value">the length to set on the underlying stream.</param>
        // Token: 0x06000133 RID: 307 RVA: 0x00007833 File Offset: 0x00005A33
        public override void SetLength(long value)
        {
            this._s.SetLength(value);
        }

        // Token: 0x040000B6 RID: 182
        private Stream _s;

        // Token: 0x040000B7 RID: 183
        private long _bytesWritten;

        // Token: 0x040000B8 RID: 184
        private long _bytesRead;

        // Token: 0x040000B9 RID: 185
        private long _initialOffset;
    }
}

namespace Ionic.Zip
{
    // Token: 0x02000027 RID: 39
    internal enum CryptoMode
    {
        // Token: 0x040000BD RID: 189
        Encrypt,
        // Token: 0x040000BE RID: 190
        Decrypt
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// An enum that provides the various encryption algorithms supported by this
    /// library.
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    ///   <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
    ///   weak and subvertible.
    /// </para>
    ///
    /// <para>
    ///   A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
    ///   specified in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
    ///   specification</see>, and are considered to be "standard".  Zip archives
    ///   produced using these options will be interoperable with many other zip tools
    ///   and libraries, including Windows Explorer.
    /// </para>
    ///
    /// <para>
    ///   Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
    ///   specification, but rather imply the use of a vendor-specific extension from
    ///   WinZip. If you want to produce interoperable Zip archives, do not use these
    ///   values.  For example, if you produce a zip archive using WinZipAes256, you
    ///   will be able to open it in Windows Explorer on Windows XP and Vista, but you
    ///   will not be able to extract entries; trying this will lead to an "unspecified
    ///   error". For this reason, some people have said that a zip archive that uses
    ///   WinZip's AES encryption is not actually a zip archive at all.  A zip archive
    ///   produced this way will be readable with the WinZip tool (Version 11 and
    ///   beyond).
    /// </para>
    ///
    /// <para>
    ///   There are other third-party tools and libraries, both commercial and
    ///   otherwise, that support WinZip's AES encryption. These will be able to read
    ///   AES-encrypted zip archives produced by DotNetZip, and conversely applications
    ///   that use DotNetZip to read zip archives will be able to read AES-encrypted
    ///   archives produced by those tools or libraries.  Consult the documentation for
    ///   those other tools and libraries to find out if WinZip's AES encryption is
    ///   supported.
    /// </para>
    ///
    /// <para>
    ///   In case you care: According to <see href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
    ///   actual AES key used is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password" /> via an
    ///   algorithm that complies with <see href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
    ///   count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
    ///   for "Password Based Key Derivation Function #2".
    /// </para>
    ///
    /// <para>
    ///   A word about password strength and length: The AES encryption technology is
    ///   very good, but any system is only as secure as the weakest link.  If you want
    ///   to secure your data, be sure to use a password that is hard to guess.  To make
    ///   it harder to guess (increase its "entropy"), you should make it longer.  If
    ///   you use normal characters from an ASCII keyboard, a password of length 20 will
    ///   be strong enough that it will be impossible to guess.  For more information on
    ///   that, I'd encourage you to read <see href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
    ///   article.</see>
    /// </para>
    ///
    /// <para>
    ///   The WinZip AES algorithms are not supported with the version of DotNetZip that
    ///   runs on the .NET Compact Framework.  This is because .NET CF lacks the
    ///   HMACSHA1 class that is required for producing the archive.
    /// </para>
    /// </remarks>
    // Token: 0x0200000B RID: 11
    public enum EncryptionAlgorithm
    {
        /// <summary>
        /// No encryption at all.
        /// </summary>
        // Token: 0x04000051 RID: 81
        None,
        /// <summary>
        /// Traditional or Classic pkzip encryption.
        /// </summary>
        // Token: 0x04000052 RID: 82
        PkzipWeak,
        /// <summary>
        /// WinZip AES encryption (128 key bits).
        /// </summary>
        // Token: 0x04000053 RID: 83
        WinZipAes128,
        /// <summary>
        /// WinZip AES encryption (256 key bits).
        /// </summary>
        // Token: 0x04000054 RID: 84
        WinZipAes256,
        /// <summary>
        /// An encryption algorithm that is not supported by DotNetZip.
        /// </summary>
        // Token: 0x04000055 RID: 85
        Unsupported
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// An enum for the options when extracting an entry would overwrite an existing file. 
    /// </summary>
    ///
    /// <remarks>
    ///   <para>
    ///     This enum describes the actions that the library can take when an
    ///     <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
    ///     entry to a filesystem, and the extraction would overwrite an existing filesystem
    ///     file.
    ///   </para>
    /// </remarks>
    // Token: 0x0200000C RID: 12
    public enum ExtractExistingFileAction
    {
        /// <summary>
        /// Throw an exception when extraction would overwrite an existing file. (For
        /// COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x04000057 RID: 87
        Throw,
        /// <summary>
        /// When extraction would overwrite an existing file, overwrite the file silently.
        /// The overwrite will happen even if the target file is marked as read-only.
        /// (For COM clients, this is a 1.)
        /// </summary>
        // Token: 0x04000058 RID: 88
        OverwriteSilently,
        /// <summary>
        /// When extraction would overwrite an existing file, don't overwrite the file, silently. 
        /// (For COM clients, this is a 2.)
        /// </summary>
        // Token: 0x04000059 RID: 89
        DoNotOverwrite,
        /// <summary>
        /// When extraction would overwrite an existing file, invoke the ExtractProgress
        /// event, using an event type of <see cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite" />.  In
        /// this way, the application can decide, just-in-time, whether to overwrite the
        /// file. For example, a GUI application may wish to pop up a dialog to allow
        /// the user to choose. You may want to examine the <see cref="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation" /> property before making
        /// the decision. If, after your processing in the Extract progress event, you
        /// want to NOT extract the file, set <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        /// on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
        /// If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
        /// to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
        /// <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
        /// DoNotOverwrite in that a cancel will not extract any further entries, if
        /// there are any.  (For COM clients, the value of this enum is a 3.)
        /// </summary>
        // Token: 0x0400005A RID: 90
        InvokeExtractProgressEvent
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the progress of the extract operation.
    /// </summary>
    // Token: 0x02000032 RID: 50
    public class ExtractProgressEventArgs : ZipProgressEventArgs
    {
        /// <summary>
        /// Constructor for the ExtractProgressEventArgs.
        /// </summary>
        /// <param name="archiveName">the name of the zip archive.</param>
        /// <param name="before">whether this is before saving the entry, or after</param>
        /// <param name="entriesTotal">The total number of entries in the zip archive.</param>
        /// <param name="entriesExtracted">Number of entries that have been extracted.</param>
        /// <param name="entry">The entry involved in the event.</param>
        /// <param name="extractLocation">The location to which entries are extracted.</param>
        // Token: 0x0600017B RID: 379 RVA: 0x00008084 File Offset: 0x00006284
        internal ExtractProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesExtracted, ZipEntry entry, string extractLocation) : base(archiveName, before ? ZipProgressEventType.Extracting_BeforeExtractEntry : ZipProgressEventType.Extracting_AfterExtractEntry)
        {
            base.EntriesTotal = entriesTotal;
            base.CurrentEntry = entry;
            this._entriesExtracted = entriesExtracted;
            this._target = extractLocation;
        }

        // Token: 0x0600017C RID: 380 RVA: 0x000080BA File Offset: 0x000062BA
        internal ExtractProgressEventArgs(string archiveName, ZipProgressEventType flavor) : base(archiveName, flavor)
        {
        }

        // Token: 0x0600017D RID: 381 RVA: 0x000080C7 File Offset: 0x000062C7
        internal ExtractProgressEventArgs()
        {
        }

        // Token: 0x0600017E RID: 382 RVA: 0x000080D4 File Offset: 0x000062D4
        internal static ExtractProgressEventArgs BeforeExtractEntry(string archiveName, ZipEntry entry, string extractLocation)
        {
            return new ExtractProgressEventArgs
            {
                ArchiveName = archiveName,
                EventType = ZipProgressEventType.Extracting_BeforeExtractEntry,
                CurrentEntry = entry,
                _target = extractLocation
            };
        }

        // Token: 0x0600017F RID: 383 RVA: 0x00008110 File Offset: 0x00006310
        internal static ExtractProgressEventArgs ExtractExisting(string archiveName, ZipEntry entry, string extractLocation)
        {
            return new ExtractProgressEventArgs
            {
                ArchiveName = archiveName,
                EventType = ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite,
                CurrentEntry = entry,
                _target = extractLocation
            };
        }

        // Token: 0x06000180 RID: 384 RVA: 0x0000814C File Offset: 0x0000634C
        internal static ExtractProgressEventArgs AfterExtractEntry(string archiveName, ZipEntry entry, string extractLocation)
        {
            return new ExtractProgressEventArgs
            {
                ArchiveName = archiveName,
                EventType = ZipProgressEventType.Extracting_AfterExtractEntry,
                CurrentEntry = entry,
                _target = extractLocation
            };
        }

        // Token: 0x06000181 RID: 385 RVA: 0x00008188 File Offset: 0x00006388
        internal static ExtractProgressEventArgs ExtractAllStarted(string archiveName, string extractLocation)
        {
            return new ExtractProgressEventArgs(archiveName, ZipProgressEventType.Extracting_BeforeExtractAll)
            {
                _target = extractLocation
            };
        }

        // Token: 0x06000182 RID: 386 RVA: 0x000081AC File Offset: 0x000063AC
        internal static ExtractProgressEventArgs ExtractAllCompleted(string archiveName, string extractLocation)
        {
            return new ExtractProgressEventArgs(archiveName, ZipProgressEventType.Extracting_AfterExtractAll)
            {
                _target = extractLocation
            };
        }

        // Token: 0x06000183 RID: 387 RVA: 0x000081D0 File Offset: 0x000063D0
        internal static ExtractProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesWritten, long totalBytes)
        {
            return new ExtractProgressEventArgs(archiveName, ZipProgressEventType.Extracting_EntryBytesWritten)
            {
                ArchiveName = archiveName,
                CurrentEntry = entry,
                BytesTransferred = bytesWritten,
                TotalBytesToTransfer = totalBytes
            };
        }

        /// <summary>
        /// Number of entries extracted so far.  This is set only if the
        /// EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
        /// the Extract() is occurring witin the scope of a call to ExtractAll().
        /// </summary>
        // Token: 0x1700006C RID: 108
        // (get) Token: 0x06000184 RID: 388 RVA: 0x0000820C File Offset: 0x0000640C
        public int EntriesExtracted
        {
            get
            {
                return this._entriesExtracted;
            }
        }

        /// <summary>
        /// Returns the extraction target location, a filesystem path.
        /// </summary>
        // Token: 0x1700006D RID: 109
        // (get) Token: 0x06000185 RID: 389 RVA: 0x00008224 File Offset: 0x00006424
        public string ExtractLocation
        {
            get
            {
                return this._target;
            }
        }

        // Token: 0x040000E3 RID: 227
        private int _entriesExtracted;

        // Token: 0x040000E4 RID: 228
        private string _target;
    }
}


namespace Ionic.Zip
{
    // Token: 0x02000009 RID: 9
    internal class OffsetStream : Stream, IDisposable
    {
        // Token: 0x06000088 RID: 136 RVA: 0x00003E3C File Offset: 0x0000203C
        public OffsetStream(Stream s)
        {
            this._originalPosition = s.Position;
            this._innerStream = s;
        }

        // Token: 0x06000089 RID: 137 RVA: 0x00003E5C File Offset: 0x0000205C
        public override int Read(byte[] buffer, int offset, int count)
        {
            return this._innerStream.Read(buffer, offset, count);
        }

        // Token: 0x0600008A RID: 138 RVA: 0x00003E7C File Offset: 0x0000207C
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotImplementedException();
        }

        // Token: 0x1700003C RID: 60
        // (get) Token: 0x0600008B RID: 139 RVA: 0x00003E84 File Offset: 0x00002084
        public override bool CanRead
        {
            get
            {
                return this._innerStream.CanRead;
            }
        }

        // Token: 0x1700003D RID: 61
        // (get) Token: 0x0600008C RID: 140 RVA: 0x00003EA4 File Offset: 0x000020A4
        public override bool CanSeek
        {
            get
            {
                return this._innerStream.CanSeek;
            }
        }

        // Token: 0x1700003E RID: 62
        // (get) Token: 0x0600008D RID: 141 RVA: 0x00003EC4 File Offset: 0x000020C4
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        // Token: 0x0600008E RID: 142 RVA: 0x00003ED7 File Offset: 0x000020D7
        public override void Flush()
        {
            this._innerStream.Flush();
        }

        // Token: 0x1700003F RID: 63
        // (get) Token: 0x0600008F RID: 143 RVA: 0x00003EE8 File Offset: 0x000020E8
        public override long Length
        {
            get
            {
                return this._innerStream.Length;
            }
        }

        // Token: 0x17000040 RID: 64
        // (get) Token: 0x06000090 RID: 144 RVA: 0x00003F08 File Offset: 0x00002108
        // (set) Token: 0x06000091 RID: 145 RVA: 0x00003F2C File Offset: 0x0000212C
        public override long Position
        {
            get
            {
                return this._innerStream.Position - this._originalPosition;
            }
            set
            {
                this._innerStream.Position = this._originalPosition + value;
            }
        }

        // Token: 0x06000092 RID: 146 RVA: 0x00003F44 File Offset: 0x00002144
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this._innerStream.Seek(this._originalPosition + offset, origin) - this._originalPosition;
        }

        // Token: 0x06000093 RID: 147 RVA: 0x00003F71 File Offset: 0x00002171
        public override void SetLength(long value)
        {
            throw new NotImplementedException();
        }

        // Token: 0x06000094 RID: 148 RVA: 0x00003F79 File Offset: 0x00002179
        void IDisposable.Dispose()
        {
            this.Close();
        }

        // Token: 0x06000095 RID: 149 RVA: 0x00003F83 File Offset: 0x00002183
        public override void Close()
        {
            base.Close();
        }

        // Token: 0x04000049 RID: 73
        private long _originalPosition;

        // Token: 0x0400004A RID: 74
        private Stream _innerStream;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   Delegate in which the application opens the stream, just-in-time, for the named entry.
    /// </summary>
    ///
    /// <param name="entryName">
    /// The name of the ZipEntry that the application should open the stream for.
    /// </param>
    ///
    /// <remarks>
    ///   When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />, the application code provides the logic that
    ///   opens and closes the stream for the given ZipEntry.
    /// </remarks>
    ///
    /// <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
    // Token: 0x0200002A RID: 42
    // (Invoke) Token: 0x0600014D RID: 333
    public delegate Stream OpenDelegate(string entryName);
}


namespace Ionic.Zip
{
    /// <summary>
    ///   A class for collecting the various options that can be used when
    ///   Reading zip files for extraction or update.
    /// </summary>
    ///
    /// <remarks>
    ///   <para>
    ///     When reading a zip file, there are several options an
    ///     application can set, to modify how the file is read, or what
    ///     the library does while reading.  This class collects those
    ///     options into one container.
    ///   </para>
    ///
    ///   <para>
    ///     Pass an instance of the <c>ReadOptions</c> class into the
    ///     <c>ZipFile.Read()</c> method.
    ///   </para>
    ///
    /// <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />.
    /// <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)" />.
    /// </remarks>
    // Token: 0x0200003E RID: 62
    public class ReadOptions
    {
        /// <summary>
        /// An event handler for Read operations.  When opening large zip
        /// archives, you may want to display a progress bar or other
        /// indicator of status progress while reading.  This parameter
        /// allows you to specify a ReadProgress Event Handler directly.
        /// When you call <c>Read()</c>, the progress event is invoked as
        /// necessary.
        /// </summary>
        // Token: 0x170000CE RID: 206
        // (get) Token: 0x0600030F RID: 783 RVA: 0x00014FF8 File Offset: 0x000131F8
        // (set) Token: 0x06000310 RID: 784 RVA: 0x0001500F File Offset: 0x0001320F
        public EventHandler<ReadProgressEventArgs> ReadProgress { get; set; }

        /// <summary>
        /// The <c>System.IO.TextWriter</c> to use for writing verbose status messages
        /// during operations on the zip archive.  A console application may wish to
        /// pass <c>System.Console.Out</c> to get messages on the Console. A graphical
        /// or headless application may wish to capture the messages in a different
        /// <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
        /// </summary>
        // Token: 0x170000CF RID: 207
        // (get) Token: 0x06000311 RID: 785 RVA: 0x00015018 File Offset: 0x00013218
        // (set) Token: 0x06000312 RID: 786 RVA: 0x0001502F File Offset: 0x0001322F
        public TextWriter StatusMessageWriter { get; set; }

        /// <summary>
        /// The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
        /// careful specifying the encoding.  If the value you use here is not the same
        /// as the Encoding used when the zip archive was created (possibly by a
        /// different archiver) you will get unexpected results and possibly exceptions.
        /// </summary>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        // Token: 0x170000D0 RID: 208
        // (get) Token: 0x06000313 RID: 787 RVA: 0x00015038 File Offset: 0x00013238
        // (set) Token: 0x06000314 RID: 788 RVA: 0x0001504F File Offset: 0x0001324F
        public Encoding Encoding { get; set; }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the progress of a Read operation.
    /// </summary>
    // Token: 0x0200002F RID: 47
    public class ReadProgressEventArgs : ZipProgressEventArgs
    {
        // Token: 0x06000168 RID: 360 RVA: 0x00007E5E File Offset: 0x0000605E
        internal ReadProgressEventArgs()
        {
        }

        // Token: 0x06000169 RID: 361 RVA: 0x00007E69 File Offset: 0x00006069
        private ReadProgressEventArgs(string archiveName, ZipProgressEventType flavor) : base(archiveName, flavor)
        {
        }

        // Token: 0x0600016A RID: 362 RVA: 0x00007E78 File Offset: 0x00006078
        internal static ReadProgressEventArgs Before(string archiveName, int entriesTotal)
        {
            return new ReadProgressEventArgs(archiveName, ZipProgressEventType.Reading_BeforeReadEntry)
            {
                EntriesTotal = entriesTotal
            };
        }

        // Token: 0x0600016B RID: 363 RVA: 0x00007E9C File Offset: 0x0000609C
        internal static ReadProgressEventArgs After(string archiveName, ZipEntry entry, int entriesTotal)
        {
            return new ReadProgressEventArgs(archiveName, ZipProgressEventType.Reading_AfterReadEntry)
            {
                EntriesTotal = entriesTotal,
                CurrentEntry = entry
            };
        }

        // Token: 0x0600016C RID: 364 RVA: 0x00007EC8 File Offset: 0x000060C8
        internal static ReadProgressEventArgs Started(string archiveName)
        {
            return new ReadProgressEventArgs(archiveName, ZipProgressEventType.Reading_Started);
        }

        // Token: 0x0600016D RID: 365 RVA: 0x00007EE4 File Offset: 0x000060E4
        internal static ReadProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes)
        {
            return new ReadProgressEventArgs(archiveName, ZipProgressEventType.Reading_ArchiveBytesRead)
            {
                CurrentEntry = entry,
                BytesTransferred = bytesXferred,
                TotalBytesToTransfer = totalBytes
            };
        }

        // Token: 0x0600016E RID: 366 RVA: 0x00007F18 File Offset: 0x00006118
        internal static ReadProgressEventArgs Completed(string archiveName)
        {
            return new ReadProgressEventArgs(archiveName, ZipProgressEventType.Reading_Completed);
        }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the progress of a save operation.
    /// </summary>
    // Token: 0x02000031 RID: 49
    public class SaveProgressEventArgs : ZipProgressEventArgs
    {
        /// <summary>
        /// Constructor for the SaveProgressEventArgs.
        /// </summary>
        /// <param name="archiveName">the name of the zip archive.</param>
        /// <param name="before">whether this is before saving the entry, or after</param>
        /// <param name="entriesTotal">The total number of entries in the zip archive.</param>
        /// <param name="entriesSaved">Number of entries that have been saved.</param>
        /// <param name="entry">The entry involved in the event.</param>
        // Token: 0x06000174 RID: 372 RVA: 0x00007FAF File Offset: 0x000061AF
        internal SaveProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesSaved, ZipEntry entry) : base(archiveName, before ? ZipProgressEventType.Saving_BeforeWriteEntry : ZipProgressEventType.Saving_AfterWriteEntry)
        {
            base.EntriesTotal = entriesTotal;
            base.CurrentEntry = entry;
            this._entriesSaved = entriesSaved;
        }

        // Token: 0x06000175 RID: 373 RVA: 0x00007FDD File Offset: 0x000061DD
        internal SaveProgressEventArgs()
        {
        }

        // Token: 0x06000176 RID: 374 RVA: 0x00007FE8 File Offset: 0x000061E8
        internal SaveProgressEventArgs(string archiveName, ZipProgressEventType flavor) : base(archiveName, flavor)
        {
        }

        // Token: 0x06000177 RID: 375 RVA: 0x00007FF8 File Offset: 0x000061F8
        internal static SaveProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes)
        {
            return new SaveProgressEventArgs(archiveName, ZipProgressEventType.Saving_EntryBytesRead)
            {
                ArchiveName = archiveName,
                CurrentEntry = entry,
                BytesTransferred = bytesXferred,
                TotalBytesToTransfer = totalBytes
            };
        }

        // Token: 0x06000178 RID: 376 RVA: 0x00008034 File Offset: 0x00006234
        internal static SaveProgressEventArgs Started(string archiveName)
        {
            return new SaveProgressEventArgs(archiveName, ZipProgressEventType.Saving_Started);
        }

        // Token: 0x06000179 RID: 377 RVA: 0x00008050 File Offset: 0x00006250
        internal static SaveProgressEventArgs Completed(string archiveName)
        {
            return new SaveProgressEventArgs(archiveName, ZipProgressEventType.Saving_Completed);
        }

        /// <summary>
        /// Number of entries saved so far.
        /// </summary>
        // Token: 0x1700006B RID: 107
        // (get) Token: 0x0600017A RID: 378 RVA: 0x0000806C File Offset: 0x0000626C
        public int EntriesSaved
        {
            get
            {
                return this._entriesSaved;
            }
        }

        // Token: 0x040000E2 RID: 226
        private int _entriesSaved;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// An enum that provides the different self-extractor flavors
    /// </summary>
    // Token: 0x02000040 RID: 64
    public enum SelfExtractorFlavor
    {
        /// <summary>
        /// A self-extracting zip archive that runs from the console or
        /// command line.
        /// </summary>
        // Token: 0x04000199 RID: 409
        ConsoleApplication,
        /// <summary>
        /// A self-extracting zip archive that presents a graphical user
        /// interface when it is executed.
        /// </summary>
        // Token: 0x0400019A RID: 410
        WinFormsApplication
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// The options for generating a self-extracting archive.
    /// </summary>
    // Token: 0x02000041 RID: 65
    public class SelfExtractorSaveOptions
    {
        /// <summary>
        ///   The type of SFX to create.
        /// </summary>
        // Token: 0x170000D1 RID: 209
        // (get) Token: 0x0600031B RID: 795 RVA: 0x0001585C File Offset: 0x00013A5C
        // (set) Token: 0x0600031C RID: 796 RVA: 0x00015873 File Offset: 0x00013A73
        public SelfExtractorFlavor Flavor { get; set; }

        /// <summary>
        ///   The command to run after extraction.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is optional. Leave it empty (<c>null</c> in C# or <c>Nothing</c> in
        ///   VB) to run no command after extraction.
        /// </para>
        ///
        /// <para>
        ///   If it is non-empty, the SFX will execute the command specified in this
        ///   string on the user's machine, and using the extract directory as the
        ///   working directory for the process, after unpacking the archive. The
        ///   program to execute can include a path, if you like. If you want to execute
        ///   a program that accepts arguments, specify the program name, followed by a
        ///   space, and then the arguments for the program, each separated by a space,
        ///   just as you would on a normal command line. Example: <c>program.exe arg1
        ///   arg2</c>.  The string prior to the first space will be taken as the
        ///   program name, and the string following the first space specifies the
        ///   arguments to the program.
        /// </para>
        ///
        /// <para>
        ///   If you want to execute a program that has a space in the name or path of
        ///   the file, surround the program name in double-quotes. The first character
        ///   of the command line should be a double-quote character, and there must be
        ///   a matching double-quote following the end of the program file name. Any
        ///   optional arguments to the program follow that, separated by
        ///   spaces. Example: <c>"c:\project files\program name.exe" arg1 arg2</c>.
        /// </para>
        ///
        /// <para>
        ///   If the flavor of the SFX is <c>SelfExtractorFlavor.ConsoleApplication</c>,
        ///   then the SFX starts a new process, using this string as the post-extract
        ///   command line.  The SFX waits for the process to exit.  The exit code of
        ///   the post-extract command line is returned as the exit code of the
        ///   command-line self-extractor exe. A non-zero exit code is typically used to
        ///   indicated a failure by the program. In the case of an SFX, a non-zero exit
        ///   code may indicate a failure during extraction, OR, it may indicate a
        ///   failure of the run-after-extract program if specified, OR, it may indicate
        ///   the run-after-extract program could not be fuond. There is no way to
        ///   distinguish these conditions from the calling shell, aside from parsing
        ///   the output of the SFX. If you have Quiet set to <c>true</c>, you may not
        ///   see error messages, if a problem occurs.
        /// </para>
        ///
        /// <para>
        ///   If the flavor of the SFX is
        ///   <c>SelfExtractorFlavor.WinFormsApplication</c>, then the SFX starts a new
        ///   process, using this string as the post-extract command line, and using the
        ///   extract directory as the working directory for the process. The SFX does
        ///   not wait for the command to complete, and does not check the exit code of
        ///   the program. If the run-after-extract program cannot be fuond, a message
        ///   box is displayed indicating that fact.
        /// </para>
        ///
        /// <para>
        ///   You can specify environment variables within this string, with a format like
        ///   <c>%NAME%</c>. The value of these variables will be expanded at the time
        ///   the SFX is run. Example: <c>%WINDIR%\system32\xcopy.exe</c> may expand at
        ///   runtime to <c>c:\Windows\System32\xcopy.exe</c>.
        /// </para>
        ///
        /// <para>
        ///   By combining this with the <c>RemoveUnpackedFilesAfterExecute</c>
        ///   flag, you can create an SFX that extracts itself, runs a file that
        ///   was extracted, then deletes all the files that were extracted. If
        ///   you want it to run "invisibly" then set <c>Flavor</c> to
        ///   <c>SelfExtractorFlavor.ConsoleApplication</c>, and set <c>Quiet</c>
        ///   to true.  The user running such an EXE will see a console window
        ///   appear, then disappear quickly.  You may also want to specify the
        ///   default extract location, with <c>DefaultExtractDirectory</c>.
        /// </para>
        ///
        /// <para>
        ///   If you set <c>Flavor</c> to
        ///   <c>SelfExtractorFlavor.WinFormsApplication</c>, and set <c>Quiet</c> to
        ///   true, then a GUI with progressbars is displayed, but it is
        ///   "non-interactive" - it accepts no input from the user.  Instead the SFX
        ///   just automatically unpacks and exits.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x170000D2 RID: 210
        // (get) Token: 0x0600031D RID: 797 RVA: 0x0001587C File Offset: 0x00013A7C
        // (set) Token: 0x0600031E RID: 798 RVA: 0x00015893 File Offset: 0x00013A93
        public string PostExtractCommandLine { get; set; }

        /// <summary>
        ///   The default extract directory the user will see when
        ///   running the self-extracting archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Passing null (or Nothing in VB) here will cause the Self Extractor to use
        ///   the the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal" />) for the default extract
        ///   location.
        /// </para>
        ///
        /// <para>
        ///   This is only a default location.  The actual extract location will be
        ///   settable on the command line when the SFX is executed.
        /// </para>
        ///
        /// <para>
        ///   You can specify environment variables within this string,
        ///   with <c>%NAME%</c>. The value of these variables will be
        ///   expanded at the time the SFX is run. Example:
        ///   <c>%USERPROFILE%\Documents\unpack</c> may expand at runtime to
        ///   <c>c:\users\melvin\Documents\unpack</c>.
        /// </para>
        /// </remarks>
        // Token: 0x170000D3 RID: 211
        // (get) Token: 0x0600031F RID: 799 RVA: 0x0001589C File Offset: 0x00013A9C
        // (set) Token: 0x06000320 RID: 800 RVA: 0x000158B3 File Offset: 0x00013AB3
        public string DefaultExtractDirectory { get; set; }

        /// <summary>
        ///   The name of an .ico file in the filesystem to use for the application icon
        ///   for the generated SFX.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Normally, DotNetZip will embed an "zipped folder" icon into the generated
        ///   SFX.  If you prefer to use a different icon, you can specify it here. It
        ///   should be a .ico file.  This file is passed as the <c>/win32icon</c>
        ///   option to the csc.exe compiler when constructing the SFX file.
        /// </para>
        /// </remarks>
        // Token: 0x170000D4 RID: 212
        // (get) Token: 0x06000321 RID: 801 RVA: 0x000158BC File Offset: 0x00013ABC
        // (set) Token: 0x06000322 RID: 802 RVA: 0x000158D3 File Offset: 0x00013AD3
        public string IconFile { get; set; }

        /// <summary>
        ///   Whether the ConsoleApplication SFX will be quiet during extraction.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This option affects the way the generated SFX runs. By default it is
        ///   false.  When you set it to true,...
        /// </para>
        ///
        /// <list type="table">
        ///   <listheader>
        ///     <term>Flavor</term>
        ///     <description>Behavior</description>
        ///   </listheader>
        ///
        /// <item>
        ///   <term><c>ConsoleApplication</c></term>
        ///   <description><para>no messages will be emitted during successful
        ///     operation.</para> <para> Double-clicking the SFX in Windows
        ///     Explorer or as an attachment in an email will cause a console
        ///     window to appear briefly, before it disappears. If you run the
        ///     ConsoleApplication SFX from the cmd.exe prompt, it runs as a
        ///     normal console app; by default, because it is quiet, it displays
        ///     no messages to the console.  If you pass the -v+ command line
        ///     argument to the Console SFX when you run it, you will get verbose
        ///     messages to the console. </para>
        ///   </description>
        /// </item>
        ///
        /// <item>
        ///   <term><c>WinFormsApplication</c></term>
        ///   <description>the SFX extracts automatically when the application
        ///        is launched, with no additional user input.
        ///   </description>
        /// </item>
        ///
        /// </list>
        ///
        /// <para>
        ///   When you set it to false,...
        /// </para>
        ///
        /// <list type="table">
        ///   <listheader>
        ///     <term>Flavor</term>
        ///     <description>Behavior</description>
        ///   </listheader>
        ///
        /// <item>
        ///   <term><c>ConsoleApplication</c></term>
        ///   <description><para>the extractor will emit a
        ///     message to the console for each entry extracted.</para>
        ///     <para>
        ///       When double-clicking to launch the SFX, the console window will
        ///       remain, and the SFX will emit a message for each file as it
        ///       extracts. The messages fly by quickly, they won't be easily
        ///       readable, unless the extracted files are fairly large.
        ///     </para>
        ///   </description>
        /// </item>
        ///
        /// <item>
        ///   <term><c>WinFormsApplication</c></term>
        ///   <description>the SFX presents a forms UI and allows the user to select
        ///     options before extracting.
        ///   </description>
        /// </item>
        ///
        /// </list>
        ///
        /// </remarks>
        // Token: 0x170000D5 RID: 213
        // (get) Token: 0x06000323 RID: 803 RVA: 0x000158DC File Offset: 0x00013ADC
        // (set) Token: 0x06000324 RID: 804 RVA: 0x000158F3 File Offset: 0x00013AF3
        public bool Quiet { get; set; }

        /// <summary>
        ///   Specify what the self-extractor will do when extracting an entry
        ///   would overwrite an existing file.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   The default behavvior is to Throw.
        /// </para>
        /// </remarks>
        // Token: 0x170000D6 RID: 214
        // (get) Token: 0x06000325 RID: 805 RVA: 0x000158FC File Offset: 0x00013AFC
        // (set) Token: 0x06000326 RID: 806 RVA: 0x00015913 File Offset: 0x00013B13
        public ExtractExistingFileAction ExtractExistingFile { get; set; }

        /// <summary>
        ///   Whether to remove the files that have been unpacked, after executing the
        ///   PostExtractCommandLine.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   If true, and if there is a <see cref="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
        ///   PostExtractCommandLine</see>, and if the command runs successfully,
        ///   then the files that the SFX unpacked will be removed, afterwards.  If
        ///   the command does not complete successfully (non-zero return code),
        ///   that is interpreted as a failure, and the extracted files will not be
        ///   removed.
        /// </para>
        ///
        /// <para>
        ///   Setting this flag, and setting <c>Flavor</c> to
        ///   <c>SelfExtractorFlavor.ConsoleApplication</c>, and setting <c>Quiet</c> to
        ///   true, results in an SFX that extracts itself, runs a file that was
        ///   extracted, then deletes all the files that were extracted, with no
        ///   intervention by the user.  You may also want to specify the default
        ///   extract location, with <c>DefaultExtractDirectory</c>.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x170000D7 RID: 215
        // (get) Token: 0x06000327 RID: 807 RVA: 0x0001591C File Offset: 0x00013B1C
        // (set) Token: 0x06000328 RID: 808 RVA: 0x00015933 File Offset: 0x00013B33
        public bool RemoveUnpackedFilesAfterExecute { get; set; }

        /// <summary>
        ///   The file version number to embed into the generated EXE. It will show up, for
        ///   example, during a mouseover in Windows Explorer.
        /// </summary>
        // Token: 0x170000D8 RID: 216
        // (get) Token: 0x06000329 RID: 809 RVA: 0x0001593C File Offset: 0x00013B3C
        // (set) Token: 0x0600032A RID: 810 RVA: 0x00015953 File Offset: 0x00013B53
        public Version FileVersion { get; set; }

        /// <summary>
        ///   The product version to embed into the generated EXE. It will show up, for
        ///   example, during a mouseover in Windows Explorer.
        /// </summary>
        ///
        /// <remarks>
        ///   You can use any arbitrary string, but a human-readable version number is
        ///   recommended. For example "v1.2 alpha" or "v4.2 RC2".  If you specify nothing,
        ///   then there is no product version embedded into the EXE.
        /// </remarks>
        // Token: 0x170000D9 RID: 217
        // (get) Token: 0x0600032B RID: 811 RVA: 0x0001595C File Offset: 0x00013B5C
        // (set) Token: 0x0600032C RID: 812 RVA: 0x00015973 File Offset: 0x00013B73
        public string ProductVersion { get; set; }

        /// <summary>
        ///   The copyright notice, if any, to embed into the generated EXE.
        /// </summary>
        ///
        /// <remarks>
        ///   It will show up, for example, while viewing properties of the file in
        ///   Windows Explorer.  You can use any arbitrary string, but typically you
        ///   want something like "Copyright © Dino Chiesa 2011".
        /// </remarks>
        // Token: 0x170000DA RID: 218
        // (get) Token: 0x0600032D RID: 813 RVA: 0x0001597C File Offset: 0x00013B7C
        // (set) Token: 0x0600032E RID: 814 RVA: 0x00015993 File Offset: 0x00013B93
        public string Copyright { get; set; }

        /// <summary>
        ///   The description to embed into the generated EXE.
        /// </summary>
        ///
        /// <remarks>
        ///   Use any arbitrary string.  This text will be displayed during a
        ///   mouseover in Windows Explorer.  If you specify nothing, then the string
        ///   "DotNetZip SFX Archive" is embedded into the EXE as the description.
        /// </remarks>
        // Token: 0x170000DB RID: 219
        // (get) Token: 0x0600032F RID: 815 RVA: 0x0001599C File Offset: 0x00013B9C
        // (set) Token: 0x06000330 RID: 816 RVA: 0x000159B3 File Offset: 0x00013BB3
        public string Description { get; set; }

        /// <summary>
        ///   The product name to embed into the generated EXE.
        /// </summary>
        ///
        /// <remarks>
        ///   Use any arbitrary string. This text will be displayed
        ///   while viewing properties of the EXE file in
        ///   Windows Explorer.
        /// </remarks>
        // Token: 0x170000DC RID: 220
        // (get) Token: 0x06000331 RID: 817 RVA: 0x000159BC File Offset: 0x00013BBC
        // (set) Token: 0x06000332 RID: 818 RVA: 0x000159D3 File Offset: 0x00013BD3
        public string ProductName { get; set; }

        /// <summary>
        ///   The title to display in the Window of a GUI SFX, while it extracts.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     By default the title show in the GUI window of a self-extractor
        ///     is "DotNetZip Self-extractor (http://DotNetZip.codeplex.com/)".
        ///     You can change that by setting this property before saving the SFX.
        ///   </para>
        ///
        ///   <para>
        ///     This property has an effect only when producing a Self-extractor
        ///     of flavor <c>SelfExtractorFlavor.WinFormsApplication</c>.
        ///   </para>
        /// </remarks>
        // Token: 0x170000DD RID: 221
        // (get) Token: 0x06000333 RID: 819 RVA: 0x000159DC File Offset: 0x00013BDC
        // (set) Token: 0x06000334 RID: 820 RVA: 0x000159F3 File Offset: 0x00013BF3
        public string SfxExeWindowTitle { get; set; }

        /// <summary>
        ///   Additional options for the csc.exe compiler, when producing the SFX
        ///   EXE.
        /// </summary>
        /// <exclude />
        // Token: 0x170000DE RID: 222
        // (get) Token: 0x06000335 RID: 821 RVA: 0x000159FC File Offset: 0x00013BFC
        // (set) Token: 0x06000336 RID: 822 RVA: 0x00015A13 File Offset: 0x00013C13
        public string AdditionalCompilerSwitches { get; set; }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   Delegate for the callback by which the application tells the
    ///   library the CompressionLevel to use for a file.
    /// </summary>
    ///
    /// <remarks>
    /// <para>
    ///   Using this callback, the application can, for example, specify that
    ///   previously-compressed files (.mp3, .png, .docx, etc) should use a
    ///   <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
    ///   on any other factor.
    /// </para>
    /// </remarks>
    /// <seealso cref="P:Ionic.Zip.ZipFile.SetCompression" />
    // Token: 0x0200002C RID: 44
    // (Invoke) Token: 0x06000155 RID: 341
    public delegate CompressionLevel SetCompressionCallback(string localFileName, string fileNameInArchive);
}


namespace Ionic.Zip
{
    /// <summary>
    /// Issued when errors occur saving a self-extracting archive.
    /// </summary>
    // Token: 0x02000022 RID: 34
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00008")]
    [Serializable]
    public class SfxGenerationException : ZipException
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x06000107 RID: 263 RVA: 0x00006B1B File Offset: 0x00004D1B
        public SfxGenerationException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x06000108 RID: 264 RVA: 0x00006B26 File Offset: 0x00004D26
        public SfxGenerationException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x06000109 RID: 265 RVA: 0x00006B32 File Offset: 0x00004D32
        protected SfxGenerationException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Collects general purpose utility methods.
    /// </summary>
    // Token: 0x02000024 RID: 36
    internal static class SharedUtilities
    {
        /// private null constructor
        // Token: 0x0600010E RID: 270 RVA: 0x00006B70 File Offset: 0x00004D70
        public static long GetFileLength(string fileName)
        {
            if (!File.Exists(fileName))
            {
                throw new FileNotFoundException(fileName);
            }
            long fileLength = 0L;
            FileShare fs = FileShare.ReadWrite;
            fs |= FileShare.Delete;
            using (FileStream s = File.Open(fileName, FileMode.Open, FileAccess.Read, fs))
            {
                fileLength = s.Length;
            }
            return fileLength;
        }

        // Token: 0x0600010F RID: 271 RVA: 0x00006BD8 File Offset: 0x00004DD8
        [Conditional("NETCF")]
        public static void Workaround_Ladybug318918(Stream s)
        {
            s.Flush();
        }

        // Token: 0x06000110 RID: 272 RVA: 0x00006BE4 File Offset: 0x00004DE4
        private static string SimplifyFwdSlashPath(string path)
        {
            if (path.StartsWith("./"))
            {
                path = path.Substring(2);
            }
            path = path.Replace("/./", "/");
            path = SharedUtilities.doubleDotRegex1.Replace(path, "$1$3");
            return path;
        }

        /// <summary>
        /// Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
        /// a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
        /// swapping backslashes for forward slashes.
        /// </summary>
        /// <param name="pathName">source path.</param>
        /// <returns>transformed path</returns>
        // Token: 0x06000111 RID: 273 RVA: 0x00006C38 File Offset: 0x00004E38
        public static string NormalizePathForUseInZipFile(string pathName)
        {
            string result;
            if (string.IsNullOrEmpty(pathName))
            {
                result = pathName;
            }
            else
            {
                if (pathName.Length >= 2 && pathName[1] == ':' && pathName[2] == '\\')
                {
                    pathName = pathName.Substring(3);
                }
                pathName = pathName.Replace('\\', '/');
                while (pathName.StartsWith("/"))
                {
                    pathName = pathName.Substring(1);
                }
                result = SharedUtilities.SimplifyFwdSlashPath(pathName);
            }
            return result;
        }

        // Token: 0x06000112 RID: 274 RVA: 0x00006CBC File Offset: 0x00004EBC
        internal static byte[] StringToByteArray(string value, Encoding encoding)
        {
            return encoding.GetBytes(value);
        }

        // Token: 0x06000113 RID: 275 RVA: 0x00006CD8 File Offset: 0x00004ED8
        internal static byte[] StringToByteArray(string value)
        {
            return SharedUtilities.StringToByteArray(value, SharedUtilities.ibm437);
        }

        // Token: 0x06000114 RID: 276 RVA: 0x00006CF8 File Offset: 0x00004EF8
        internal static string Utf8StringFromBuffer(byte[] buf)
        {
            return SharedUtilities.StringFromBuffer(buf, SharedUtilities.utf8);
        }

        // Token: 0x06000115 RID: 277 RVA: 0x00006D18 File Offset: 0x00004F18
        internal static string StringFromBuffer(byte[] buf, Encoding encoding)
        {
            return encoding.GetString(buf, 0, buf.Length);
        }

        // Token: 0x06000116 RID: 278 RVA: 0x00006D38 File Offset: 0x00004F38
        internal static int ReadSignature(Stream s)
        {
            int x = 0;
            try
            {
                x = SharedUtilities._ReadFourBytes(s, "n/a");
            }
            catch (BadReadException)
            {
            }
            return x;
        }

        // Token: 0x06000117 RID: 279 RVA: 0x00006D74 File Offset: 0x00004F74
        internal static int ReadEntrySignature(Stream s)
        {
            int x = 0;
            try
            {
                x = SharedUtilities._ReadFourBytes(s, "n/a");
                if (x == 134695760)
                {
                    s.Seek(12L, SeekOrigin.Current);
                    x = SharedUtilities._ReadFourBytes(s, "n/a");
                    if (x != 67324752)
                    {
                        s.Seek(8L, SeekOrigin.Current);
                        x = SharedUtilities._ReadFourBytes(s, "n/a");
                        if (x != 67324752)
                        {
                            s.Seek(-24L, SeekOrigin.Current);
                            x = SharedUtilities._ReadFourBytes(s, "n/a");
                        }
                    }
                }
            }
            catch (BadReadException)
            {
            }
            return x;
        }

        // Token: 0x06000118 RID: 280 RVA: 0x00006E20 File Offset: 0x00005020
        internal static int ReadInt(Stream s)
        {
            return SharedUtilities._ReadFourBytes(s, "Could not read block - no data!  (position 0x{0:X8})");
        }

        // Token: 0x06000119 RID: 281 RVA: 0x00006E40 File Offset: 0x00005040
        private static int _ReadFourBytes(Stream s, string message)
        {
            byte[] block = new byte[4];
            int i = s.Read(block, 0, block.Length);
            if (i != block.Length)
            {
                throw new BadReadException(string.Format(message, s.Position));
            }
            return (((int)block[3] * 256 + (int)block[2]) * 256 + (int)block[1]) * 256 + (int)block[0];
        }

        /// <summary>
        ///   Finds a signature in the zip stream. This is useful for finding
        ///   the end of a zip entry, for example, or the beginning of the next ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     Scans through 64k at a time.
        ///   </para>
        ///
        ///   <para>
        ///     If the method fails to find the requested signature, the stream Position
        ///     after completion of this method is unchanged. If the method succeeds in
        ///     finding the requested signature, the stream position after completion is
        ///     direct AFTER the signature found in the stream.
        ///   </para>
        /// </remarks>
        ///
        /// <param name="stream">The stream to search</param>
        /// <param name="SignatureToFind">The 4-byte signature to find</param>
        /// <returns>The number of bytes read</returns>
        // Token: 0x0600011A RID: 282 RVA: 0x00006EB0 File Offset: 0x000050B0
        internal static long FindSignature(Stream stream, int SignatureToFind)
        {
            long startingPosition = stream.Position;
            int BATCH_SIZE = 65536;
            byte[] targetBytes = new byte[]
            {
                (byte)(SignatureToFind >> 24),
                (byte)((SignatureToFind & 16711680) >> 16),
                (byte)((SignatureToFind & 65280) >> 8),
                (byte)(SignatureToFind & 255)
            };
            byte[] batch = new byte[BATCH_SIZE];
            bool success = false;
            do
            {
                int i = stream.Read(batch, 0, batch.Length);
                if (i == 0)
                {
                    break;
                }
                for (int j = 0; j < i; j++)
                {
                    if (batch[j] == targetBytes[3])
                    {
                        long curPosition = stream.Position;
                        stream.Seek((long)(j - i), SeekOrigin.Current);
                        int sig = SharedUtilities.ReadSignature(stream);
                        success = (sig == SignatureToFind);
                        if (success)
                        {
                            break;
                        }
                        stream.Seek(curPosition, SeekOrigin.Begin);
                    }
                }
            }
            while (!success);
            long result;
            if (!success)
            {
                stream.Seek(startingPosition, SeekOrigin.Begin);
                result = -1L;
            }
            else
            {
                long bytesRead = stream.Position - startingPosition - 4L;
                result = bytesRead;
            }
            return result;
        }

        // Token: 0x0600011B RID: 283 RVA: 0x00006FDC File Offset: 0x000051DC
        internal static DateTime AdjustTime_Reverse(DateTime time)
        {
            DateTime result;
            if (time.Kind == DateTimeKind.Utc)
            {
                result = time;
            }
            else
            {
                DateTime adjusted = time;
                if (DateTime.Now.IsDaylightSavingTime() && !time.IsDaylightSavingTime())
                {
                    adjusted = time - new TimeSpan(1, 0, 0);
                }
                else if (!DateTime.Now.IsDaylightSavingTime() && time.IsDaylightSavingTime())
                {
                    adjusted = time + new TimeSpan(1, 0, 0);
                }
                result = adjusted;
            }
            return result;
        }

        // Token: 0x0600011C RID: 284 RVA: 0x00007064 File Offset: 0x00005264
        internal static DateTime PackedToDateTime(int packedDateTime)
        {
            unchecked
            {
                DateTime result;
                if (packedDateTime == 65535 || packedDateTime == 0)
                {
                    result = new DateTime(1995, 1, 1, 0, 0, 0, 0);
                }
                else
                {
                    short packedTime = (short)(packedDateTime & 65535);
                    short packedDate = (short)(((long)packedDateTime & (long)((ulong)((long)-65536))) >> 16);
                    int year = 1980 + (((int)packedDate & 65024) >> 9);
                    int month = (packedDate & 480) >> 5;
                    int day = (int)(packedDate & 31);
                    int hour = ((int)packedTime & 63488) >> 11;
                    int minute = (packedTime & 2016) >> 5;
                    int second = (int)((packedTime & 31) * 2);
                    if (second >= 60)
                    {
                        minute++;
                        second = 0;
                    }
                    if (minute >= 60)
                    {
                        hour++;
                        minute = 0;
                    }
                    if (hour >= 24)
                    {
                        day++;
                        hour = 0;
                    }
                    DateTime d = DateTime.Now;
                    bool success = false;
                    try
                    {
                        d = new DateTime(year, month, day, hour, minute, second, 0);
                        success = true;
                    }
                    catch (ArgumentOutOfRangeException)
                    {
                        if (year == 1980 && (month == 0 || day == 0))
                        {
                            try
                            {
                                d = new DateTime(1980, 1, 1, hour, minute, second, 0);
                                success = true;
                            }
                            catch (ArgumentOutOfRangeException)
                            {
                                try
                                {
                                    d = new DateTime(1980, 1, 1, 0, 0, 0, 0);
                                    success = true;
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }
                        }
                        else
                        {
                            try
                            {
                                while (year < 1980)
                                {
                                    year++;
                                }
                                while (year > 2030)
                                {
                                    year--;
                                }
                                while (month < 1)
                                {
                                    month++;
                                }
                                while (month > 12)
                                {
                                    month--;
                                }
                                while (day < 1)
                                {
                                    day++;
                                }
                                while (day > 28)
                                {
                                    day--;
                                }
                                while (minute < 0)
                                {
                                    minute++;
                                }
                                while (minute > 59)
                                {
                                    minute--;
                                }
                                while (second < 0)
                                {
                                    second++;
                                }
                                while (second > 59)
                                {
                                    second--;
                                }
                                d = new DateTime(year, month, day, hour, minute, second, 0);
                                success = true;
                            }
                            catch (ArgumentOutOfRangeException)
                            {
                            }
                        }
                    }
                    if (!success)
                    {
                        string msg = string.Format("y({0}) m({1}) d({2}) h({3}) m({4}) s({5})", new object[]
                        {
                        year,
                        month,
                        day,
                        hour,
                        minute,
                        second
                        });
                        throw new ZipException(string.Format("Bad date/time format in the zip file. ({0})", msg));
                    }
                    d = DateTime.SpecifyKind(d, DateTimeKind.Local);
                    result = d;
                }
                return result;
            }
        }

        // Token: 0x0600011D RID: 285 RVA: 0x00007398 File Offset: 0x00005598
        internal static int DateTimeToPacked(DateTime time)
        {
            time = time.ToLocalTime();
            ushort packedDate = (ushort)((time.Day & 31) | (time.Month << 5 & 480) | (time.Year - 1980 << 9 & 65024));
            ushort packedTime = (ushort)((time.Second / 2 & 31) | (time.Minute << 5 & 2016) | (time.Hour << 11 & 63488));
            return (int)packedDate << 16 | (int)packedTime;
        }

        /// <summary>
        ///   Create a pseudo-random filename, suitable for use as a temporary
        ///   file, and open it.
        /// </summary>
        /// <remarks>
        /// <para>
        ///   The System.IO.Path.GetRandomFileName() method is not available on
        ///   the Compact Framework, so this library provides its own substitute
        ///   on NETCF.
        /// </para>
        /// <para>
        ///   This method produces a filename of the form
        ///   DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
        ///   chosen characters, and creates that file.
        /// </para>
        /// </remarks>
        // Token: 0x0600011E RID: 286 RVA: 0x00007420 File Offset: 0x00005620
        public static void CreateAndOpenUniqueTempFile(string dir, out Stream fs, out string filename)
        {
            for (int i = 0; i < 3; i++)
            {
                try
                {
                    filename = Path.Combine(dir, SharedUtilities.InternalGetTempFileName());
                    fs = new FileStream(filename, FileMode.CreateNew);
                    return;
                }
                catch (IOException)
                {
                    if (i == 2)
                    {
                        throw;
                    }
                }
            }
            throw new IOException();
        }

        // Token: 0x0600011F RID: 287 RVA: 0x00007484 File Offset: 0x00005684
        public static string InternalGetTempFileName()
        {
            return "DotNetZip-" + Path.GetRandomFileName().Substring(0, 8) + ".tmp";
        }

        /// <summary>
        /// Workitem 7889: handle ERROR_LOCK_VIOLATION during read
        /// </summary>
        /// <remarks>
        /// This could be gracefully handled with an extension attribute, but
        /// This assembly is built for .NET 2.0, so I cannot use them.
        /// </remarks>
        // Token: 0x06000120 RID: 288 RVA: 0x000074B4 File Offset: 0x000056B4
        internal static int ReadWithRetry(Stream s, byte[] buffer, int offset, int count, string FileName)
        {
            int i = 0;
            bool done = false;
            int retries = 0;
            do
            {
                try
                {
                    i = s.Read(buffer, offset, count);
                    done = true;
                }
                catch (IOException ioexc)
                {
                    uint hresult = SharedUtilities._HRForException(ioexc);
                    if (hresult != 2147942433u)
                    {
                        throw new IOException(string.Format("Cannot read file {0}", FileName), ioexc);
                    }
                    retries++;
                    if (retries > 10)
                    {
                        throw new IOException(string.Format("Cannot read file {0}, at offset 0x{1:X8} after 10 retries", FileName, offset), ioexc);
                    }
                    Thread.Sleep(250 + retries * 550);
                }
            }
            while (!done);
            return i;
        }

        // Token: 0x06000121 RID: 289 RVA: 0x00007590 File Offset: 0x00005790
        private static uint _HRForException(Exception ex1)
        {
            return (uint)Marshal.GetHRForException(ex1);
        }

        // Token: 0x040000B3 RID: 179
        private static Regex doubleDotRegex1 = new Regex("^(.*/)?([^/\\\\.]+/\\\\.\\\\./)(.+)$");

        // Token: 0x040000B4 RID: 180
        private static Encoding ibm437 = Encoding.GetEncoding("IBM437");

        // Token: 0x040000B5 RID: 181
        private static Encoding utf8 = Encoding.GetEncoding("UTF-8");
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   A stream that encrypts as it writes, or decrypts as it reads.  The
    ///   Crypto is AES in CTR (counter) mode, which is compatible with the AES
    ///   encryption employed by WinZip 12.0.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     The AES/CTR encryption protocol used by WinZip works like this:
    ///
    ///       - start with a counter, initialized to zero.
    ///
    ///       - to encrypt, take the data by 16-byte blocks. For each block:
    ///         - apply the transform to the counter
    ///         - increement the counter
    ///         - XOR the result of the transform with the plaintext to
    ///           get the ciphertext.
    ///         - compute the mac on the encrypted bytes
    ///       - when finished with all blocks, store the computed MAC.
    ///
    ///       - to decrypt, take the data by 16-byte blocks. For each block:
    ///         - compute the mac on the encrypted bytes,
    ///         - apply the transform to the counter
    ///         - increement the counter
    ///         - XOR the result of the transform with the ciphertext to
    ///           get the plaintext.
    ///       - when finished with all blocks, compare the computed MAC against
    ///         the stored MAC
    ///
    ///   </para>
    /// </remarks>
    // Token: 0x0200001C RID: 28
    internal class WinZipAesCipherStream : Stream
    {
        /// <summary>
        /// The constructor.
        /// </summary>
        /// <param name="s">The underlying stream</param>
        /// <param name="mode">To either encrypt or decrypt.</param>
        /// <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
        /// <param name="length">The maximum number of bytes to read from the stream.</param>
        // Token: 0x060000E2 RID: 226 RVA: 0x0000612A File Offset: 0x0000432A
        internal WinZipAesCipherStream(Stream s, WinZipAesCrypto cryptoParams, long length, CryptoMode mode) : this(s, cryptoParams, mode)
        {
            this._length = length;
        }

        // Token: 0x060000E3 RID: 227 RVA: 0x00006140 File Offset: 0x00004340
        internal WinZipAesCipherStream(Stream s, WinZipAesCrypto cryptoParams, CryptoMode mode)
        {
            this._params = cryptoParams;
            this._s = s;
            this._mode = mode;
            this._nonce = 1;
            if (this._params == null)
            {
                throw new BadPasswordException("Supply a password to use AES encryption.");
            }
            int keySizeInBits = this._params.KeyBytes.Length * 8;
            if (keySizeInBits != 256 && keySizeInBits != 128 && keySizeInBits != 192)
            {
                throw new ArgumentOutOfRangeException("keysize", "size of key must be 128, 192, or 256");
            }
            this._mac = new HMACSHA1(this._params.MacIv);
            this._aesCipher = new RijndaelManaged();
            this._aesCipher.BlockSize = 128;
            this._aesCipher.KeySize = keySizeInBits;
            this._aesCipher.Mode = CipherMode.ECB;
            this._aesCipher.Padding = PaddingMode.None;
            byte[] iv = new byte[16];
            this._xform = this._aesCipher.CreateEncryptor(this._params.KeyBytes, iv);
            if (this._mode == CryptoMode.Encrypt)
            {
                this._iobuf = new byte[2048];
                this._PendingWriteBlock = new byte[16];
            }
        }

        // Token: 0x060000E4 RID: 228 RVA: 0x000062A0 File Offset: 0x000044A0
        private void XorInPlace(byte[] buffer, int offset, int count)
        {
            for (int i = 0; i < count; i++)
            {
                buffer[offset + i] = (byte)(this.counterOut[i] ^ buffer[offset + i]);
            }
        }

        // Token: 0x060000E5 RID: 229 RVA: 0x000062D4 File Offset: 0x000044D4
        private void WriteTransformOneBlock(byte[] buffer, int offset)
        {
            Array.Copy(BitConverter.GetBytes(this._nonce++), 0, this.counter, 0, 4);
            this._xform.TransformBlock(this.counter, 0, 16, this.counterOut, 0);
            this.XorInPlace(buffer, offset, 16);
            this._mac.TransformBlock(buffer, offset, 16, null, 0);
        }

        // Token: 0x060000E6 RID: 230 RVA: 0x00006340 File Offset: 0x00004540
        private void WriteTransformBlocks(byte[] buffer, int offset, int count)
        {
            int posn = offset;
            int last = count + offset;
            while (posn < buffer.Length && posn < last)
            {
                this.WriteTransformOneBlock(buffer, posn);
                posn += 16;
            }
        }

        // Token: 0x060000E7 RID: 231 RVA: 0x00006378 File Offset: 0x00004578
        private void WriteTransformFinalBlock()
        {
            if (this._pendingCount == 0)
            {
                throw new InvalidOperationException("No bytes available.");
            }
            if (this._finalBlock)
            {
                throw new InvalidOperationException("The final block has already been transformed.");
            }
            Array.Copy(BitConverter.GetBytes(this._nonce++), 0, this.counter, 0, 4);
            this.counterOut = this._xform.TransformFinalBlock(this.counter, 0, 16);
            this.XorInPlace(this._PendingWriteBlock, 0, this._pendingCount);
            this._mac.TransformFinalBlock(this._PendingWriteBlock, 0, this._pendingCount);
            this._finalBlock = true;
        }

        // Token: 0x060000E8 RID: 232 RVA: 0x0000642C File Offset: 0x0000462C
        private int ReadTransformOneBlock(byte[] buffer, int offset, int last)
        {
            if (this._finalBlock)
            {
                throw new NotSupportedException();
            }
            int bytesRemaining = last - offset;
            int bytesToRead = (bytesRemaining > 16) ? 16 : bytesRemaining;
            Array.Copy(BitConverter.GetBytes(this._nonce++), 0, this.counter, 0, 4);
            if (bytesToRead == bytesRemaining && this._length > 0L && this._totalBytesXferred + (long)last == this._length)
            {
                this._mac.TransformFinalBlock(buffer, offset, bytesToRead);
                this.counterOut = this._xform.TransformFinalBlock(this.counter, 0, 16);
                this._finalBlock = true;
            }
            else
            {
                this._mac.TransformBlock(buffer, offset, bytesToRead, null, 0);
                this._xform.TransformBlock(this.counter, 0, 16, this.counterOut, 0);
            }
            this.XorInPlace(buffer, offset, bytesToRead);
            return bytesToRead;
        }

        // Token: 0x060000E9 RID: 233 RVA: 0x00006520 File Offset: 0x00004720
        private void ReadTransformBlocks(byte[] buffer, int offset, int count)
        {
            int posn = offset;
            int last = count + offset;
            while (posn < buffer.Length && posn < last)
            {
                int i = this.ReadTransformOneBlock(buffer, posn, last);
                posn += i;
            }
        }

        // Token: 0x060000EA RID: 234 RVA: 0x00006558 File Offset: 0x00004758
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this._mode == CryptoMode.Encrypt)
            {
                throw new NotSupportedException();
            }
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (offset < 0)
            {
                throw new ArgumentOutOfRangeException("offset", "Must not be less than zero.");
            }
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count", "Must not be less than zero.");
            }
            if (buffer.Length < offset + count)
            {
                throw new ArgumentException("The buffer is too small");
            }
            int bytesToRead = count;
            int result;
            if (this._totalBytesXferred >= this._length)
            {
                result = 0;
            }
            else
            {
                long bytesRemaining = this._length - this._totalBytesXferred;
                if (bytesRemaining < (long)count)
                {
                    bytesToRead = (int)bytesRemaining;
                }
                int i = this._s.Read(buffer, offset, bytesToRead);
                this.ReadTransformBlocks(buffer, offset, bytesToRead);
                this._totalBytesXferred += (long)i;
                result = i;
            }
            return result;
        }

        /// <summary>
        /// Returns the final HMAC-SHA1-80 for the data that was encrypted.
        /// </summary>
        // Token: 0x1700004F RID: 79
        // (get) Token: 0x060000EB RID: 235 RVA: 0x00006654 File Offset: 0x00004854
        public byte[] FinalAuthentication
        {
            get
            {
                if (!this._finalBlock)
                {
                    if (this._totalBytesXferred != 0L)
                    {
                        throw new BadStateException("The final hash has not been computed.");
                    }
                    byte[] b = new byte[0];
                    this._mac.ComputeHash(b);
                }
                byte[] macBytes10 = new byte[10];
                Array.Copy(this._mac.Hash, 0, macBytes10, 0, 10);
                return macBytes10;
            }
        }

        // Token: 0x060000EC RID: 236 RVA: 0x000066C0 File Offset: 0x000048C0
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this._finalBlock)
            {
                throw new InvalidOperationException("The final block has already been transformed.");
            }
            if (this._mode == CryptoMode.Decrypt)
            {
                throw new NotSupportedException();
            }
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (offset < 0)
            {
                throw new ArgumentOutOfRangeException("offset", "Must not be less than zero.");
            }
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException("count", "Must not be less than zero.");
            }
            if (buffer.Length < offset + count)
            {
                throw new ArgumentException("The offset and count are too large");
            }
            if (count != 0)
            {
                if (count + this._pendingCount <= 16)
                {
                    Buffer.BlockCopy(buffer, offset, this._PendingWriteBlock, this._pendingCount, count);
                    this._pendingCount += count;
                }
                else
                {
                    int bytesRemaining = count;
                    int curOffset = offset;
                    if (this._pendingCount != 0)
                    {
                        int fillCount = 16 - this._pendingCount;
                        if (fillCount > 0)
                        {
                            Buffer.BlockCopy(buffer, offset, this._PendingWriteBlock, this._pendingCount, fillCount);
                            bytesRemaining -= fillCount;
                            curOffset += fillCount;
                        }
                        this.WriteTransformOneBlock(this._PendingWriteBlock, 0);
                        this._s.Write(this._PendingWriteBlock, 0, 16);
                        this._totalBytesXferred += 16L;
                        this._pendingCount = 0;
                    }
                    int blocksToXform = (bytesRemaining - 1) / 16;
                    this._pendingCount = bytesRemaining - blocksToXform * 16;
                    Buffer.BlockCopy(buffer, curOffset + bytesRemaining - this._pendingCount, this._PendingWriteBlock, 0, this._pendingCount);
                    bytesRemaining -= this._pendingCount;
                    this._totalBytesXferred += (long)bytesRemaining;
                    if (blocksToXform > 0)
                    {
                        do
                        {
                            int c = this._iobuf.Length;
                            if (c > bytesRemaining)
                            {
                                c = bytesRemaining;
                            }
                            Buffer.BlockCopy(buffer, curOffset, this._iobuf, 0, c);
                            this.WriteTransformBlocks(this._iobuf, 0, c);
                            this._s.Write(this._iobuf, 0, c);
                            bytesRemaining -= c;
                            curOffset += c;
                        }
                        while (bytesRemaining > 0);
                    }
                }
            }
        }

        /// <summary>
        ///   Close the stream.
        /// </summary>
        // Token: 0x060000ED RID: 237 RVA: 0x00006900 File Offset: 0x00004B00
        public override void Close()
        {
            if (this._pendingCount > 0)
            {
                this.WriteTransformFinalBlock();
                this._s.Write(this._PendingWriteBlock, 0, this._pendingCount);
                this._totalBytesXferred += (long)this._pendingCount;
                this._pendingCount = 0;
            }
            this._s.Close();
        }

        /// <summary>
        /// Returns true if the stream can be read.
        /// </summary>
        // Token: 0x17000050 RID: 80
        // (get) Token: 0x060000EE RID: 238 RVA: 0x00006968 File Offset: 0x00004B68
        public override bool CanRead
        {
            get
            {
                return this._mode == CryptoMode.Decrypt;
            }
        }

        /// <summary>
        /// Always returns false.
        /// </summary>
        // Token: 0x17000051 RID: 81
        // (get) Token: 0x060000EF RID: 239 RVA: 0x0000698C File Offset: 0x00004B8C
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Returns true if the CryptoMode is Encrypt.
        /// </summary>
        // Token: 0x17000052 RID: 82
        // (get) Token: 0x060000F0 RID: 240 RVA: 0x000069A0 File Offset: 0x00004BA0
        public override bool CanWrite
        {
            get
            {
                return this._mode == CryptoMode.Encrypt;
            }
        }

        /// <summary>
        /// Flush the content in the stream.
        /// </summary>
        // Token: 0x060000F1 RID: 241 RVA: 0x000069BB File Offset: 0x00004BBB
        public override void Flush()
        {
            this._s.Flush();
        }

        /// <summary>
        /// Getting this property throws a NotImplementedException.
        /// </summary>
        // Token: 0x17000053 RID: 83
        // (get) Token: 0x060000F2 RID: 242 RVA: 0x000069CA File Offset: 0x00004BCA
        public override long Length
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Getting or Setting this property throws a NotImplementedException.
        /// </summary>
        // Token: 0x17000054 RID: 84
        // (get) Token: 0x060000F3 RID: 243 RVA: 0x000069D2 File Offset: 0x00004BD2
        // (set) Token: 0x060000F4 RID: 244 RVA: 0x000069DA File Offset: 0x00004BDA
        public override long Position
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// This method throws a NotImplementedException.
        /// </summary>
        // Token: 0x060000F5 RID: 245 RVA: 0x000069E2 File Offset: 0x00004BE2
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method throws a NotImplementedException.
        /// </summary>
        // Token: 0x060000F6 RID: 246 RVA: 0x000069EA File Offset: 0x00004BEA
        public override void SetLength(long value)
        {
            throw new NotImplementedException();
        }

        // Token: 0x060000F7 RID: 247 RVA: 0x000069F4 File Offset: 0x00004BF4
        [Conditional("Trace")]
        private void TraceOutput(string format, params object[] varParams)
        {
            lock (this._outputLock)
            {
                int tid = Thread.CurrentThread.GetHashCode();
                Console.ForegroundColor = tid % 8 + ConsoleColor.DarkGray;
                Console.Write("{0:000} WZACS ", tid);
                Console.WriteLine(format, varParams);
                Console.ResetColor();
            }
        }

        // Token: 0x04000095 RID: 149
        private const int BLOCK_SIZE_IN_BYTES = 16;

        // Token: 0x04000096 RID: 150
        private WinZipAesCrypto _params;

        // Token: 0x04000097 RID: 151
        private Stream _s;

        // Token: 0x04000098 RID: 152
        private CryptoMode _mode;

        // Token: 0x04000099 RID: 153
        private int _nonce;

        // Token: 0x0400009A RID: 154
        private bool _finalBlock;

        // Token: 0x0400009B RID: 155
        internal HMACSHA1 _mac;

        // Token: 0x0400009C RID: 156
        internal RijndaelManaged _aesCipher;

        // Token: 0x0400009D RID: 157
        internal ICryptoTransform _xform;

        // Token: 0x0400009E RID: 158
        private byte[] counter = new byte[16];

        // Token: 0x0400009F RID: 159
        private byte[] counterOut = new byte[16];

        // Token: 0x040000A0 RID: 160
        private long _length;

        // Token: 0x040000A1 RID: 161
        private long _totalBytesXferred;

        // Token: 0x040000A2 RID: 162
        private byte[] _PendingWriteBlock;

        // Token: 0x040000A3 RID: 163
        private int _pendingCount;

        // Token: 0x040000A4 RID: 164
        private byte[] _iobuf;

        // Token: 0x040000A5 RID: 165
        private object _outputLock = new object();
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   This is a helper class supporting WinZip AES encryption.
    ///   This class is intended for use only by the DotNetZip library.
    /// </summary>
    ///
    /// <remarks>
    ///   Most uses of the DotNetZip library will not involve direct calls into
    ///   the WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is
    ///   instantiated and used by the ZipEntry() class when WinZip AES
    ///   encryption or decryption on an entry is employed.
    /// </remarks>
    // Token: 0x0200001B RID: 27
    internal class WinZipAesCrypto
    {
        // Token: 0x060000D5 RID: 213 RVA: 0x00005DB4 File Offset: 0x00003FB4
        private WinZipAesCrypto(string password, int KeyStrengthInBits)
        {
            this._Password = password;
            this._KeyStrengthInBits = KeyStrengthInBits;
        }

        // Token: 0x060000D6 RID: 214 RVA: 0x00005DD8 File Offset: 0x00003FD8
        public static WinZipAesCrypto Generate(string password, int KeyStrengthInBits)
        {
            WinZipAesCrypto c = new WinZipAesCrypto(password, KeyStrengthInBits);
            int saltSizeInBytes = c._KeyStrengthInBytes / 2;
            c._Salt = new byte[saltSizeInBytes];
            Random rnd = new Random();
            rnd.NextBytes(c._Salt);
            return c;
        }

        // Token: 0x060000D7 RID: 215 RVA: 0x00005E1C File Offset: 0x0000401C
        public static WinZipAesCrypto ReadFromStream(string password, int KeyStrengthInBits, Stream s)
        {
            WinZipAesCrypto c = new WinZipAesCrypto(password, KeyStrengthInBits);
            int saltSizeInBytes = c._KeyStrengthInBytes / 2;
            c._Salt = new byte[saltSizeInBytes];
            c._providedPv = new byte[2];
            s.Read(c._Salt, 0, c._Salt.Length);
            s.Read(c._providedPv, 0, c._providedPv.Length);
            c.PasswordVerificationStored = (short)((int)c._providedPv[0] + (int)c._providedPv[1] * 256);
            if (password != null)
            {
                c.PasswordVerificationGenerated = (short)((int)c.GeneratedPV[0] + (int)c.GeneratedPV[1] * 256);
                if (c.PasswordVerificationGenerated != c.PasswordVerificationStored)
                {
                    throw new BadPasswordException("bad password");
                }
            }
            return c;
        }

        // Token: 0x17000048 RID: 72
        // (get) Token: 0x060000D8 RID: 216 RVA: 0x00005EE8 File Offset: 0x000040E8
        public byte[] GeneratedPV
        {
            get
            {
                if (!this._cryptoGenerated)
                {
                    this._GenerateCryptoBytes();
                }
                return this._generatedPv;
            }
        }

        // Token: 0x17000049 RID: 73
        // (get) Token: 0x060000D9 RID: 217 RVA: 0x00005F14 File Offset: 0x00004114
        public byte[] Salt
        {
            get
            {
                return this._Salt;
            }
        }

        // Token: 0x1700004A RID: 74
        // (get) Token: 0x060000DA RID: 218 RVA: 0x00005F2C File Offset: 0x0000412C
        private int _KeyStrengthInBytes
        {
            get
            {
                return this._KeyStrengthInBits / 8;
            }
        }

        // Token: 0x1700004B RID: 75
        // (get) Token: 0x060000DB RID: 219 RVA: 0x00005F48 File Offset: 0x00004148
        public int SizeOfEncryptionMetadata
        {
            get
            {
                return this._KeyStrengthInBytes / 2 + 10 + 2;
            }
        }

        // Token: 0x1700004C RID: 76
        // (get) Token: 0x060000DD RID: 221 RVA: 0x00005FC4 File Offset: 0x000041C4
        // (set) Token: 0x060000DC RID: 220 RVA: 0x00005F68 File Offset: 0x00004168
        public string Password
        {
            private get
            {
                return this._Password;
            }
            set
            {
                this._Password = value;
                if (this._Password != null)
                {
                    this.PasswordVerificationGenerated = (short)((int)this.GeneratedPV[0] + (int)this.GeneratedPV[1] * 256);
                    if (this.PasswordVerificationGenerated != this.PasswordVerificationStored)
                    {
                        throw new BadPasswordException();
                    }
                }
            }
        }

        // Token: 0x060000DE RID: 222 RVA: 0x00005FDC File Offset: 0x000041DC
        private void _GenerateCryptoBytes()
        {
            Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes(this._Password, this.Salt, this.Rfc2898KeygenIterations);
            this._keyBytes = rfc2898.GetBytes(this._KeyStrengthInBytes);
            this._MacInitializationVector = rfc2898.GetBytes(this._KeyStrengthInBytes);
            this._generatedPv = rfc2898.GetBytes(2);
            this._cryptoGenerated = true;
        }

        // Token: 0x1700004D RID: 77
        // (get) Token: 0x060000DF RID: 223 RVA: 0x0000603C File Offset: 0x0000423C
        public byte[] KeyBytes
        {
            get
            {
                if (!this._cryptoGenerated)
                {
                    this._GenerateCryptoBytes();
                }
                return this._keyBytes;
            }
        }

        // Token: 0x1700004E RID: 78
        // (get) Token: 0x060000E0 RID: 224 RVA: 0x00006068 File Offset: 0x00004268
        public byte[] MacIv
        {
            get
            {
                if (!this._cryptoGenerated)
                {
                    this._GenerateCryptoBytes();
                }
                return this._MacInitializationVector;
            }
        }

        // Token: 0x060000E1 RID: 225 RVA: 0x00006094 File Offset: 0x00004294
        public void ReadAndVerifyMac(Stream s)
        {
            bool invalid = false;
            this._StoredMac = new byte[10];
            s.Read(this._StoredMac, 0, this._StoredMac.Length);
            if (this._StoredMac.Length != this.CalculatedMac.Length)
            {
                invalid = true;
            }
            if (!invalid)
            {
                for (int i = 0; i < this._StoredMac.Length; i++)
                {
                    if (this._StoredMac[i] != this.CalculatedMac[i])
                    {
                        invalid = true;
                    }
                }
            }
            if (invalid)
            {
                throw new BadStateException("The MAC does not match.");
            }
        }

        // Token: 0x04000088 RID: 136
        internal byte[] _Salt;

        // Token: 0x04000089 RID: 137
        internal byte[] _providedPv;

        // Token: 0x0400008A RID: 138
        internal byte[] _generatedPv;

        // Token: 0x0400008B RID: 139
        internal int _KeyStrengthInBits;

        // Token: 0x0400008C RID: 140
        private byte[] _MacInitializationVector;

        // Token: 0x0400008D RID: 141
        private byte[] _StoredMac;

        // Token: 0x0400008E RID: 142
        private byte[] _keyBytes;

        // Token: 0x0400008F RID: 143
        private short PasswordVerificationStored;

        // Token: 0x04000090 RID: 144
        private short PasswordVerificationGenerated;

        // Token: 0x04000091 RID: 145
        private int Rfc2898KeygenIterations = 1000;

        // Token: 0x04000092 RID: 146
        private string _Password;

        // Token: 0x04000093 RID: 147
        private bool _cryptoGenerated;

        // Token: 0x04000094 RID: 148
        public byte[] CalculatedMac;
    }
}

namespace Ionic.Zip
{
    /// <summary>
    ///   Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
    /// </summary>
    ///
    /// <param name="entryName">The name of the entry that must be written.</param>
    /// <param name="stream">The stream to which the entry data should be written.</param>
    ///
    /// <remarks>
    ///   When you add an entry and specify a <c>WriteDelegate</c>, via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />, the application
    ///   code provides the logic that writes the entry data directly into the zip file.
    /// </remarks>
    ///
    /// <example>
    ///
    /// This example shows how to define a WriteDelegate that obtains a DataSet, and then
    /// writes the XML for the DataSet into the zip archive.  There's no need to
    /// save the XML to a disk file first.
    ///
    /// <code lang="C#">
    /// private void WriteEntry (String filename, Stream output)
    /// {
    ///     DataSet ds1 = ObtainDataSet();
    ///     ds1.WriteXml(output);
    /// }
    ///
    /// private void Run()
    /// {
    ///     using (var zip = new ZipFile())
    ///     {
    ///         zip.AddEntry(zipEntryName, WriteEntry);
    ///         zip.Save(zipFileName);
    ///     }
    /// }
    /// </code>
    ///
    /// <code lang="vb">
    /// Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
    ///     DataSet ds1 = ObtainDataSet()
    ///     ds1.WriteXml(stream)
    /// End Sub
    ///
    /// Public Sub Run()
    ///     Using zip = New ZipFile
    ///         zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
    ///         zip.Save(zipFileName)
    ///     End Using
    /// End Sub
    /// </code>
    /// </example>
    /// <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />
    // Token: 0x02000029 RID: 41
    // (Invoke) Token: 0x06000149 RID: 329
    public delegate void WriteDelegate(string entryName, Stream stream);
}

namespace Ionic.Zip
{
    /// <summary>
    ///   Options for using ZIP64 extensions when saving zip archives.
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    ///   Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
    ///   specification from PKWARE</see> allowed for 32-bit quantities for the
    ///   compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
    ///   for specifying the length of the zip archive itself, and a maximum of 65535
    ///   entries.  These limits are now regularly exceeded in many backup and archival
    ///   scenarios.  Recently, PKWare added extensions to the original zip spec, called
    ///   "ZIP64 extensions", to raise those limitations.  This property governs whether
    ///   DotNetZip will use those extensions when writing zip archives. The use of
    ///   these extensions is optional and explicit in DotNetZip because, despite the
    ///   status of ZIP64 as a bona fide standard, many other zip tools and libraries do
    ///   not support ZIP64, and therefore a zip file with ZIP64 extensions may be
    ///   unreadable by some of those other tools.
    /// </para>
    ///
    /// <para>
    ///   Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always" /> to always use ZIP64
    ///   extensions when saving, regardless of whether your zip archive needs it.
    ///   Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
    ///   for this flag, you will get a ZIP64 archive, though the archive does not need
    ///   to use ZIP64 because none of the original zip limits had been exceeded.
    /// </para>
    ///
    /// <para>
    ///   Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" /> to tell the DotNetZip
    ///   library to never use ZIP64 extensions.  This is useful for maximum
    ///   compatibility and interoperability, at the expense of the capability of
    ///   handling large files or large archives.  NB: Windows Explorer in Windows XP
    ///   and Windows Vista cannot currently extract files from a zip64 archive, so if
    ///   you want to guarantee that a zip archive produced by this library will work in
    ///   Windows Explorer, use <c>Never</c>. If you set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" />, and your application creates a zip that would
    ///   exceed one of the Zip limits, the library will throw an exception while saving
    ///   the zip file.
    /// </para>
    ///
    /// <para>
    ///   Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> to tell the
    ///   DotNetZip library to use the ZIP64 extensions when required by the
    ///   entry. After the file is compressed, the original and compressed sizes are
    ///   checked, and if they exceed the limits described above, then zip64 can be
    ///   used. That is the general idea, but there is an additional wrinkle when saving
    ///   to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
    ///   <c>Console.Out</c>.  When using non-seekable streams for output, the entry
    ///   header - which indicates whether zip64 is in use - is emitted before it is
    ///   known if zip64 is necessary.  It is only after all entries have been saved
    ///   that it can be known if ZIP64 will be required.  On seekable output streams,
    ///   after saving all entries, the library can seek backward and re-emit the zip
    ///   file header to be consistent with the actual ZIP64 requirement.  But using a
    ///   non-seekable output stream, the library cannot seek backward, so the header
    ///   can never be changed. In other words, the archive's use of ZIP64 extensions is
    ///   not alterable after the header is emitted.  Therefore, when saving to
    ///   non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is the same
    ///   as using <see cref="F:Ionic.Zip.Zip64Option.Always" />: it will always produce a zip
    ///   archive that uses ZIP64 extensions.
    /// </para>
    ///
    /// </remarks>
    // Token: 0x0200003B RID: 59
    public enum Zip64Option
    {
        /// <summary>
        /// The default behavior, which is "Never".
        /// (For COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x04000189 RID: 393
        Default,
        /// <summary>
        /// Do not use ZIP64 extensions when writing zip archives.
        /// (For COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x0400018A RID: 394
        Never = 0,
        /// <summary>
        /// Use ZIP64 extensions when writing zip archives, as necessary.
        /// For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
        /// exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
        /// (For COM clients, this is a 1.)
        /// </summary>
        // Token: 0x0400018B RID: 395
        AsNecessary,
        /// <summary>
        /// Always use ZIP64 extensions when writing zip archives, even when unnecessary.
        /// (For COM clients, this is a 2.)
        /// </summary>
        // Token: 0x0400018C RID: 396
        Always
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   A Stream for reading and concurrently decrypting data from a zip file,
    ///   or for writing and concurrently encrypting data to a zip file.
    /// </summary>
    // Token: 0x02000028 RID: 40
    internal class ZipCipherStream : Stream
    {
        /// <summary>  The constructor. </summary>
        /// <param name="s">The underlying stream</param>
        /// <param name="mode">To either encrypt or decrypt.</param>
        /// <param name="cipher">The pre-initialized ZipCrypto object.</param>
        // Token: 0x0600013C RID: 316 RVA: 0x00007B73 File Offset: 0x00005D73
        public ZipCipherStream(Stream s, ZipCrypto cipher, CryptoMode mode)
        {
            this._cipher = cipher;
            this._s = s;
            this._mode = mode;
        }

        // Token: 0x0600013D RID: 317 RVA: 0x00007B94 File Offset: 0x00005D94
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this._mode == CryptoMode.Encrypt)
            {
                throw new NotSupportedException("This stream does not encrypt via Read()");
            }
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            byte[] db = new byte[count];
            int i = this._s.Read(db, 0, count);
            byte[] decrypted = this._cipher.DecryptMessage(db, i);
            for (int j = 0; j < i; j++)
            {
                buffer[offset + j] = decrypted[j];
            }
            return i;
        }

        // Token: 0x0600013E RID: 318 RVA: 0x00007C20 File Offset: 0x00005E20
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this._mode == CryptoMode.Decrypt)
            {
                throw new NotSupportedException("This stream does not Decrypt via Write()");
            }
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }
            if (count != 0)
            {
                byte[] plaintext;
                if (offset != 0)
                {
                    plaintext = new byte[count];
                    for (int i = 0; i < count; i++)
                    {
                        plaintext[i] = buffer[offset + i];
                    }
                }
                else
                {
                    plaintext = buffer;
                }
                byte[] encrypted = this._cipher.EncryptMessage(plaintext, count);
                this._s.Write(encrypted, 0, encrypted.Length);
            }
        }

        // Token: 0x1700005F RID: 95
        // (get) Token: 0x0600013F RID: 319 RVA: 0x00007CBC File Offset: 0x00005EBC
        public override bool CanRead
        {
            get
            {
                return this._mode == CryptoMode.Decrypt;
            }
        }

        // Token: 0x17000060 RID: 96
        // (get) Token: 0x06000140 RID: 320 RVA: 0x00007CD8 File Offset: 0x00005ED8
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        // Token: 0x17000061 RID: 97
        // (get) Token: 0x06000141 RID: 321 RVA: 0x00007CEC File Offset: 0x00005EEC
        public override bool CanWrite
        {
            get
            {
                return this._mode == CryptoMode.Encrypt;
            }
        }

        // Token: 0x06000142 RID: 322 RVA: 0x00007D07 File Offset: 0x00005F07
        public override void Flush()
        {
        }

        // Token: 0x17000062 RID: 98
        // (get) Token: 0x06000143 RID: 323 RVA: 0x00007D0A File Offset: 0x00005F0A
        public override long Length
        {
            get
            {
                throw new NotSupportedException();
            }
        }

        // Token: 0x17000063 RID: 99
        // (get) Token: 0x06000144 RID: 324 RVA: 0x00007D12 File Offset: 0x00005F12
        // (set) Token: 0x06000145 RID: 325 RVA: 0x00007D1A File Offset: 0x00005F1A
        public override long Position
        {
            get
            {
                throw new NotSupportedException();
            }
            set
            {
                throw new NotSupportedException();
            }
        }

        // Token: 0x06000146 RID: 326 RVA: 0x00007D22 File Offset: 0x00005F22
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        // Token: 0x06000147 RID: 327 RVA: 0x00007D2A File Offset: 0x00005F2A
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        // Token: 0x040000BF RID: 191
        private ZipCrypto _cipher;

        // Token: 0x040000C0 RID: 192
        private Stream _s;

        // Token: 0x040000C1 RID: 193
        private CryptoMode _mode;
    }
}


namespace Ionic.Zip
{
    // Token: 0x0200001D RID: 29
    internal static class ZipConstants
    {
        // Token: 0x040000A6 RID: 166
        public const uint PackedToRemovableMedia = 808471376u;

        // Token: 0x040000A7 RID: 167
        public const uint Zip64EndOfCentralDirectoryRecordSignature = 101075792u;

        // Token: 0x040000A8 RID: 168
        public const uint Zip64EndOfCentralDirectoryLocatorSignature = 117853008u;

        // Token: 0x040000A9 RID: 169
        public const uint EndOfCentralDirectorySignature = 101010256u;

        // Token: 0x040000AA RID: 170
        public const int ZipEntrySignature = 67324752;

        // Token: 0x040000AB RID: 171
        public const int ZipEntryDataDescriptorSignature = 134695760;

        // Token: 0x040000AC RID: 172
        public const int SplitArchiveSignature = 134695760;

        // Token: 0x040000AD RID: 173
        public const int ZipDirEntrySignature = 33639248;

        // Token: 0x040000AE RID: 174
        public const int AesKeySize = 192;

        // Token: 0x040000AF RID: 175
        public const int AesBlockSize = 128;

        // Token: 0x040000B0 RID: 176
        public const ushort AesAlgId128 = 26126;

        // Token: 0x040000B1 RID: 177
        public const ushort AesAlgId192 = 26127;

        // Token: 0x040000B2 RID: 178
        public const ushort AesAlgId256 = 26128;
    }
}


namespace Ionic.Zip
{
    // Token: 0x02000004 RID: 4
    internal class ZipContainer
    {
        // Token: 0x0600003A RID: 58 RVA: 0x00002C2E File Offset: 0x00000E2E
        public ZipContainer(object o)
        {
            this._zf = (o as ZipFile);
            this._zos = (o as ZipOutputStream);
            this._zis = (o as ZipInputStream);
        }

        // Token: 0x1700001A RID: 26
        // (get) Token: 0x0600003B RID: 59 RVA: 0x00002C60 File Offset: 0x00000E60
        public ZipFile ZipFile
        {
            get
            {
                return this._zf;
            }
        }

        // Token: 0x1700001B RID: 27
        // (get) Token: 0x0600003C RID: 60 RVA: 0x00002C78 File Offset: 0x00000E78
        public ZipOutputStream ZipOutputStream
        {
            get
            {
                return this._zos;
            }
        }

        // Token: 0x1700001C RID: 28
        // (get) Token: 0x0600003D RID: 61 RVA: 0x00002C90 File Offset: 0x00000E90
        public string Name
        {
            get
            {
                string name;
                if (this._zf != null)
                {
                    name = this._zf.Name;
                }
                else
                {
                    if (this._zis != null)
                    {
                        throw new NotSupportedException();
                    }
                    name = this._zos.Name;
                }
                return name;
            }
        }

        // Token: 0x1700001D RID: 29
        // (get) Token: 0x0600003E RID: 62 RVA: 0x00002CDC File Offset: 0x00000EDC
        public string Password
        {
            get
            {
                string password;
                if (this._zf != null)
                {
                    password = this._zf._Password;
                }
                else if (this._zis != null)
                {
                    password = this._zis._Password;
                }
                else
                {
                    password = this._zos._password;
                }
                return password;
            }
        }

        // Token: 0x1700001E RID: 30
        // (get) Token: 0x0600003F RID: 63 RVA: 0x00002D30 File Offset: 0x00000F30
        public Zip64Option Zip64
        {
            get
            {
                Zip64Option zip;
                if (this._zf != null)
                {
                    zip = this._zf._zip64;
                }
                else
                {
                    if (this._zis != null)
                    {
                        throw new NotSupportedException();
                    }
                    zip = this._zos._zip64;
                }
                return zip;
            }
        }

        // Token: 0x1700001F RID: 31
        // (get) Token: 0x06000040 RID: 64 RVA: 0x00002D7C File Offset: 0x00000F7C
        public int BufferSize
        {
            get
            {
                int result;
                if (this._zf != null)
                {
                    result = this._zf.BufferSize;
                }
                else
                {
                    if (this._zis != null)
                    {
                        throw new NotSupportedException();
                    }
                    result = 0;
                }
                return result;
            }
        }

        // Token: 0x17000020 RID: 32
        // (get) Token: 0x06000041 RID: 65 RVA: 0x00002DC0 File Offset: 0x00000FC0
        // (set) Token: 0x06000042 RID: 66 RVA: 0x00002E0C File Offset: 0x0000100C
        public ParallelDeflateOutputStream ParallelDeflater
        {
            get
            {
                ParallelDeflateOutputStream result;
                if (this._zf != null)
                {
                    result = this._zf.ParallelDeflater;
                }
                else if (this._zis != null)
                {
                    result = null;
                }
                else
                {
                    result = this._zos.ParallelDeflater;
                }
                return result;
            }
            set
            {
                if (this._zf != null)
                {
                    this._zf.ParallelDeflater = value;
                }
                else if (this._zos != null)
                {
                    this._zos.ParallelDeflater = value;
                }
            }
        }

        // Token: 0x17000021 RID: 33
        // (get) Token: 0x06000043 RID: 67 RVA: 0x00002E50 File Offset: 0x00001050
        public long ParallelDeflateThreshold
        {
            get
            {
                long parallelDeflateThreshold;
                if (this._zf != null)
                {
                    parallelDeflateThreshold = this._zf.ParallelDeflateThreshold;
                }
                else
                {
                    parallelDeflateThreshold = this._zos.ParallelDeflateThreshold;
                }
                return parallelDeflateThreshold;
            }
        }

        // Token: 0x17000022 RID: 34
        // (get) Token: 0x06000044 RID: 68 RVA: 0x00002E88 File Offset: 0x00001088
        public int ParallelDeflateMaxBufferPairs
        {
            get
            {
                int parallelDeflateMaxBufferPairs;
                if (this._zf != null)
                {
                    parallelDeflateMaxBufferPairs = this._zf.ParallelDeflateMaxBufferPairs;
                }
                else
                {
                    parallelDeflateMaxBufferPairs = this._zos.ParallelDeflateMaxBufferPairs;
                }
                return parallelDeflateMaxBufferPairs;
            }
        }

        // Token: 0x17000023 RID: 35
        // (get) Token: 0x06000045 RID: 69 RVA: 0x00002EC0 File Offset: 0x000010C0
        public int CodecBufferSize
        {
            get
            {
                int codecBufferSize;
                if (this._zf != null)
                {
                    codecBufferSize = this._zf.CodecBufferSize;
                }
                else if (this._zis != null)
                {
                    codecBufferSize = this._zis.CodecBufferSize;
                }
                else
                {
                    codecBufferSize = this._zos.CodecBufferSize;
                }
                return codecBufferSize;
            }
        }

        // Token: 0x17000024 RID: 36
        // (get) Token: 0x06000046 RID: 70 RVA: 0x00002F14 File Offset: 0x00001114
        public CompressionStrategy Strategy
        {
            get
            {
                CompressionStrategy strategy;
                if (this._zf != null)
                {
                    strategy = this._zf.Strategy;
                }
                else
                {
                    strategy = this._zos.Strategy;
                }
                return strategy;
            }
        }

        // Token: 0x17000025 RID: 37
        // (get) Token: 0x06000047 RID: 71 RVA: 0x00002F4C File Offset: 0x0000114C
        public Zip64Option UseZip64WhenSaving
        {
            get
            {
                Zip64Option result;
                if (this._zf != null)
                {
                    result = this._zf.UseZip64WhenSaving;
                }
                else
                {
                    result = this._zos.EnableZip64;
                }
                return result;
            }
        }

        // Token: 0x17000026 RID: 38
        // (get) Token: 0x06000048 RID: 72 RVA: 0x00002F84 File Offset: 0x00001184
        public Encoding AlternateEncoding
        {
            get
            {
                Encoding result;
                if (this._zf != null)
                {
                    result = this._zf.AlternateEncoding;
                }
                else if (this._zos != null)
                {
                    result = this._zos.AlternateEncoding;
                }
                else
                {
                    result = null;
                }
                return result;
            }
        }

        // Token: 0x17000027 RID: 39
        // (get) Token: 0x06000049 RID: 73 RVA: 0x00002FD0 File Offset: 0x000011D0
        public Encoding DefaultEncoding
        {
            get
            {
                Encoding result;
                if (this._zf != null)
                {
                    result = ZipFile.DefaultEncoding;
                }
                else if (this._zos != null)
                {
                    result = ZipOutputStream.DefaultEncoding;
                }
                else
                {
                    result = null;
                }
                return result;
            }
        }

        // Token: 0x17000028 RID: 40
        // (get) Token: 0x0600004A RID: 74 RVA: 0x00003010 File Offset: 0x00001210
        public ZipOption AlternateEncodingUsage
        {
            get
            {
                ZipOption result;
                if (this._zf != null)
                {
                    result = this._zf.AlternateEncodingUsage;
                }
                else if (this._zos != null)
                {
                    result = this._zos.AlternateEncodingUsage;
                }
                else
                {
                    result = ZipOption.Default;
                }
                return result;
            }
        }

        // Token: 0x17000029 RID: 41
        // (get) Token: 0x0600004B RID: 75 RVA: 0x0000305C File Offset: 0x0000125C
        public Stream ReadStream
        {
            get
            {
                Stream readStream;
                if (this._zf != null)
                {
                    readStream = this._zf.ReadStream;
                }
                else
                {
                    readStream = this._zis.ReadStream;
                }
                return readStream;
            }
        }

        // Token: 0x04000027 RID: 39
        private ZipFile _zf;

        // Token: 0x04000028 RID: 40
        private ZipOutputStream _zos;

        // Token: 0x04000029 RID: 41
        private ZipInputStream _zis;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   This class implements the "traditional" or "classic" PKZip encryption,
    ///   which today is considered to be weak. On the other hand it is
    ///   ubiquitous. This class is intended for use only by the DotNetZip
    ///   library.
    /// </summary>
    ///
    /// <remarks>
    ///   Most uses of the DotNetZip library will not involve direct calls into
    ///   the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
    ///   used by the ZipEntry() class when encryption or decryption on an entry
    ///   is employed.  If for some reason you really wanted to use a weak
    ///   encryption algorithm in some other application, you might use this
    ///   library.  But you would be much better off using one of the built-in
    ///   strong encryption libraries in the .NET Framework, like the AES
    ///   algorithm or SHA.
    /// </remarks>
    // Token: 0x02000026 RID: 38
    internal class ZipCrypto
    {
        /// <summary>
        ///   The default constructor for ZipCrypto.
        /// </summary>
        ///
        /// <remarks>
        ///   This class is intended for internal use by the library only. It's
        ///   probably not useful to you. Seriously.  Stop reading this
        ///   documentation.  It's a waste of your time.  Go do something else.
        ///   Check the football scores. Go get an ice cream with a friend.
        ///   Seriously.
        /// </remarks>
        // Token: 0x06000134 RID: 308 RVA: 0x00007854 File Offset: 0x00005A54
        private ZipCrypto()
        {
        }

        // Token: 0x06000135 RID: 309 RVA: 0x00007884 File Offset: 0x00005A84
        public static ZipCrypto ForWrite(string password)
        {
            ZipCrypto z = new ZipCrypto();
            if (password == null)
            {
                throw new BadPasswordException("This entry requires a password.");
            }
            z.InitCipher(password);
            return z;
        }

        // Token: 0x06000136 RID: 310 RVA: 0x000078BC File Offset: 0x00005ABC
        public static ZipCrypto ForRead(string password, ZipEntry e)
        {
            Stream s = e._archiveStream;
            e._WeakEncryptionHeader = new byte[12];
            byte[] eh = e._WeakEncryptionHeader;
            ZipCrypto z = new ZipCrypto();
            if (password == null)
            {
                throw new BadPasswordException("This entry requires a password.");
            }
            z.InitCipher(password);
            ZipEntry.ReadWeakEncryptionHeader(s, eh);
            byte[] DecryptedHeader = z.DecryptMessage(eh, eh.Length);
            if (DecryptedHeader[11] != (byte)(e._Crc32 >> 24 & 255))
            {
                if ((e._BitField & 8) != 8)
                {
                    throw new BadPasswordException("The password did not match.");
                }
                if (DecryptedHeader[11] != (byte)(e._TimeBlob >> 8 & 255))
                {
                    throw new BadPasswordException("The password did not match.");
                }
            }
            return z;
        }

        /// <summary>
        /// From AppNote.txt:
        /// unsigned char decrypt_byte()
        ///     local unsigned short temp
        ///     temp :=- Key(2) | 2
        ///     decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
        /// end decrypt_byte
        /// </summary>
        // Token: 0x1700005E RID: 94
        // (get) Token: 0x06000137 RID: 311 RVA: 0x0000798C File Offset: 0x00005B8C
        private byte MagicByte
        {
            get
            {
                ushort t = (ushort)((this._Keys[2] & 65535u) | 2);
                return (byte)(t * (t ^ 1) >> 8);
            }
        }

        /// <summary>
        ///   Call this method on a cipher text to render the plaintext. You must
        ///   first initialize the cipher with a call to InitCipher.
        /// </summary>
        ///
        /// <example>
        ///   <code>
        ///     var cipher = new ZipCrypto();
        ///     cipher.InitCipher(Password);
        ///     // Decrypt the header.  This has a side effect of "further initializing the
        ///     // encryption keys" in the traditional zip encryption.
        ///     byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
        ///   </code>
        /// </example>
        ///
        /// <param name="cipherText">The encrypted buffer.</param>
        /// <param name="length">
        ///   The number of bytes to encrypt.
        ///   Should be less than or equal to CipherText.Length.
        /// </param>
        ///
        /// <returns>The plaintext.</returns>
        // Token: 0x06000138 RID: 312 RVA: 0x000079BC File Offset: 0x00005BBC
        public byte[] DecryptMessage(byte[] cipherText, int length)
        {
            if (cipherText == null)
            {
                throw new ArgumentNullException("cipherText");
            }
            if (length > cipherText.Length)
            {
                throw new ArgumentOutOfRangeException("length", "Bad length during Decryption: the length parameter must be smaller than or equal to the size of the destination array.");
            }
            byte[] plainText = new byte[length];
            for (int i = 0; i < length; i++)
            {
                byte C = (byte)(cipherText[i] ^ this.MagicByte);
                this.UpdateKeys(C);
                plainText[i] = C;
            }
            return plainText;
        }

        /// <summary>
        ///   This is the converse of DecryptMessage.  It encrypts the plaintext
        ///   and produces a ciphertext.
        /// </summary>
        ///
        /// <param name="plainText">The plain text buffer.</param>
        ///
        /// <param name="length">
        ///   The number of bytes to encrypt.
        ///   Should be less than or equal to plainText.Length.
        /// </param>
        ///
        /// <returns>The ciphertext.</returns>
        // Token: 0x06000139 RID: 313 RVA: 0x00007A3C File Offset: 0x00005C3C
        public byte[] EncryptMessage(byte[] plainText, int length)
        {
            if (plainText == null)
            {
                throw new ArgumentNullException("plaintext");
            }
            if (length > plainText.Length)
            {
                throw new ArgumentOutOfRangeException("length", "Bad length during Encryption: The length parameter must be smaller than or equal to the size of the destination array.");
            }
            byte[] cipherText = new byte[length];
            for (int i = 0; i < length; i++)
            {
                byte C = plainText[i];
                cipherText[i] = (byte)(plainText[i] ^ this.MagicByte);
                this.UpdateKeys(C);
            }
            return cipherText;
        }

        /// <summary>
        ///   This initializes the cipher with the given password.
        ///   See AppNote.txt for details.
        /// </summary>
        ///
        /// <param name="passphrase">
        ///   The passphrase for encrypting or decrypting with this cipher.
        /// </param>
        ///
        /// <remarks>
        /// <code>
        /// Step 1 - Initializing the encryption keys
        /// -----------------------------------------
        /// Start with these keys:
        /// Key(0) := 305419896 (0x12345678)
        /// Key(1) := 591751049 (0x23456789)
        /// Key(2) := 878082192 (0x34567890)
        ///
        /// Then, initialize the keys with a password:
        ///
        /// loop for i from 0 to length(password)-1
        ///     update_keys(password(i))
        /// end loop
        ///
        /// Where update_keys() is defined as:
        ///
        /// update_keys(char):
        ///   Key(0) := crc32(key(0),char)
        ///   Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
        ///   Key(1) := Key(1) * 134775813 + 1
        ///   Key(2) := crc32(key(2),key(1) rightshift 24)
        /// end update_keys
        ///
        /// Where crc32(old_crc,char) is a routine that given a CRC value and a
        /// character, returns an updated CRC value after applying the CRC-32
        /// algorithm described elsewhere in this document.
        ///
        /// </code>
        ///
        /// <para>
        ///   After the keys are initialized, then you can use the cipher to
        ///   encrypt the plaintext.
        /// </para>
        ///
        /// <para>
        ///   Essentially we encrypt the password with the keys, then discard the
        ///   ciphertext for the password. This initializes the keys for later use.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x0600013A RID: 314 RVA: 0x00007ABC File Offset: 0x00005CBC
        public void InitCipher(string passphrase)
        {
            byte[] p = SharedUtilities.StringToByteArray(passphrase);
            for (int i = 0; i < passphrase.Length; i++)
            {
                this.UpdateKeys(p[i]);
            }
        }

        // Token: 0x0600013B RID: 315 RVA: 0x00007AF0 File Offset: 0x00005CF0
        private void UpdateKeys(byte byteValue)
        {
            this._Keys[0] = (uint)this.crc32.ComputeCrc32((int)this._Keys[0], byteValue);
            this._Keys[1] = this._Keys[1] + (uint)((byte)this._Keys[0]);
            this._Keys[1] = this._Keys[1] * 134775813u + 1u;
            this._Keys[2] = (uint)this.crc32.ComputeCrc32((int)this._Keys[2], (byte)(this._Keys[1] >> 24));
        }

        // Token: 0x040000BA RID: 186
        private uint[] _Keys = new uint[]
        {
            305419896u,
            591751049u,
            878082192u
        };

        // Token: 0x040000BB RID: 187
        private CRC32 crc32 = new CRC32();
    }
}

namespace Ionic.Zip
{
    /// <summary>
    /// Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
    /// by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
    /// </summary>
    // Token: 0x02000034 RID: 52
    [ComVisible(true)]
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00004")]
    [ClassInterface(ClassInterfaceType.AutoDispatch)]
    public class ZipEntry
    {
        /// <summary>
        /// True if the referenced entry is a directory.
        /// </summary>
        // Token: 0x17000070 RID: 112
        // (get) Token: 0x0600018A RID: 394 RVA: 0x000082BC File Offset: 0x000064BC
        internal bool AttributesIndicateDirectory
        {
            get
            {
                return this._InternalFileAttrs == 0 && (this._ExternalFileAttrs & 16) == 16;
            }
        }

        // Token: 0x0600018B RID: 395 RVA: 0x000082E6 File Offset: 0x000064E6
        internal void ResetDirEntry()
        {
            this.__FileDataPosition = -1L;
            this._LengthOfHeader = 0;
        }

        /// <summary>
        /// Provides a human-readable string with information about the ZipEntry.
        /// </summary>
        // Token: 0x17000071 RID: 113
        // (get) Token: 0x0600018C RID: 396 RVA: 0x000082F8 File Offset: 0x000064F8
        public string Info
        {
            get
            {
                unchecked
                {
                    StringBuilder builder = new StringBuilder();
                    builder.Append(string.Format("          ZipEntry: {0}\n", this.FileName)).Append(string.Format("   Version Made By: {0}\n", this._VersionMadeBy)).Append(string.Format(" Needed to extract: {0}\n", this.VersionNeeded));
                    if (this._IsDirectory)
                    {
                        builder.Append("        Entry type: directory\n");
                    }
                    else
                    {
                        builder.Append(string.Format("         File type: {0}\n", this._IsText ? "text" : "binary")).Append(string.Format("       Compression: {0}\n", this.CompressionMethod)).Append(string.Format("        Compressed: 0x{0:X}\n", this.CompressedSize)).Append(string.Format("      Uncompressed: 0x{0:X}\n", this.UncompressedSize)).Append(string.Format("             CRC32: 0x{0:X8}\n", this._Crc32));
                    }
                    builder.Append(string.Format("       Disk Number: {0}\n", this._diskNumber));
                    if (this._RelativeOffsetOfLocalHeader > (long)((ulong)-1))
                    {
                        builder.Append(string.Format("   Relative Offset: 0x{0:X16}\n", this._RelativeOffsetOfLocalHeader));
                    }
                    else
                    {
                        builder.Append(string.Format("   Relative Offset: 0x{0:X8}\n", this._RelativeOffsetOfLocalHeader));
                    }
                    builder.Append(string.Format("         Bit Field: 0x{0:X4}\n", this._BitField)).Append(string.Format("        Encrypted?: {0}\n", this._sourceIsEncrypted)).Append(string.Format("          Timeblob: 0x{0:X8}\n", this._TimeBlob)).Append(string.Format("              Time: {0}\n", SharedUtilities.PackedToDateTime(this._TimeBlob)));
                    builder.Append(string.Format("         Is Zip64?: {0}\n", this._InputUsesZip64));
                    if (!string.IsNullOrEmpty(this._Comment))
                    {
                        builder.Append(string.Format("           Comment: {0}\n", this._Comment));
                    }
                    builder.Append("\n");
                    return builder.ToString();
                }
            }
        }

        /// <summary>
        ///   Reads one entry from the zip directory structure in the zip file.
        /// </summary>
        ///
        /// <param name="zf">
        ///   The zipfile for which a directory entry will be read.  From this param, the
        ///   method gets the ReadStream and the expected text encoding
        ///   (ProvisionalAlternateEncoding) which is used if the entry is not marked
        ///   UTF-8.
        /// </param>
        ///
        /// <param name="previouslySeen">
        ///   a list of previously seen entry names; used to prevent duplicates.
        /// </param>
        ///
        /// <returns>the entry read from the archive.</returns>
        // Token: 0x0600018D RID: 397 RVA: 0x00008534 File Offset: 0x00006734
        internal static ZipEntry ReadDirEntry(ZipFile zf, Dictionary<string, object> previouslySeen)
        {
            Stream s = zf.ReadStream;
            Encoding expectedEncoding = (zf.AlternateEncodingUsage == ZipOption.Always) ? zf.AlternateEncoding : ZipFile.DefaultEncoding;
            int signature = SharedUtilities.ReadSignature(s);
            ZipEntry result;
            if (ZipEntry.IsNotValidZipDirEntrySig(signature))
            {
                s.Seek(-4L, SeekOrigin.Current);
                if ((long)signature != 101010256L && (long)signature != 101075792L && signature != 67324752)
                {
                    throw new BadReadException(string.Format("  Bad signature (0x{0:X8}) at position 0x{1:X8}", signature, s.Position));
                }
                result = null;
            }
            else
            {
                int bytesRead = 46;
                byte[] block = new byte[42];
                int i = s.Read(block, 0, block.Length);
                if (i != block.Length)
                {
                    result = null;
                }
                else
                {
                    int j = 0;
                    ZipEntry zde = new ZipEntry();
                    zde.AlternateEncoding = expectedEncoding;
                    zde._Source = ZipEntrySource.ZipFile;
                    zde._container = new ZipContainer(zf);
                    zde._VersionMadeBy = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._VersionNeeded = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._BitField = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._CompressionMethod = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._TimeBlob = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                    zde._LastModified = SharedUtilities.PackedToDateTime(zde._TimeBlob);
                    zde._timestamp |= ZipEntryTimestamp.DOS;
                    zde._Crc32 = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                    zde._CompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                    zde._UncompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                    zde._CompressionMethod_FromZipFile = zde._CompressionMethod;
                    zde._filenameLength = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._extraFieldLength = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._commentLength = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._diskNumber = (uint)block[j++] + (uint)block[j++] * 256u;
                    zde._InternalFileAttrs = (short)((int)block[j++] + (int)block[j++] * 256);
                    zde._ExternalFileAttrs = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                    zde._RelativeOffsetOfLocalHeader = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                    zde.IsText = ((zde._InternalFileAttrs & 1) == 1);
                    block = new byte[(int)zde._filenameLength];
                    i = s.Read(block, 0, block.Length);
                    bytesRead += i;
                    if ((zde._BitField & 2048) == 2048)
                    {
                        zde._FileNameInArchive = SharedUtilities.Utf8StringFromBuffer(block);
                    }
                    else
                    {
                        zde._FileNameInArchive = SharedUtilities.StringFromBuffer(block, expectedEncoding);
                    }
                    while (previouslySeen.ContainsKey(zde._FileNameInArchive))
                    {
                        zde._FileNameInArchive = ZipEntry.CopyHelper.AppendCopyToFileName(zde._FileNameInArchive);
                        zde._metadataChanged = true;
                    }
                    if (zde.AttributesIndicateDirectory)
                    {
                        zde.MarkAsDirectory();
                    }
                    else if (zde._FileNameInArchive.EndsWith("/"))
                    {
                        zde.MarkAsDirectory();
                    }
                    zde._CompressedFileDataSize = zde._CompressedSize;
                    if ((zde._BitField & 1) == 1)
                    {
                        zde._Encryption_FromZipFile = (zde._Encryption = EncryptionAlgorithm.PkzipWeak);
                        zde._sourceIsEncrypted = true;
                    }
                    if (zde._extraFieldLength > 0)
                    {
                        unchecked
                        {
                            zde._InputUsesZip64 = (zde._CompressedSize == (long)((ulong)-1) || zde._UncompressedSize == (long)((ulong)-1) || zde._RelativeOffsetOfLocalHeader == (long)((ulong)-1));
                            bytesRead += zde.ProcessExtraField(s, zde._extraFieldLength);
                            zde._CompressedFileDataSize = zde._CompressedSize;
                        }
                    }
                    if (zde._Encryption == EncryptionAlgorithm.PkzipWeak)
                    {
                        zde._CompressedFileDataSize -= 12L;
                    }
                    else if (zde.Encryption == EncryptionAlgorithm.WinZipAes128 || zde.Encryption == EncryptionAlgorithm.WinZipAes256)
                    {
                        zde._CompressedFileDataSize = zde.CompressedSize - (long)(ZipEntry.GetLengthOfCryptoHeaderBytes(zde.Encryption) + 10);
                        zde._LengthOfTrailer = 10;
                    }
                    if ((zde._BitField & 8) == 8)
                    {
                        if (zde._InputUsesZip64)
                        {
                            zde._LengthOfTrailer += 24;
                        }
                        else
                        {
                            zde._LengthOfTrailer += 16;
                        }
                    }
                    zde.AlternateEncoding = (((zde._BitField & 2048) == 2048) ? Encoding.UTF8 : expectedEncoding);
                    zde.AlternateEncodingUsage = ZipOption.Always;
                    if (zde._commentLength > 0)
                    {
                        block = new byte[(int)zde._commentLength];
                        i = s.Read(block, 0, block.Length);
                        bytesRead += i;
                        if ((zde._BitField & 2048) == 2048)
                        {
                            zde._Comment = SharedUtilities.Utf8StringFromBuffer(block);
                        }
                        else
                        {
                            zde._Comment = SharedUtilities.StringFromBuffer(block, expectedEncoding);
                        }
                    }
                    result = zde;
                }
            }
            return result;
        }

        /// <summary>
        /// Returns true if the passed-in value is a valid signature for a ZipDirEntry.
        /// </summary>
        /// <param name="signature">the candidate 4-byte signature value.</param>
        /// <returns>true, if the signature is valid according to the PKWare spec.</returns>
        // Token: 0x0600018E RID: 398 RVA: 0x00008C8C File Offset: 0x00006E8C
        internal static bool IsNotValidZipDirEntrySig(int signature)
        {
            return signature != 33639248;
        }

        /// <summary>
        /// Default constructor.
        /// </summary>
        /// <remarks>
        /// Applications should never need to call this directly.  It is exposed to
        /// support COM Automation environments.
        /// </remarks>
        // Token: 0x0600018F RID: 399 RVA: 0x00008CAC File Offset: 0x00006EAC
        public ZipEntry()
        {
            this._CompressionMethod = 8;
            this._CompressionLevel = CompressionLevel.Default;
            this._Encryption = EncryptionAlgorithm.None;
            this._Source = ZipEntrySource.None;
            this.AlternateEncoding = Encoding.GetEncoding("IBM437");
            this.AlternateEncodingUsage = ZipOption.Default;
        }

        /// <summary>
        ///   The time and date at which the file indicated by the <c>ZipEntry</c> was
        ///   last modified.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The DotNetZip library sets the LastModified value for an entry, equal to
        ///   the Last Modified time of the file in the filesystem.  If an entry is
        ///   added from a stream, the library uses <c>System.DateTime.Now</c> for this
        ///   value, for the given entry.
        /// </para>
        ///
        /// <para>
        ///   This property allows the application to retrieve and possibly set the
        ///   LastModified value on an entry, to an arbitrary value.  <see cref="T:System.DateTime" /> values with a <see cref="T:System.DateTimeKind" />
        ///   setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
        ///   <c>DateTimeKind.Local</c>.
        /// </para>
        ///
        /// <para>
        ///   Be aware that because of the way <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
        ///   Zip specification</see> describes how times are stored in the zip file,
        ///   the full precision of the <c>System.DateTime</c> datatype is not stored
        ///   for the last modified time when saving zip files.  For more information on
        ///   how times are formatted, see the PKZip specification.
        /// </para>
        ///
        /// <para>
        ///   The actual last modified time of a file can be stored in multiple ways in
        ///   the zip file, and they are not mutually exclusive:
        /// </para>
        ///
        /// <list type="bullet">
        ///   <item>
        ///     In the so-called "DOS" format, which has a 2-second precision. Values
        ///     are rounded to the nearest even second. For example, if the time on the
        ///     file is 12:34:43, then it will be stored as 12:34:44. This first value
        ///     is accessible via the <c>LastModified</c> property. This value is always
        ///     present in the metadata for each zip entry.  In some cases the value is
        ///     invalid, or zero.
        ///   </item>
        ///
        ///   <item>
        ///     In the so-called "Windows" or "NTFS" format, as an 8-byte integer
        ///     quantity expressed as the number of 1/10 milliseconds (in other words
        ///     the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
        ///     format is how Windows represents file times.  This time is accessible
        ///     via the <c>ModifiedTime</c> property.
        ///   </item>
        ///
        ///   <item>
        ///     In the "Unix" format, a 4-byte quantity specifying the number of seconds since
        ///     January 1, 1970 UTC.
        ///   </item>
        ///
        ///   <item>
        ///     In an older format, now deprecated but still used by some current
        ///     tools. This format is also a 4-byte quantity specifying the number of
        ///     seconds since January 1, 1970 UTC.
        ///   </item>
        ///
        /// </list>
        ///
        /// <para>
        ///   Zip tools and libraries will always at least handle (read or write) the
        ///   DOS time, and may also handle the other time formats.  Keep in mind that
        ///   while the names refer to particular operating systems, there is nothing in
        ///   the time formats themselves that prevents their use on other operating
        ///   systems.
        /// </para>
        ///
        /// <para>
        ///   When reading ZIP files, the DotNetZip library reads the Windows-formatted
        ///   time, if it is stored in the entry, and sets both <c>LastModified</c> and
        ///   <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
        ///   library by default will write both time quantities. It can also emit the
        ///   Unix-formatted time if desired (See <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />.)
        /// </para>
        ///
        /// <para>
        ///   The last modified time of the file created upon a call to
        ///   <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
        ///   for differences in how the .NET Base Class Library deals with daylight
        ///   saving time (DST) versus how the Windows filesystem deals with daylight
        ///   saving time.  Raymond Chen <see href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
        ///   some good context</see>.
        /// </para>
        ///
        /// <para>
        ///   In a nutshell: Daylight savings time rules change regularly.  In 2007, for
        ///   example, the inception week of DST changed.  In 1977, DST was in place all
        ///   year round. In 1945, likewise.  And so on.  Win32 does not attempt to
        ///   guess which time zone rules were in effect at the time in question.  It
        ///   will render a time as "standard time" and allow the app to change to DST
        ///   as necessary.  .NET makes a different choice.
        /// </para>
        ///
        /// <para>
        ///   Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
        ///   see in the Windows Explorer property sheet for a file that was last
        ///   written to on the other side of the DST transition. For example, suppose
        ///   the file was last modified on October 17, 2003, during DST but DST is not
        ///   currently in effect. Explorer's file properties reports Thursday, October
        ///   17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
        ///   2003, 9:45 AM.
        /// </para>
        ///
        /// <para>
        ///   Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
        ///   STANDARD Time. Even though October 17 of that year occurred during Pacific
        ///   Daylight Time, Win32 displays the time as standard time because that's
        ///   what time it is NOW.
        /// </para>
        ///
        /// <para>
        ///   .NET BCL assumes that the current DST rules were in place at the time in
        ///   question.  So, .NET says, "Well, if the rules in effect now were also in
        ///   effect on October 17, 2003, then that would be daylight time" so it
        ///   displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
        /// </para>
        ///
        /// <para>
        ///   So .NET gives a value which is more intuitively correct, but is also
        ///   potentially incorrect, and which is not invertible. Win32 gives a value
        ///   which is intuitively incorrect, but is strictly correct.
        /// </para>
        ///
        /// <para>
        ///   Because of this funkiness, this library adds one hour to the LastModified
        ///   time on the extracted file, if necessary.  That is to say, if the time in
        ///   question had occurred in what the .NET Base Class Library assumed to be
        ///   DST. This assumption may be wrong given the constantly changing DST rules,
        ///   but it is the best we can do.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000072 RID: 114
        // (get) Token: 0x06000190 RID: 400 RVA: 0x00008D18 File Offset: 0x00006F18
        // (set) Token: 0x06000191 RID: 401 RVA: 0x00008D38 File Offset: 0x00006F38
        public DateTime LastModified
        {
            get
            {
                return this._LastModified.ToLocalTime();
            }
            set
            {
                this._LastModified = ((value.Kind == DateTimeKind.Unspecified) ? DateTime.SpecifyKind(value, DateTimeKind.Local) : value.ToLocalTime());
                this._Mtime = SharedUtilities.AdjustTime_Reverse(this._LastModified).ToUniversalTime();
                this._metadataChanged = true;
            }
        }

        // Token: 0x17000073 RID: 115
        // (get) Token: 0x06000192 RID: 402 RVA: 0x00008D88 File Offset: 0x00006F88
        private int BufferSize
        {
            get
            {
                return this._container.BufferSize;
            }
        }

        /// <summary>
        /// Last Modified time for the file represented by the entry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This value corresponds to the "last modified" time in the NTFS file times
        ///   as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
        ///   specification</see>.  When getting this property, the value may be
        ///   different from <see cref="P:Ionic.Zip.ZipEntry.LastModified" />.  When setting the property,
        ///   the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property also gets set, but with a lower
        ///   precision.
        /// </para>
        ///
        /// <para>
        ///   Let me explain. It's going to take a while, so get
        ///   comfortable. Originally, waaaaay back in 1989 when the ZIP specification
        ///   was originally described by the esteemed Mr. Phil Katz, the dominant
        ///   operating system of the time was MS-DOS. MSDOS stored file times with a
        ///   2-second precision, because, c'mon, <em>who is ever going to need better
        ///   resolution than THAT?</em> And so ZIP files, regardless of the platform on
        ///   which the zip file was created, store file times in exactly <see href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
        ///   in 1989</see>.
        /// </para>
        ///
        /// <para>
        ///   Since then, the ZIP spec has evolved, but the internal format for file
        ///   timestamps remains the same.  Despite the fact that the way times are
        ///   stored in a zip file is rooted in DOS heritage, any program on any
        ///   operating system can format a time in this way, and most zip tools and
        ///   libraries DO - they round file times to the nearest even second and store
        ///   it just like DOS did 25+ years ago.
        /// </para>
        ///
        /// <para>
        ///   PKWare extended the ZIP specification to allow a zip file to store what
        ///   are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
        ///   <em>last write</em>, <em>last access</em>, and <em>file creation</em>
        ///   times of a particular file. These metadata are not actually specific
        ///   to NTFS or Unix. They are tracked for each file by NTFS and by various
        ///   Unix filesystems, but they are also tracked by other filesystems, too.
        ///   The key point is that the times are <em>formatted in the zip file</em>
        ///   in the same way that NTFS formats the time (ticks since win32 epoch),
        ///   or in the same way that Unix formats the time (seconds since Unix
        ///   epoch). As with the DOS time, any tool or library running on any
        ///   operating system is capable of formatting a time in one of these ways
        ///   and embedding it into the zip file.
        /// </para>
        ///
        /// <para>
        ///   These extended times are higher precision quantities than the DOS time.
        ///   As described above, the (DOS) LastModified has a precision of 2 seconds.
        ///   The Unix time is stored with a precision of 1 second. The NTFS time is
        ///   stored with a precision of 0.0000001 seconds. The quantities are easily
        ///   convertible, except for the loss of precision you may incur.
        /// </para>
        ///
        /// <para>
        ///   A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
        ///   or not at all.  Often a tool running on Unix or Mac will embed the times
        ///   in Unix format (1 second precision), while WinZip running on Windows might
        ///   embed the times in NTFS format (precision of of 0.0000001 seconds).  When
        ///   reading a zip file with these "extended" times, in either format,
        ///   DotNetZip represents the values with the
        ///   <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
        ///   properties on the <c>ZipEntry</c>.
        /// </para>
        ///
        /// <para>
        ///   While any zip application or library, regardless of the platform it
        ///   runs on, could use any of the time formats allowed by the ZIP
        ///   specification, not all zip tools or libraries do support all these
        ///   formats.  Storing the higher-precision times for each entry is
        ///   optional for zip files, and many tools and libraries don't use the
        ///   higher precision quantities at all. The old DOS time, represented by
        ///   <see cref="P:Ionic.Zip.ZipEntry.LastModified" />, is guaranteed to be present, though it
        ///   sometimes unset.
        /// </para>
        ///
        /// <para>
        ///   Ok, getting back to the question about how the <c>LastModified</c>
        ///   property relates to this <c>ModifiedTime</c>
        ///   property... <c>LastModified</c> is always set, while
        ///   <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
        ///   times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
        ///   may not be set on an entry that is read from an existing zip file.)
        ///   When reading a zip file, then <c>LastModified</c> takes the DOS time
        ///   that is stored with the file. If the DOS time has been stored as zero
        ///   in the zipfile, then this library will use <c>DateTime.Now</c> for the
        ///   <c>LastModified</c> value.  If the ZIP file was created by an evolved
        ///   tool, then there will also be higher precision NTFS or Unix times in
        ///   the zip file.  In that case, this library will read those times, and
        ///   set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
        ///   one corresponding to the last write time of the file.  If there are no
        ///   higher precision times stored for the entry, then <c>ModifiedTime</c>
        ///   remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
        ///   and <c>LastModified</c> keeps its DOS time.
        /// </para>
        ///
        /// <para>
        ///   When creating zip files with this library, by default the extended time
        ///   properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
        ///   <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
        ///   stored in the zip archive for each entry, in NTFS format. If you add an
        ///   entry from an actual filesystem file, then the entry gets the actual file
        ///   times for that file, to NTFS-level precision.  If you add an entry from a
        ///   stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
        ///   this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
        ///   to 2 seconds of precision.  You can explicitly set the
        ///   <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
        ///   entry using the property setters.  If you want to set all of those
        ///   quantities, it's more efficient to use the <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" /> method.  Those
        ///   changes are not made permanent in the zip file until you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins.
        /// </para>
        ///
        /// <para>
        ///   When creating a zip file, you can override the default behavior of
        ///   this library for formatting times in the zip file, disabling the
        ///   embedding of file times in NTFS format or enabling the storage of file
        ///   times in Unix format, or both.  You may want to do this, for example,
        ///   when creating a zip file on Windows, that will be consumed on a Mac,
        ///   by an application that is not hip to the "NTFS times" format. To do
        ///   this, use the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> and
        ///   <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> properties.  A valid zip
        ///   file may store the file times in both formats.  But, there are no
        ///   guarantees that a program running on Mac or Linux will gracefully
        ///   handle the NTFS-formatted times when Unix times are present, or that a
        ///   non-DotNetZip-powered application running on Windows will be able to
        ///   handle file times in Unix format. DotNetZip will always do something
        ///   reasonable; other libraries or tools may not. When in doubt, test.
        /// </para>
        ///
        /// <para>
        ///   I'll bet you didn't think one person could type so much about time, eh?
        ///   And reading it was so enjoyable, too!  Well, in appreciation, <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
        ///   should donate</see>?
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.LastModified" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        // Token: 0x17000074 RID: 116
        // (get) Token: 0x06000193 RID: 403 RVA: 0x00008DA8 File Offset: 0x00006FA8
        // (set) Token: 0x06000194 RID: 404 RVA: 0x00008DC0 File Offset: 0x00006FC0
        public DateTime ModifiedTime
        {
            get
            {
                return this._Mtime;
            }
            set
            {
                this.SetEntryTimes(this._Ctime, this._Atime, value);
            }
        }

        /// <summary>
        /// Last Access time for the file represented by the entry.
        /// </summary>
        /// <remarks>
        /// This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
        /// Zip archive, this information may not be available. For an explanation of why, see
        /// <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />.
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        // Token: 0x17000075 RID: 117
        // (get) Token: 0x06000195 RID: 405 RVA: 0x00008DD8 File Offset: 0x00006FD8
        // (set) Token: 0x06000196 RID: 406 RVA: 0x00008DF0 File Offset: 0x00006FF0
        public DateTime AccessedTime
        {
            get
            {
                return this._Atime;
            }
            set
            {
                this.SetEntryTimes(this._Ctime, value, this._Mtime);
            }
        }

        /// <summary>
        /// The file creation time for the file represented by the entry.
        /// </summary>
        ///
        /// <remarks>
        /// This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
        /// from an existing zip archive, and the creation time was not set on the entry
        /// when the zip file was created, then this property may be meaningless. For an
        /// explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />.
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        // Token: 0x17000076 RID: 118
        // (get) Token: 0x06000197 RID: 407 RVA: 0x00008E08 File Offset: 0x00007008
        // (set) Token: 0x06000198 RID: 408 RVA: 0x00008E20 File Offset: 0x00007020
        public DateTime CreationTime
        {
            get
            {
                return this._Ctime;
            }
            set
            {
                this.SetEntryTimes(value, this._Atime, this._Mtime);
            }
        }

        /// <summary>
        ///   Sets the NTFS Creation, Access, and Modified times for the given entry.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   When adding an entry from a file or directory, the Creation, Access, and
        ///   Modified times for the given entry are automatically set from the
        ///   filesystem values. When adding an entry from a stream or string, the
        ///   values are implicitly set to DateTime.Now.  The application may wish to
        ///   set these values to some arbitrary value, before saving the archive, and
        ///   can do so using the various setters.  If you want to set all of the times,
        ///   this method is more efficient.
        /// </para>
        ///
        /// <para>
        ///   The values you set here will be retrievable with the <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.CreationTime" /> and <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" /> properties.
        /// </para>
        ///
        /// <para>
        ///   When this method is called, if both <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> and <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> are false, then the
        ///   <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
        /// </para>
        ///
        /// <para>
        ///   DateTime values provided here without a DateTimeKind are assumed to be Local Time.
        /// </para>
        ///
        /// </remarks>
        /// <param name="created">the creation time of the entry.</param>
        /// <param name="accessed">the last access time of the entry.</param>
        /// <param name="modified">the last modified time of the entry.</param>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        // Token: 0x06000199 RID: 409 RVA: 0x00008E38 File Offset: 0x00007038
        public void SetEntryTimes(DateTime created, DateTime accessed, DateTime modified)
        {
            this._ntfsTimesAreSet = true;
            if (created == ZipEntry._zeroHour && created.Kind == ZipEntry._zeroHour.Kind)
            {
                created = ZipEntry._win32Epoch;
            }
            if (accessed == ZipEntry._zeroHour && accessed.Kind == ZipEntry._zeroHour.Kind)
            {
                accessed = ZipEntry._win32Epoch;
            }
            if (modified == ZipEntry._zeroHour && modified.Kind == ZipEntry._zeroHour.Kind)
            {
                modified = ZipEntry._win32Epoch;
            }
            this._Ctime = created.ToUniversalTime();
            this._Atime = accessed.ToUniversalTime();
            this._Mtime = modified.ToUniversalTime();
            this._LastModified = this._Mtime;
            if (!this._emitUnixTimes && !this._emitNtfsTimes)
            {
                this._emitNtfsTimes = true;
            }
            this._metadataChanged = true;
        }

        /// <summary>
        ///   Specifies whether the Creation, Access, and Modified times for the given
        ///   entry will be emitted in "Windows format" when the zip archive is saved.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   An application creating a zip archive can use this flag to explicitly
        ///   specify that the file times for the entry should or should not be stored
        ///   in the zip archive in the format used by Windows. The default value of
        ///   this property is <c>true</c>.
        /// </para>
        ///
        /// <para>
        ///   When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified
        ///   (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are automatically
        ///   set from the filesystem values. When adding an entry from a stream or
        ///   string, all three values are implicitly set to DateTime.Now.  Applications
        ///   can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
        /// </para>
        ///
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see> describes multiple ways to format these times in a
        ///   zip file. One is the format Windows applications normally use: 100ns ticks
        ///   since Jan 1, 1601 UTC.  The other is a format Unix applications typically
        ///   use: seconds since January 1, 1970 UTC.  Each format can be stored in an
        ///   "extra field" in the zip entry when saving the zip archive. The former
        ///   uses an extra field with a Header Id of 0x000A, while the latter uses a
        ///   header ID of 0x5455.
        /// </para>
        ///
        /// <para>
        ///   Not all zip tools and libraries can interpret these fields.  Windows
        ///   compressed folders is one that can read the Windows Format timestamps,
        ///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
        ///   tools can read the Unix format timestamps. Although the time values are
        ///   easily convertible, subject to a loss of precision, some tools and
        ///   libraries may be able to read only one or the other. DotNetZip can read or
        ///   write times in either or both formats.
        /// </para>
        ///
        /// <para>
        ///   The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
        /// </para>
        ///
        /// <para>
        ///   This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> property.  It is
        ///   possible that a zip entry can embed the timestamps in both forms, one
        ///   form, or neither.  But, there are no guarantees that a program running on
        ///   Mac or Linux will gracefully handle NTFS Formatted times, or that a
        ///   non-DotNetZip-powered application running on Windows will be able to
        ///   handle file times in Unix format. When in doubt, test.
        /// </para>
        ///
        /// <para>
        ///   Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
        ///   property, to specify the behavior for all entries in a zip, rather than
        ///   the property on each individual entry.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        // Token: 0x17000077 RID: 119
        // (get) Token: 0x0600019A RID: 410 RVA: 0x00008F38 File Offset: 0x00007138
        // (set) Token: 0x0600019B RID: 411 RVA: 0x00008F50 File Offset: 0x00007150
        public bool EmitTimesInWindowsFormatWhenSaving
        {
            get
            {
                return this._emitNtfsTimes;
            }
            set
            {
                this._emitNtfsTimes = value;
                this._metadataChanged = true;
            }
        }

        /// <summary>
        ///   Specifies whether the Creation, Access, and Modified times for the given
        ///   entry will be emitted in "Unix(tm) format" when the zip archive is saved.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   An application creating a zip archive can use this flag to explicitly
        ///   specify that the file times for the entry should or should not be stored
        ///   in the zip archive in the format used by Unix. By default this flag is
        ///   <c>false</c>, meaning the Unix-format times are not stored in the zip
        ///   archive.
        /// </para>
        ///
        /// <para>
        ///   When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified
        ///   (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are automatically
        ///   set from the filesystem values. When adding an entry from a stream or
        ///   string, all three values are implicitly set to DateTime.Now.  Applications
        ///   can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
        /// </para>
        ///
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see> describes multiple ways to format these times in a
        ///   zip file. One is the format Windows applications normally use: 100ns ticks
        ///   since Jan 1, 1601 UTC.  The other is a format Unix applications typically
        ///   use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
        ///   "extra field" in the zip entry when saving the zip archive. The former
        ///   uses an extra field with a Header Id of 0x000A, while the latter uses a
        ///   header ID of 0x5455.
        /// </para>
        ///
        /// <para>
        ///   Not all tools and libraries can interpret these fields.  Windows
        ///   compressed folders is one that can read the Windows Format timestamps,
        ///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
        ///   tools can read the Unix format timestamps. Although the time values are
        ///   easily convertible, subject to a loss of precision, some tools and
        ///   libraries may be able to read only one or the other. DotNetZip can read or
        ///   write times in either or both formats.
        /// </para>
        ///
        /// <para>
        ///   The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
        /// </para>
        ///
        /// <para>
        ///   This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> property.  It is
        ///   possible that a zip entry can embed the timestamps in both forms, one
        ///   form, or neither.  But, there are no guarantees that a program running on
        ///   Mac or Linux will gracefully handle NTFS Formatted times, or that a
        ///   non-DotNetZip-powered application running on Windows will be able to
        ///   handle file times in Unix format. When in doubt, test.
        /// </para>
        ///
        /// <para>
        ///   Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
        ///   property, to specify the behavior for all entries, rather than the
        ///   property on each individual entry.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        // Token: 0x17000078 RID: 120
        // (get) Token: 0x0600019C RID: 412 RVA: 0x00008F64 File Offset: 0x00007164
        // (set) Token: 0x0600019D RID: 413 RVA: 0x00008F7C File Offset: 0x0000717C
        public bool EmitTimesInUnixFormatWhenSaving
        {
            get
            {
                return this._emitUnixTimes;
            }
            set
            {
                this._emitUnixTimes = value;
                this._metadataChanged = true;
            }
        }

        /// <summary>
        /// The type of timestamp attached to the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        /// This property is valid only for a ZipEntry that was read from a zip archive.
        /// It indicates the type of timestamp attached to the entry.
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
        // Token: 0x17000079 RID: 121
        // (get) Token: 0x0600019E RID: 414 RVA: 0x00008F90 File Offset: 0x00007190
        public ZipEntryTimestamp Timestamp
        {
            get
            {
                return this._timestamp;
            }
        }

        /// <summary>
        ///   The file attributes for the entry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
        ///   ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
        ///   <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
        ///   adding an entry from the filesystem.  When adding an entry from a stream
        ///   or string, the Attributes are not set implicitly.  Regardless of the way
        ///   an entry was added to a <c>ZipFile</c>, you can set the attributes
        ///   explicitly if you like.
        /// </para>
        ///
        /// <para>
        ///   When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
        ///   set according to the data stored in the <c>ZipFile</c>. If you extract the
        ///   entry from the archive to a filesystem file, DotNetZip will set the
        ///   attributes on the resulting file accordingly.
        /// </para>
        ///
        /// <para>
        ///   The attributes can be set explicitly by the application.  For example the
        ///   application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
        ///   entries added to an archive, so that on unpack, this attribute will be set
        ///   on the extracted file.  Any changes you make to this property are made
        ///   permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
        ///   instance that contains the ZipEntry.
        /// </para>
        ///
        /// <para>
        ///   For example, an application may wish to zip up a directory and set the
        ///   ReadOnly bit on every file in the archive, so that upon later extraction,
        ///   the resulting files will be marked as ReadOnly.  Not every extraction tool
        ///   respects these attributes, but if you unpack with DotNetZip, as for
        ///   example in a self-extracting archive, then the attributes will be set as
        ///   they are stored in the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   These attributes may not be interesting or useful if the resulting archive
        ///   is extracted on a non-Windows platform.  How these attributes get used
        ///   upon extraction depends on the platform and tool used.
        /// </para>
        ///
        /// <para>
        ///   This property is only partially supported in the Silverlight version
        ///   of the library: applications can read attributes on entries within
        ///   ZipFiles. But extracting entries within Silverlight will not set the
        ///   attributes on the extracted files.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x1700007A RID: 122
        // (get) Token: 0x0600019F RID: 415 RVA: 0x00008FA8 File Offset: 0x000071A8
        // (set) Token: 0x060001A0 RID: 416 RVA: 0x00008FC0 File Offset: 0x000071C0
        public FileAttributes Attributes
        {
            get
            {
                return (FileAttributes)this._ExternalFileAttrs;
            }
            set
            {
                this._ExternalFileAttrs = (int)value;
                this._VersionMadeBy = 45;
                this._metadataChanged = true;
            }
        }

        /// <summary>
        ///   The name of the filesystem file, referred to by the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    This property specifies the thing-to-be-zipped on disk, and is set only
        ///    when the <c>ZipEntry</c> is being created from a filesystem file.  If the
        ///    <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
        ///    the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
        ///  </para>
        ///
        ///  <para>
        ///    When it is set, the value of this property may be different than <see cref="P:Ionic.Zip.ZipEntry.FileName" />, which is the path used in the archive itself.  If you
        ///    call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
        ///    used for the <c>ZipEntry</c> within the zip archive will be different
        ///    than this path.
        ///  </para>
        ///
        ///  <para>
        ///   If the entry is being added from a stream, then this is null (Nothing in VB).
        ///  </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.FileName" />
        // Token: 0x1700007B RID: 123
        // (get) Token: 0x060001A1 RID: 417 RVA: 0x00008FDC File Offset: 0x000071DC
        internal string LocalFileName
        {
            get
            {
                return this._LocalFileName;
            }
        }

        /// <summary>
        ///   The name of the file contained in the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This is the name of the entry in the <c>ZipFile</c> itself.  When creating
        ///   a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
        ///   file, via a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />, or a related overload, the value
        ///   of this property is derived from the name of that file. The
        ///   <c>FileName</c> property does not include drive letters, and may include a
        ///   different directory path, depending on the value of the
        ///   <c>directoryPathInArchive</c> parameter used when adding the entry into
        ///   the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   In some cases there is no related filesystem file - for example when a
        ///   <c>ZipEntry</c> is created using <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" /> or one of the similar overloads.  In this case, the value of
        ///   this property is derived from the fileName and the directory path passed
        ///   to that method.
        /// </para>
        ///
        /// <para>
        ///   When reading a zip file, this property takes the value of the entry name
        ///   as stored in the zip file. If you extract such an entry, the extracted
        ///   file will take the name given by this property.
        /// </para>
        ///
        /// <para>
        ///   Applications can set this property when creating new zip archives or when
        ///   reading existing archives. When setting this property, the actual value
        ///   that is set will replace backslashes with forward slashes, in accordance
        ///   with <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
        ///   specification</see>, for compatibility with Unix(tm) and ... get
        ///   this.... Amiga!
        /// </para>
        ///
        /// <para>
        ///   If an application reads a <c>ZipFile</c> via <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> or a related overload, and then explicitly
        ///   sets the FileName on an entry contained within the <c>ZipFile</c>, and
        ///   then calls <see cref="M:Ionic.Zip.ZipFile.Save" />, the application will effectively
        ///   rename the entry within the zip archive.
        /// </para>
        ///
        /// <para>
        ///   If an application sets the value of <c>FileName</c>, then calls
        ///   <c>Extract()</c> on the entry, the entry is extracted to a file using the
        ///   newly set value as the filename.  The <c>FileName</c> value is made
        ///   permanent in the zip archive only <em>after</em> a call to one of the
        ///   <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
        ///   ZipEntry.
        /// </para>
        ///
        /// <para>
        ///   If an application attempts to set the <c>FileName</c> to a value that
        ///   would result in a duplicate entry in the <c>ZipFile</c>, an exception is
        ///   thrown.
        /// </para>
        ///
        /// <para>
        ///   When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
        ///   cannot rename the entry within the context of a <c>foreach</c> (<c>For
        ///   Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
        ///   entries.  If you need to enumerate through all the entries and rename one
        ///   or more of them, use <see cref="P:Ionic.Zip.ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
        ///   collection.  See also, <see cref="M:Ionic.Zip.ZipFile.GetEnumerator">ZipFile.GetEnumerator()</see>.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x1700007C RID: 124
        // (get) Token: 0x060001A2 RID: 418 RVA: 0x00008FF4 File Offset: 0x000071F4
        // (set) Token: 0x060001A3 RID: 419 RVA: 0x0000900C File Offset: 0x0000720C
        public string FileName
        {
            get
            {
                return this._FileNameInArchive;
            }
            set
            {
                if (this._container.ZipFile == null)
                {
                    throw new ZipException("Cannot rename; this is not supported in ZipOutputStream/ZipInputStream.");
                }
                if (string.IsNullOrEmpty(value))
                {
                    throw new ZipException("The FileName must be non empty and non-null.");
                }
                string filename = ZipEntry.NameInArchive(value, null);
                if (!(this._FileNameInArchive == filename))
                {
                    this._container.ZipFile.RemoveEntry(this);
                    this._container.ZipFile.InternalAddEntry(filename, this);
                    this._FileNameInArchive = filename;
                    this._container.ZipFile.NotifyEntryChanged();
                    this._metadataChanged = true;
                }
            }
        }

        /// <summary>
        /// The stream that provides content for the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   The application can use this property to set the input stream for an
        ///   entry on a just-in-time basis. Imagine a scenario where the application
        ///   creates a <c>ZipFile</c> comprised of content obtained from hundreds of
        ///   files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
        ///   on these files on a just-in-time basis, only when writing the entry out to
        ///   an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
        ///   one input stream is opened at a time, as each entry is being written out.
        /// </para>
        ///
        /// <para>
        ///   Now imagine a different application that creates a <c>ZipFile</c>
        ///   with content obtained from hundreds of streams, added through <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />.  Normally the
        ///   application would supply an open stream to that call.  But when large
        ///   numbers of streams are being added, this can mean many open streams at one
        ///   time, unnecessarily.
        /// </para>
        ///
        /// <para>
        ///   To avoid this, call <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" /> and specify delegates that open and close the stream at
        ///   the time of Save.
        /// </para>
        ///
        ///
        /// <para>
        ///   Setting the value of this property when the entry was not added from a
        ///   stream (for example, when the <c>ZipEntry</c> was added with <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />, or when the entry was added by
        ///   reading an existing zip archive) will throw an exception.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x1700007D RID: 125
        // (get) Token: 0x060001A4 RID: 420 RVA: 0x000090B4 File Offset: 0x000072B4
        // (set) Token: 0x060001A5 RID: 421 RVA: 0x000090CC File Offset: 0x000072CC
        public Stream InputStream
        {
            get
            {
                return this._sourceStream;
            }
            set
            {
                if (this._Source != ZipEntrySource.Stream)
                {
                    throw new ZipException("You must not set the input stream for this entry.");
                }
                this._sourceWasJitProvided = true;
                this._sourceStream = value;
            }
        }

        /// <summary>
        ///   A flag indicating whether the InputStream was provided Just-in-time.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When creating a zip archive, an application can obtain content for one or
        ///   more of the <c>ZipEntry</c> instances from streams, using the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" /> method.  At the time
        ///   of calling that method, the application can supply null as the value of
        ///   the stream parameter.  By doing so, the application indicates to the
        ///   library that it will provide a stream for the entry on a just-in-time
        ///   basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
        ///   the data for the various entries are being compressed and written out.
        /// </para>
        ///
        /// <para>
        ///   In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream" />
        ///   property, typically within the SaveProgress event (event type: <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry" />) for that entry.
        /// </para>
        ///
        /// <para>
        ///   The application will later want to call Close() and Dispose() on that
        ///   stream.  In the SaveProgress event, when the event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry" />, the application can
        ///   do so.  This flag indicates that the stream has been provided by the
        ///   application on a just-in-time basis and that it is the application's
        ///   responsibility to call Close/Dispose on that stream.
        /// </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
        // Token: 0x1700007E RID: 126
        // (get) Token: 0x060001A6 RID: 422 RVA: 0x00009100 File Offset: 0x00007300
        public bool InputStreamWasJitProvided
        {
            get
            {
                return this._sourceWasJitProvided;
            }
        }

        /// <summary>
        /// An enum indicating the source of the ZipEntry.
        /// </summary>
        // Token: 0x1700007F RID: 127
        // (get) Token: 0x060001A7 RID: 423 RVA: 0x00009118 File Offset: 0x00007318
        public ZipEntrySource Source
        {
            get
            {
                return this._Source;
            }
        }

        /// <summary>
        /// The version of the zip engine needed to read the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is a readonly property, indicating the version of <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
        ///   specification</a> that the extracting tool or library must support to
        ///   extract the given entry.  Generally higher versions indicate newer
        ///   features.  Older zip engines obviously won't know about new features, and
        ///   won't be able to extract entries that depend on those newer features.
        /// </para>
        ///
        /// <list type="table">
        /// <listheader>
        /// <term>value</term>
        /// <description>Features</description>
        /// </listheader>
        ///
        /// <item>
        /// <term>20</term>
        /// <description>a basic Zip Entry, potentially using PKZIP encryption.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>45</term>
        /// <description>The ZIP64 extension is used on the entry.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>46</term>
        /// <description> File is compressed using BZIP2 compression*</description>
        /// </item>
        ///
        /// <item>
        /// <term>50</term>
        /// <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
        /// </item>
        ///
        /// <item>
        /// <term>51</term>
        /// <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
        /// </item>
        ///
        /// <item>
        /// <term>52</term>
        /// <description> File is encrypted using corrected RC2-64 encryption**</description>
        /// </item>
        ///
        /// <item>
        /// <term>61</term>
        /// <description> File is encrypted using non-OAEP key wrapping***</description>
        /// </item>
        ///
        /// <item>
        /// <term>63</term>
        /// <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
        /// </item>
        ///
        /// </list>
        ///
        /// <para>
        ///   There are other values possible, not listed here. DotNetZip supports
        ///   regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
        ///   entries that require a zip engine higher than 45.
        /// </para>
        ///
        /// <para>
        ///   This value is set upon reading an existing zip file, or after saving a zip
        ///   archive.
        /// </para>
        /// </remarks>
        // Token: 0x17000080 RID: 128
        // (get) Token: 0x060001A8 RID: 424 RVA: 0x00009130 File Offset: 0x00007330
        public short VersionNeeded
        {
            get
            {
                return this._VersionNeeded;
            }
        }

        /// <summary>
        /// The comment attached to the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Each entry in a zip file can optionally have a comment associated to
        ///   it. The comment might be displayed by a zip tool during extraction, for
        ///   example.
        /// </para>
        ///
        /// <para>
        ///   By default, the <c>Comment</c> is encoded in IBM437 code page. You can
        ///   specify an alternative with <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" /> and
        ///  <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" />.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" />
        // Token: 0x17000081 RID: 129
        // (get) Token: 0x060001A9 RID: 425 RVA: 0x00009148 File Offset: 0x00007348
        // (set) Token: 0x060001AA RID: 426 RVA: 0x00009160 File Offset: 0x00007360
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this._Comment = value;
                this._metadataChanged = true;
            }
        }

        /// <summary>
        /// Indicates whether the entry requires ZIP64 extensions.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This property is null (Nothing in VB) until a <c>Save()</c> method on the
        ///   containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been called. The property is
        ///   non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
        ///   been called.
        /// </para>
        ///
        /// <para>
        ///   After the containing <c>ZipFile</c> has been saved, the Value of this
        ///   property is true if any of the following three conditions holds: the
        ///   uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
        ///   size of the entry is larger than 0xFFFFFFFF; the relative offset of the
        ///   entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
        ///   are not known until a <c>Save()</c> is attempted on the zip archive and
        ///   the compression is applied.
        /// </para>
        ///
        /// <para>
        ///   If none of the three conditions holds, then the <c>Value</c> is false.
        /// </para>
        ///
        /// <para>
        ///   A <c>Value</c> of false does not indicate that the entry, as saved in the
        ///   zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
        ///   <em>not required</em>.  An entry may use ZIP64 even when not required if
        ///   the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing
        ///   <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if
        ///   the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing
        ///   <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" />
        ///   and the output stream was not seekable.
        /// </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64" />
        // Token: 0x17000082 RID: 130
        // (get) Token: 0x060001AB RID: 427 RVA: 0x00009174 File Offset: 0x00007374
        public bool? RequiresZip64
        {
            get
            {
                return this._entryRequiresZip64;
            }
        }

        /// <summary>
        ///   Indicates whether the entry actually used ZIP64 extensions, as it was most
        ///   recently written to the output file or stream.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This Nullable property is null (Nothing in VB) until a <c>Save()</c>
        ///   method on the containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been
        ///   called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
        ///   called.
        /// </para>
        ///
        /// <para>
        ///   The value of this property for a particular <c>ZipEntry</c> may change
        ///   over successive calls to <c>Save()</c> methods on the containing ZipFile,
        ///   even if the file that corresponds to the <c>ZipEntry</c> does not. This
        ///   may happen if other entries contained in the <c>ZipFile</c> expand,
        ///   causing the offset for this particular entry to exceed 0xFFFFFFFF.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64" />
        // Token: 0x17000083 RID: 131
        // (get) Token: 0x060001AC RID: 428 RVA: 0x0000918C File Offset: 0x0000738C
        public bool? OutputUsedZip64
        {
            get
            {
                return this._OutputUsesZip64;
            }
        }

        /// <summary>
        ///   The bitfield for the entry as defined in the zip spec. You probably
        ///   never need to look at this.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   You probably do not need to concern yourself with the contents of this
        ///   property, but in case you do:
        /// </para>
        ///
        /// <list type="table">
        /// <listheader>
        /// <term>bit</term>
        /// <description>meaning</description>
        /// </listheader>
        ///
        /// <item>
        /// <term>0</term>
        /// <description>set if encryption is used.</description>
        /// </item>
        ///
        /// <item>
        /// <term>1-2</term>
        /// <description>
        /// set to determine whether normal, max, fast deflation.  DotNetZip library
        /// always leaves these bits unset when writing (indicating "normal"
        /// deflation"), but can read an entry with any value here.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>3</term>
        /// <description>
        /// Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
        /// local header.  This bit gets set on an entry during writing a zip file, when
        /// it is saved to a non-seekable output stream.
        /// </description>
        /// </item>
        ///
        ///
        /// <item>
        /// <term>4</term>
        /// <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
        /// </item>
        ///
        /// <item>
        /// <term>5</term>
        /// <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
        /// </item>
        ///
        /// <item>
        /// <term>6</term>
        /// <description>
        /// set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
        /// set). This bit is not set if WinZip's AES encryption is set.</description>
        /// </item>
        ///
        /// <item>
        /// <term>7</term>
        /// <description>not used</description>
        /// </item>
        ///
        /// <item>
        /// <term>8</term>
        /// <description>not used</description>
        /// </item>
        ///
        /// <item>
        /// <term>9</term>
        /// <description>not used</description>
        /// </item>
        ///
        /// <item>
        /// <term>10</term>
        /// <description>not used</description>
        /// </item>
        ///
        /// <item>
        /// <term>11</term>
        /// <description>
        /// Language encoding flag (EFS).  If this bit is set, the filename and comment
        /// fields for this file must be encoded using UTF-8. This library currently
        /// does not support UTF-8.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>12</term>
        /// <description>Reserved by PKWARE for enhanced compression.</description>
        /// </item>
        ///
        /// <item>
        /// <term>13</term>
        /// <description>
        ///   Used when encrypting the Central Directory to indicate selected data
        ///   values in the Local Header are masked to hide their actual values.  See
        ///   the section in <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
        ///   specification</a> describing the Strong Encryption Specification for
        ///   details.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>14</term>
        /// <description>Reserved by PKWARE.</description>
        /// </item>
        ///
        /// <item>
        /// <term>15</term>
        /// <description>Reserved by PKWARE.</description>
        /// </item>
        ///
        /// </list>
        ///
        /// </remarks>
        // Token: 0x17000084 RID: 132
        // (get) Token: 0x060001AD RID: 429 RVA: 0x000091A4 File Offset: 0x000073A4
        public short BitField
        {
            get
            {
                return this._BitField;
            }
        }

        /// <summary>
        ///   The compression method employed for this ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
        ///   Zip specification</see> allows a variety of compression methods.  This
        ///   library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
        ///   for reading or writing.
        /// </para>
        ///
        /// <para>
        ///   When reading an entry from an existing zipfile, the value you retrieve
        ///   here indicates the compression method used on the entry by the original
        ///   creator of the zip.  When writing a zipfile, you can specify either 0x08
        ///   (Deflate) or 0x00 (None).  If you try setting something else, you will get
        ///   an exception.
        /// </para>
        ///
        /// <para>
        ///   You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
        ///   when zipping already-compressed data like a jpg, png, or mp3 file.
        ///   This can save time and cpu cycles.
        /// </para>
        ///
        /// <para>
        ///   When setting this property on a <c>ZipEntry</c> that is read from an
        ///   existing zip file, calling <c>ZipFile.Save()</c> will cause the new
        ///   CompressionMethod to be used on the entry in the newly saved zip file.
        /// </para>
        ///
        /// <para>
        ///   Setting this property may have the side effect of modifying the
        ///   <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
        ///   value other than <c>None</c>, and <c>CompressionLevel</c> is previously
        ///   set to <c>None</c>, then <c>CompressionLevel</c> will be set to
        ///   <c>Default</c>.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
        ///
        /// <example>
        ///   In this example, the first entry added to the zip archive uses the default
        ///   behavior - compression is used where it makes sense.  The second entry,
        ///   the MP3 file, is added to the archive without being compressed.
        /// <code>
        /// using (ZipFile zip = new ZipFile(ZipFileToCreate))
        /// {
        ///   ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
        ///   ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
        ///   e2.CompressionMethod = CompressionMethod.None;
        ///   zip.Save();
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile(ZipFileToCreate)
        ///   zip.AddFile("notes\Readme.txt")
        ///   Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
        ///   e2.CompressionMethod = CompressionMethod.None
        ///   zip.Save
        /// End Using
        /// </code>
        /// </example>
        // Token: 0x17000085 RID: 133
        // (get) Token: 0x060001AE RID: 430 RVA: 0x000091BC File Offset: 0x000073BC
        // (set) Token: 0x060001AF RID: 431 RVA: 0x000091D4 File Offset: 0x000073D4
        public CompressionMethod CompressionMethod
        {
            get
            {
                return (CompressionMethod)this._CompressionMethod;
            }
            set
            {
                if (value != (CompressionMethod)this._CompressionMethod)
                {
                    if (value != CompressionMethod.None && value != CompressionMethod.Deflate && value != CompressionMethod.BZip2)
                    {
                        throw new InvalidOperationException("Unsupported compression method.");
                    }
                    this._CompressionMethod = (short)value;
                    if (this._CompressionMethod == 0)
                    {
                        this._CompressionLevel = CompressionLevel.None;
                    }
                    else if (this.CompressionLevel == CompressionLevel.None)
                    {
                        this._CompressionLevel = CompressionLevel.Default;
                    }
                    if (this._container.ZipFile != null)
                    {
                        this._container.ZipFile.NotifyEntryChanged();
                    }
                    this._restreamRequiredOnSave = true;
                }
            }
        }

        /// <summary>
        ///   Sets the compression level to be used for the entry when saving the zip
        ///   archive. This applies only for CompressionMethod = DEFLATE.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    When using the DEFLATE compression method, Varying the compression
        ///    level used on entries can affect the size-vs-speed tradeoff when
        ///    compression and decompressing data streams or files.
        ///  </para>
        ///
        ///  <para>
        ///    If you do not set this property, the default compression level is used,
        ///    which normally gives a good balance of compression efficiency and
        ///    compression speed.  In some tests, using <c>BestCompression</c> can
        ///    double the time it takes to compress, while delivering just a small
        ///    increase in compression efficiency.  This behavior will vary with the
        ///    type of data you compress.  If you are in doubt, just leave this setting
        ///    alone, and accept the default.
        ///  </para>
        ///
        ///  <para>
        ///    When setting this property on a <c>ZipEntry</c> that is read from an
        ///    existing zip file, calling <c>ZipFile.Save()</c> will cause the new
        ///    <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
        ///  </para>
        ///
        ///  <para>
        ///    Setting this property may have the side effect of modifying the
        ///    <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
        ///    to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
        ///    to <c>Deflate</c>, if it was previously <c>None</c>.
        ///  </para>
        ///
        ///  <para>
        ///    Setting this property has no effect if the <c>CompressionMethod</c> is something
        ///    other than <c>Deflate</c> or <c>None</c>.
        ///  </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
        // Token: 0x17000086 RID: 134
        // (get) Token: 0x060001B0 RID: 432 RVA: 0x00009278 File Offset: 0x00007478
        // (set) Token: 0x060001B1 RID: 433 RVA: 0x00009290 File Offset: 0x00007490
        public CompressionLevel CompressionLevel
        {
            get
            {
                return this._CompressionLevel;
            }
            set
            {
                if (this._CompressionMethod == 8 || this._CompressionMethod == 0)
                {
                    if (value != CompressionLevel.Default || this._CompressionMethod != 8)
                    {
                        this._CompressionLevel = value;
                        if (value != CompressionLevel.None || this._CompressionMethod != 0)
                        {
                            if (this._CompressionLevel == CompressionLevel.None)
                            {
                                this._CompressionMethod = 0;
                            }
                            else
                            {
                                this._CompressionMethod = 8;
                            }
                            if (this._container.ZipFile != null)
                            {
                                this._container.ZipFile.NotifyEntryChanged();
                            }
                            this._restreamRequiredOnSave = true;
                        }
                    }
                }
            }
        }

        /// <summary>
        ///   The compressed size of the file, in bytes, within the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///   When reading a <c>ZipFile</c>, this value is read in from the existing
        ///   zip file. When creating or updating a <c>ZipFile</c>, the compressed
        ///   size is computed during compression.  Therefore the value on a
        ///   <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
        ///   overloads) in that case.
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize" />
        // Token: 0x17000087 RID: 135
        // (get) Token: 0x060001B2 RID: 434 RVA: 0x00009340 File Offset: 0x00007540
        public long CompressedSize
        {
            get
            {
                return this._CompressedSize;
            }
        }

        /// <summary>
        ///   The size of the file, in bytes, before compression, or after extraction.
        /// </summary>
        ///
        /// <remarks>
        ///   When reading a <c>ZipFile</c>, this value is read in from the existing
        ///   zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
        ///   size is computed during compression.  Therefore the value on a
        ///   <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
        ///   overloads) in that case.
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize" />
        // Token: 0x17000088 RID: 136
        // (get) Token: 0x060001B3 RID: 435 RVA: 0x00009358 File Offset: 0x00007558
        public long UncompressedSize
        {
            get
            {
                return this._UncompressedSize;
            }
        }

        /// <summary>
        /// The ratio of compressed size to uncompressed size of the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is a ratio of the compressed size to the uncompressed size of the
        ///   entry, expressed as a double in the range of 0 to 100+. A value of 100
        ///   indicates no compression at all.  It could be higher than 100 when the
        ///   compression algorithm actually inflates the data, as may occur for small
        ///   files, or uncompressible data that is encrypted.
        /// </para>
        ///
        /// <para>
        ///   You could format it for presentation to a user via a format string of
        ///   "{3,5:F0}%" to see it as a percentage.
        /// </para>
        ///
        /// <para>
        ///   If the size of the original uncompressed file is 0, implying a
        ///   denominator of 0, the return value will be zero.
        /// </para>
        ///
        /// <para>
        ///   This property is valid after reading in an existing zip file, or after
        ///   saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
        ///   effect of a compression transform until you try it.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000089 RID: 137
        // (get) Token: 0x060001B4 RID: 436 RVA: 0x00009370 File Offset: 0x00007570
        public double CompressionRatio
        {
            get
            {
                double result;
                if (this.UncompressedSize == 0L)
                {
                    result = 0.0;
                }
                else
                {
                    result = 100.0 * (1.0 - 1.0 * (double)this.CompressedSize / (1.0 * (double)this.UncompressedSize));
                }
                return result;
            }
        }

        /// <summary>
        /// The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para> You probably don't need to concern yourself with this. It is used
        /// internally by DotNetZip to verify files or streams upon extraction.  </para>
        ///
        /// <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
        /// CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
        /// PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
        /// creating a Zip archive, the CRC for each entry is set only after a call to
        /// <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
        /// of this property reflects the stored CRC for the entry.  </para>
        ///
        /// </remarks>
        // Token: 0x1700008A RID: 138
        // (get) Token: 0x060001B5 RID: 437 RVA: 0x000093D8 File Offset: 0x000075D8
        public int Crc
        {
            get
            {
                return this._Crc32;
            }
        }

        /// <summary>
        /// True if the entry is a directory (not a file).
        /// This is a readonly property on the entry.
        /// </summary>
        // Token: 0x1700008B RID: 139
        // (get) Token: 0x060001B6 RID: 438 RVA: 0x000093F0 File Offset: 0x000075F0
        public bool IsDirectory
        {
            get
            {
                return this._IsDirectory;
            }
        }

        /// <summary>
        /// A derived property that is <c>true</c> if the entry uses encryption.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is a readonly property on the entry.  When reading a zip file,
        ///   the value for the <c>ZipEntry</c> is determined by the data read
        ///   from the zip file.  After saving a ZipFile, the value of this
        ///   property for each <c>ZipEntry</c> indicates whether encryption was
        ///   actually used (which will have been true if the <see cref="P:Ionic.Zip.ZipEntry.Password" /> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property
        ///   was something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" />.
        /// </para>
        /// </remarks>
        // Token: 0x1700008C RID: 140
        // (get) Token: 0x060001B7 RID: 439 RVA: 0x00009408 File Offset: 0x00007608
        public bool UsesEncryption
        {
            get
            {
                return this._Encryption_FromZipFile != EncryptionAlgorithm.None;
            }
        }

        /// <summary>
        ///   Set this to specify which encryption algorithm to use for the entry when
        ///   saving it to a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Set this property in order to encrypt the entry when the <c>ZipFile</c> is
        ///   saved. When setting this property, you must also set a <see cref="P:Ionic.Zip.ZipEntry.Password" /> on the entry.  If you set a value other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" /> on this property and do not set a
        ///   <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
        ///   data is encrypted as the <c>ZipFile</c> is saved, when you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins on the containing
        ///   <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
        ///   when extracting entries from an archive.
        /// </para>
        ///
        /// <para>
        ///   The Zip specification from PKWare defines a set of encryption algorithms,
        ///   and the data formats for the zip archive that support them, and PKWare
        ///   supports those algorithms in the tools it produces. Other vendors of tools
        ///   and libraries, such as WinZip or Xceed, typically support <em>a
        ///   subset</em> of the algorithms specified by PKWare. These tools can
        ///   sometimes support additional different encryption algorithms and data
        ///   formats, not specified by PKWare. The AES Encryption specified and
        ///   supported by WinZip is the most popular example. This library supports a
        ///   subset of the complete set of algorithms specified by PKWare and other
        ///   vendors.
        /// </para>
        ///
        /// <para>
        ///   There is no common, ubiquitous multi-vendor standard for strong encryption
        ///   within zip files. There is broad support for so-called "traditional" Zip
        ///   encryption, sometimes called Zip 2.0 encryption, as <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
        ///   by PKWare</see>, but this encryption is considered weak and
        ///   breakable. This library currently supports the Zip 2.0 "weak" encryption,
        ///   and also a stronger WinZip-compatible AES encryption, using either 128-bit
        ///   or 256-bit key strength. If you want DotNetZip to support an algorithm
        ///   that is not currently supported, call the author of this library and maybe
        ///   we can talk business.
        /// </para>
        ///
        /// <para>
        ///   The <see cref="T:Ionic.Zip.ZipFile" /> class also has a <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property.  In most cases you will use
        ///   <em>that</em> property when setting encryption. This property takes
        ///   precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
        ///   Typically, you would use the per-entry Encryption when most entries in the
        ///   zip archive use one encryption algorithm, and a few entries use a
        ///   different one.  If all entries in the zip file use the same Encryption,
        ///   then it is simpler to just set this property on the ZipFile itself, when
        ///   creating a zip archive.
        /// </para>
        ///
        /// <para>
        ///   Some comments on updating archives: If you read a <c>ZipFile</c>, you can
        ///   modify the Encryption on an encrypted entry: you can remove encryption
        ///   from an entry that was encrypted; you can encrypt an entry that was not
        ///   encrypted previously; or, you can change the encryption algorithm.  The
        ///   changes in encryption are not made permanent until you call Save() on the
        ///   <c>ZipFile</c>.  To effect changes in encryption, the entry content is
        ///   streamed through several transformations, depending on the modification
        ///   the application has requested. For example if the entry is not encrypted
        ///   and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
        ///   the time of <c>Save()</c>, the original entry is read and decompressed,
        ///   then re-compressed and encrypted.  Conversely, if the original entry is
        ///   encrypted with <c>PkzipWeak</c> encryption, and the application sets the
        ///   <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
        ///   <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
        ///   decompressed, then re-compressed and re-encrypted with AES.  This all
        ///   happens automatically within the library, but it can be time-consuming for
        ///   large entries.
        /// </para>
        ///
        /// <para>
        ///   Additionally, when updating archives, it is not possible to change the
        ///   password when changing the encryption algorithm.  To change both the
        ///   algorithm and the password, you need to Save() the zipfile twice.  First
        ///   set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
        ///   <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
        ///   once again.
        /// </para>
        ///
        /// <para>
        ///   The WinZip AES encryption algorithms are not supported on the .NET Compact
        ///   Framework.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example creates a zip archive that uses encryption, and then extracts
        ///   entries from the archive.  When creating the zip archive, the ReadMe.txt
        ///   file is zipped without using a password or encryption.  The other file
        ///   uses encryption.
        /// </para>
        /// <code>
        /// // Create a zip archive with AES Encryption.
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddFile("ReadMe.txt")
        ///     ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
        ///     e1.Encryption= EncryptionAlgorithm.WinZipAes256;
        ///     e1.Password= "Top.Secret.No.Peeking!";
        ///     zip.Save("EncryptedArchive.zip");
        /// }
        ///
        /// // Extract a zip archive that uses AES Encryption.
        /// // You do not need to specify the algorithm during extraction.
        /// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
        /// {
        ///     // Specify the password that is used during extraction, for
        ///     // all entries that require a password:
        ///     zip.Password= "Top.Secret.No.Peeking!";
        ///     zip.ExtractAll("extractDirectory");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// ' Create a zip that uses Encryption.
        /// Using zip As New ZipFile()
        ///     zip.AddFile("ReadMe.txt")
        ///     Dim e1 as ZipEntry
        ///     e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
        ///     e1.Encryption= EncryptionAlgorithm.WinZipAes256
        ///     e1.Password= "Top.Secret.No.Peeking!"
        ///     zip.Save("EncryptedArchive.zip")
        /// End Using
        ///
        /// ' Extract a zip archive that uses AES Encryption.
        /// ' You do not need to specify the algorithm during extraction.
        /// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
        ///     ' Specify the password that is used during extraction, for
        ///     ' all entries that require a password:
        ///     zip.Password= "Top.Secret.No.Peeking!"
        ///     zip.ExtractAll("extractDirectory")
        /// End Using
        /// </code>
        ///
        /// </example>
        ///
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
        /// </exception>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        /// <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        // Token: 0x1700008D RID: 141
        // (get) Token: 0x060001B8 RID: 440 RVA: 0x00009428 File Offset: 0x00007628
        // (set) Token: 0x060001B9 RID: 441 RVA: 0x00009440 File Offset: 0x00007640
        public EncryptionAlgorithm Encryption
        {
            get
            {
                return this._Encryption;
            }
            set
            {
                if (value != this._Encryption)
                {
                    if (value == EncryptionAlgorithm.Unsupported)
                    {
                        throw new InvalidOperationException("You may not set Encryption to that value.");
                    }
                    this._Encryption = value;
                    this._restreamRequiredOnSave = true;
                    if (this._container.ZipFile != null)
                    {
                        this._container.ZipFile.NotifyEntryChanged();
                    }
                }
            }
        }

        /// <summary>
        /// The Password to be used when encrypting a <c>ZipEntry</c> upon
        /// <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is a write-only property on the entry. Set this to request that the
        ///   entry be encrypted when writing the zip archive, or set it to specify the
        ///   password to be used when extracting an existing entry that is encrypted.
        /// </para>
        ///
        /// <para>
        ///   The password set here is implicitly used to encrypt the entry during the
        ///   <see cref="M:Ionic.Zip.ZipFile.Save" /> operation, or to decrypt during the <see cref="M:Ionic.Zip.ZipEntry.Extract" /> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> operation.  If you set
        ///   the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
        ///   effect.
        /// </para>
        ///
        /// <para>
        ///   Consider setting the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property when using a
        ///   password. Answering concerns that the standard password protection
        ///   supported by all zip tools is weak, WinZip has extended the ZIP
        ///   specification with a way to use AES Encryption to protect entries in the
        ///   Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
        ///   specification, <see href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
        ///   Encryption</see> uses a standard, strong, tested, encryption
        ///   algorithm. DotNetZip can create zip archives that use WinZip-compatible
        ///   AES encryption, if you set the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property. But,
        ///   archives created that use AES encryption may not be readable by all other
        ///   tools and libraries. For example, Windows Explorer cannot read a
        ///   "compressed folder" (a zip file) that uses AES encryption, though it can
        ///   read a zip file that uses "PKZIP encryption."
        /// </para>
        ///
        /// <para>
        ///   The <see cref="T:Ionic.Zip.ZipFile" /> class also has a <see cref="P:Ionic.Zip.ZipFile.Password" />
        ///   property.  This property takes precedence over any password set on the
        ///   ZipFile itself.  Typically, you would use the per-entry Password when most
        ///   entries in the zip archive use one password, and a few entries use a
        ///   different password.  If all entries in the zip file use the same password,
        ///   then it is simpler to just set this property on the ZipFile itself,
        ///   whether creating a zip archive or extracting a zip archive.
        /// </para>
        ///
        /// <para>
        ///   Some comments on updating archives: If you read a <c>ZipFile</c>, you
        ///   cannot modify the password on any encrypted entry, except by extracting
        ///   the entry with the original password (if any), removing the original entry
        ///   via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)" />, and then adding a new
        ///   entry with a new Password.
        /// </para>
        ///
        /// <para>
        ///   For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
        ///   entry.  Setting the Password property on that <c>ZipEntry</c> and then
        ///   calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
        ///   on that entry in the archive.  Neither is an exception thrown. Instead,
        ///   what happens during the <c>Save()</c> is the existing entry is copied
        ///   through to the new zip archive, in its original encrypted form. Upon
        ///   re-reading that archive, the entry can be decrypted with its original
        ///   password.
        /// </para>
        ///
        /// <para>
        ///   If you read a ZipFile, and there is an un-encrypted entry, you can set the
        ///   <c>Password</c> on the entry and then call Save() on the ZipFile, and get
        ///   encryption on that entry.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example creates a zip file with two entries, and then extracts the
        ///   entries from the zip file.  When creating the zip file, the two files are
        ///   added to the zip file using password protection. Each entry uses a
        ///   different password.  During extraction, each file is extracted with the
        ///   appropriate password.
        /// </para>
        /// <code>
        /// // create a file with encryption
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     ZipEntry entry;
        ///     entry= zip.AddFile("Declaration.txt");
        ///     entry.Password= "123456!";
        ///     entry = zip.AddFile("Report.xls");
        ///     entry.Password= "1Secret!";
        ///     zip.Save("EncryptedArchive.zip");
        /// }
        ///
        /// // extract entries that use encryption
        /// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
        /// {
        ///     ZipEntry entry;
        ///     entry = zip["Declaration.txt"];
        ///     entry.Password = "123456!";
        ///     entry.Extract("extractDir");
        ///     entry = zip["Report.xls"];
        ///     entry.Password = "1Secret!";
        ///     entry.Extract("extractDir");
        /// }
        ///
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     Dim entry as ZipEntry
        ///     entry= zip.AddFile("Declaration.txt")
        ///     entry.Password= "123456!"
        ///     entry = zip.AddFile("Report.xls")
        ///     entry.Password= "1Secret!"
        ///     zip.Save("EncryptedArchive.zip")
        /// End Using
        ///
        ///
        /// ' extract entries that use encryption
        /// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
        ///     Dim entry as ZipEntry
        ///     entry = zip("Declaration.txt")
        ///     entry.Password = "123456!"
        ///     entry.Extract("extractDir")
        ///     entry = zip("Report.xls")
        ///     entry.Password = "1Secret!"
        ///     entry.Extract("extractDir")
        /// End Using
        ///
        /// </code>
        ///
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.Encryption" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        // Token: 0x1700008E RID: 142
        // (get) Token: 0x060001BB RID: 443 RVA: 0x00009510 File Offset: 0x00007710
        // (set) Token: 0x060001BA RID: 442 RVA: 0x000094A8 File Offset: 0x000076A8
        public string Password
        {
            private get
            {
                return this._Password;
            }
            set
            {
                this._Password = value;
                if (this._Password == null)
                {
                    this._Encryption = EncryptionAlgorithm.None;
                }
                else
                {
                    if (this._Source == ZipEntrySource.ZipFile && !this._sourceIsEncrypted)
                    {
                        this._restreamRequiredOnSave = true;
                    }
                    if (this.Encryption == EncryptionAlgorithm.None)
                    {
                        this._Encryption = EncryptionAlgorithm.PkzipWeak;
                    }
                }
            }
        }

        // Token: 0x1700008F RID: 143
        // (get) Token: 0x060001BC RID: 444 RVA: 0x00009528 File Offset: 0x00007728
        internal bool IsChanged
        {
            get
            {
                return this._restreamRequiredOnSave | this._metadataChanged;
            }
        }

        /// <summary>
        /// The action the library should take when extracting a file that already exists.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     This property affects the behavior of the Extract methods (one of the
        ///     <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
        ///     extraction would would overwrite an existing filesystem file. If you do
        ///     not set this property, the library throws an exception when extracting
        ///     an entry would overwrite an existing file.
        ///   </para>
        ///
        ///   <para>
        ///     This property has no effect when extracting to a stream, or when the file to be
        ///     extracted does not already exist.
        ///   </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
        ///
        /// <example>
        ///   This example shows how to set the <c>ExtractExistingFile</c> property in
        ///   an <c>ExtractProgress</c> event, in response to user input. The
        ///   <c>ExtractProgress</c> event is invoked if and only if the
        ///   <c>ExtractExistingFile</c> property was previously set to
        ///   <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
        /// <code lang="C#">
        /// public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
        /// {
        ///     if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
        ///         Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
        ///
        ///     else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
        ///     {
        ///         ZipEntry entry = e.CurrentEntry;
        ///         string response = null;
        ///         // Ask the user if he wants overwrite the file
        ///         do
        ///         {
        ///             Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
        ///             response = Console.ReadLine();
        ///             Console.WriteLine();
        ///
        ///         } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
        ///                  response[0]!='N' &amp;&amp; response[0]!='C');
        ///
        ///         if  (response[0]=='C')
        ///             e.Cancel = true;
        ///         else if (response[0]=='Y')
        ///             entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
        ///         else
        ///             entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
        ///     }
        /// }
        /// </code>
        /// </example>
        // Token: 0x17000090 RID: 144
        // (get) Token: 0x060001BD RID: 445 RVA: 0x00009548 File Offset: 0x00007748
        // (set) Token: 0x060001BE RID: 446 RVA: 0x0000955F File Offset: 0x0000775F
        public ExtractExistingFileAction ExtractExistingFile { get; set; }

        /// <summary>
        ///   The action to take when an error is encountered while
        ///   opening or reading files as they are saved into a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///     Errors can occur within a call to <see cref="M:Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
        ///     in a ZipFile are being saved into the zip archive.  During the
        ///     <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
        ///     associated to the ZipEntry, and then will read the entire contents of
        ///     the file as it is zipped. Either the open or the Read may fail, because
        ///     of lock conflicts or other reasons.  Using this property, you can
        ///     specify the action to take when such errors occur.
        ///  </para>
        ///
        ///  <para>
        ///     Typically you will NOT set this property on individual ZipEntry
        ///     instances.  Instead, you will set the <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
        ///     the ZipFile instance, before adding any entries to the
        ///     <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
        ///     the entries in the ZipFile will be handled the same way.
        ///  </para>
        ///
        ///  <para>
        ///     But, if you use a <see cref="E:Ionic.Zip.ZipFile.ZipError" /> handler, you will want
        ///     to set this property on the <c>ZipEntry</c> within the handler, to
        ///     communicate back to DotNetZip what you would like to do with the
        ///     particular error.
        ///  </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ZipError" />
        // Token: 0x17000091 RID: 145
        // (get) Token: 0x060001BF RID: 447 RVA: 0x00009568 File Offset: 0x00007768
        // (set) Token: 0x060001C0 RID: 448 RVA: 0x0000957F File Offset: 0x0000777F
        public ZipErrorAction ZipErrorAction { get; set; }

        /// <summary>
        /// Indicates whether the entry was included in the most recent save.
        /// </summary>
        /// <remarks>
        /// An entry can be excluded or skipped from a save if there is an error
        /// opening or reading the entry.
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" />
        // Token: 0x17000092 RID: 146
        // (get) Token: 0x060001C1 RID: 449 RVA: 0x00009588 File Offset: 0x00007788
        public bool IncludedInMostRecentSave
        {
            get
            {
                return !this._skippedDuringSave;
            }
        }

        /// <summary>
        ///   A callback that allows the application to specify the compression to use
        ///   for a given entry that is about to be added to the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See <see cref="P:Ionic.Zip.ZipFile.SetCompression" />
        /// </para>
        /// </remarks>
        // Token: 0x17000093 RID: 147
        // (get) Token: 0x060001C2 RID: 450 RVA: 0x000095A4 File Offset: 0x000077A4
        // (set) Token: 0x060001C3 RID: 451 RVA: 0x000095BB File Offset: 0x000077BB
        public SetCompressionCallback SetCompression { get; set; }

        /// <summary>
        ///   Set to indicate whether to use UTF-8 encoding for filenames and comments.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   If this flag is set, the comment and filename for the entry will be
        ///   encoded with UTF-8, as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
        ///   specification</see>, if necessary. "Necessary" means, the filename or
        ///   entry comment (if any) cannot be reflexively encoded and decoded using the
        ///   default code page, IBM437.
        /// </para>
        ///
        /// <para>
        ///   Setting this flag to true is equivalent to setting <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /> to <c>System.Text.Encoding.UTF8</c>.
        /// </para>
        ///
        /// <para>
        ///   This flag has no effect or relation to the text encoding used within the
        ///   file itself.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000094 RID: 148
        // (get) Token: 0x060001C4 RID: 452 RVA: 0x000095C4 File Offset: 0x000077C4
        // (set) Token: 0x060001C5 RID: 453 RVA: 0x000095F4 File Offset: 0x000077F4
        [Obsolete("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
        public bool UseUnicodeAsNecessary
        {
            get
            {
                return this.AlternateEncoding == Encoding.GetEncoding("UTF-8") && this.AlternateEncodingUsage == ZipOption.AsNecessary;
            }
            set
            {
                if (value)
                {
                    this.AlternateEncoding = Encoding.GetEncoding("UTF-8");
                    this.AlternateEncodingUsage = ZipOption.AsNecessary;
                }
                else
                {
                    this.AlternateEncoding = ZipFile.DefaultEncoding;
                    this.AlternateEncodingUsage = ZipOption.Default;
                }
            }
        }

        /// <summary>
        ///   The text encoding to use for the FileName and Comment on this ZipEntry,
        ///   when the default encoding is insufficient.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Don't use this property.  See <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" />.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000095 RID: 149
        // (get) Token: 0x060001C6 RID: 454 RVA: 0x00009640 File Offset: 0x00007840
        // (set) Token: 0x060001C7 RID: 455 RVA: 0x00009657 File Offset: 0x00007857
        [Obsolete("This property is obsolete since v1.9.1.6. Use AlternateEncoding and AlternateEncodingUsage instead.", true)]
        public Encoding ProvisionalAlternateEncoding { get; set; }

        /// <summary>
        ///   Specifies the alternate text encoding used by this ZipEntry
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     The default text encoding used in Zip files for encoding filenames and
        ///     comments is IBM437, which is something like a superset of ASCII.  In
        ///     cases where this is insufficient, applications can specify an
        ///     alternate encoding.
        ///   </para>
        ///   <para>
        ///     When creating a zip file, the usage of the alternate encoding is
        ///     governed by the <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" /> property.
        ///     Typically you would set both properties to tell DotNetZip to employ an
        ///     encoding that is not IBM437 in the zipfile you are creating.
        ///   </para>
        ///   <para>
        ///     Keep in mind that because the ZIP specification states that the only
        ///     valid encodings to use are IBM437 and UTF-8, if you use something
        ///     other than that, then zip tools and libraries may not be able to
        ///     successfully read the zip archive you generate.
        ///   </para>
        ///   <para>
        ///     The zip specification states that applications should presume that
        ///     IBM437 is in use, except when a special bit is set, which indicates
        ///     UTF-8. There is no way to specify an arbitrary code page, within the
        ///     zip file itself. When you create a zip file encoded with gb2312 or
        ///     ibm861 or anything other than IBM437 or UTF-8, then the application
        ///     that reads the zip file needs to "know" which code page to use. In
        ///     some cases, the code page used when reading is chosen implicitly. For
        ///     example, WinRar uses the ambient code page for the host desktop
        ///     operating system. The pitfall here is that if you create a zip in
        ///     Copenhagen and send it to Tokyo, the reader of the zipfile may not be
        ///     able to decode successfully.
        ///   </para>
        /// </remarks>
        /// <example>
        ///   This example shows how to create a zipfile encoded with a
        ///   language-specific encoding:
        /// <code>
        ///   using (var zip = new ZipFile())
        ///   {
        ///      zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
        ///      zip.AlternateEnodingUsage = ZipOption.Always;
        ///      zip.AddFileS(arrayOfFiles);
        ///      zip.Save("Myarchive-Encoded-in-IBM861.zip");
        ///   }
        /// </code>
        /// </example>
        /// <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />
        // Token: 0x17000096 RID: 150
        // (get) Token: 0x060001C8 RID: 456 RVA: 0x00009660 File Offset: 0x00007860
        // (set) Token: 0x060001C9 RID: 457 RVA: 0x00009677 File Offset: 0x00007877
        public Encoding AlternateEncoding { get; set; }

        /// <summary>
        ///   Describes if and when this instance should apply
        ///   AlternateEncoding to encode the FileName and Comment, when
        ///   saving.
        /// </summary>
        /// <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />
        // Token: 0x17000097 RID: 151
        // (get) Token: 0x060001CA RID: 458 RVA: 0x00009680 File Offset: 0x00007880
        // (set) Token: 0x060001CB RID: 459 RVA: 0x00009697 File Offset: 0x00007897
        public ZipOption AlternateEncodingUsage { get; set; }

        // Token: 0x060001CC RID: 460 RVA: 0x000096A0 File Offset: 0x000078A0
        internal static string NameInArchive(string filename, string directoryPathInArchive)
        {
            string result;
            if (directoryPathInArchive == null)
            {
                result = filename;
            }
            else if (string.IsNullOrEmpty(directoryPathInArchive))
            {
                result = Path.GetFileName(filename);
            }
            else
            {
                result = Path.Combine(directoryPathInArchive, Path.GetFileName(filename));
            }
            return SharedUtilities.NormalizePathForUseInZipFile(result);
        }

        // Token: 0x060001CD RID: 461 RVA: 0x000096F4 File Offset: 0x000078F4
        internal static ZipEntry CreateFromNothing(string nameInArchive)
        {
            return ZipEntry.Create(nameInArchive, ZipEntrySource.None, null, null);
        }

        // Token: 0x060001CE RID: 462 RVA: 0x00009710 File Offset: 0x00007910
        internal static ZipEntry CreateFromFile(string filename, string nameInArchive)
        {
            return ZipEntry.Create(nameInArchive, ZipEntrySource.FileSystem, filename, null);
        }

        // Token: 0x060001CF RID: 463 RVA: 0x0000972C File Offset: 0x0000792C
        internal static ZipEntry CreateForStream(string entryName, Stream s)
        {
            return ZipEntry.Create(entryName, ZipEntrySource.Stream, s, null);
        }

        // Token: 0x060001D0 RID: 464 RVA: 0x00009748 File Offset: 0x00007948
        internal static ZipEntry CreateForWriter(string entryName, WriteDelegate d)
        {
            return ZipEntry.Create(entryName, ZipEntrySource.WriteDelegate, d, null);
        }

        // Token: 0x060001D1 RID: 465 RVA: 0x00009764 File Offset: 0x00007964
        internal static ZipEntry CreateForJitStreamProvider(string nameInArchive, OpenDelegate opener, CloseDelegate closer)
        {
            return ZipEntry.Create(nameInArchive, ZipEntrySource.JitStream, opener, closer);
        }

        // Token: 0x060001D2 RID: 466 RVA: 0x00009780 File Offset: 0x00007980
        internal static ZipEntry CreateForZipOutputStream(string nameInArchive)
        {
            return ZipEntry.Create(nameInArchive, ZipEntrySource.ZipOutputStream, null, null);
        }

        // Token: 0x060001D3 RID: 467 RVA: 0x0000979C File Offset: 0x0000799C
        private static ZipEntry Create(string nameInArchive, ZipEntrySource source, object arg1, object arg2)
        {
            if (string.IsNullOrEmpty(nameInArchive))
            {
                throw new ZipException("The entry name must be non-null and non-empty.");
            }
            ZipEntry entry = new ZipEntry();
            entry._VersionMadeBy = 45;
            entry._Source = source;
            entry._Mtime = (entry._Atime = (entry._Ctime = DateTime.UtcNow));
            if (source == ZipEntrySource.Stream)
            {
                entry._sourceStream = (arg1 as Stream);
            }
            else if (source == ZipEntrySource.WriteDelegate)
            {
                entry._WriteDelegate = (arg1 as WriteDelegate);
            }
            else if (source == ZipEntrySource.JitStream)
            {
                entry._OpenDelegate = (arg1 as OpenDelegate);
                entry._CloseDelegate = (arg2 as CloseDelegate);
            }
            else if (source != ZipEntrySource.ZipOutputStream)
            {
                if (source == ZipEntrySource.None)
                {
                    entry._Source = ZipEntrySource.FileSystem;
                }
                else
                {
                    string filename = arg1 as string;
                    if (string.IsNullOrEmpty(filename))
                    {
                        throw new ZipException("The filename must be non-null and non-empty.");
                    }
                    try
                    {
                        entry._Mtime = File.GetLastWriteTime(filename).ToUniversalTime();
                        entry._Ctime = File.GetCreationTime(filename).ToUniversalTime();
                        entry._Atime = File.GetLastAccessTime(filename).ToUniversalTime();
                        if (File.Exists(filename) || Directory.Exists(filename))
                        {
                            entry._ExternalFileAttrs = (int)File.GetAttributes(filename);
                        }
                        entry._ntfsTimesAreSet = true;
                        entry._LocalFileName = Path.GetFullPath(filename);
                    }
                    catch (PathTooLongException ptle)
                    {
                        string msg = string.Format("The path is too long, filename={0}", filename);
                        throw new ZipException(msg, ptle);
                    }
                }
            }
            entry._LastModified = entry._Mtime;
            entry._FileNameInArchive = SharedUtilities.NormalizePathForUseInZipFile(nameInArchive);
            return entry;
        }

        // Token: 0x060001D4 RID: 468 RVA: 0x0000997C File Offset: 0x00007B7C
        internal void MarkAsDirectory()
        {
            this._IsDirectory = true;
            if (!this._FileNameInArchive.EndsWith("/"))
            {
                this._FileNameInArchive += "/";
            }
        }

        /// <summary>
        ///   Indicates whether an entry is marked as a text file. Be careful when
        ///   using on this property. Unless you have a good reason, you should
        ///   probably ignore this property.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The ZIP format includes a provision for specifying whether an entry in
        ///   the zip archive is a text or binary file.  This property exposes that
        ///   metadata item. Be careful when using this property: It's not clear
        ///   that this property as a firm meaning, across tools and libraries.
        /// </para>
        ///
        /// <para>
        ///   To be clear, when reading a zip file, the property value may or may
        ///   not be set, and its value may or may not be valid.  Not all entries
        ///   that you may think of as "text" entries will be so marked, and entries
        ///   marked as "text" are not guaranteed in any way to be text entries.
        ///   Whether the value is set and set correctly depends entirely on the
        ///   application that produced the zip file.
        /// </para>
        ///
        /// <para>
        ///   There are many zip tools available, and when creating zip files, some
        ///   of them "respect" the IsText metadata field, and some of them do not.
        ///   Unfortunately, even when an application tries to do "the right thing",
        ///   it's not always clear what "the right thing" is.
        /// </para>
        ///
        /// <para>
        ///   There's no firm definition of just what it means to be "a text file",
        ///   and the zip specification does not help in this regard. Twenty years
        ///   ago, text was ASCII, each byte was less than 127. IsText meant, all
        ///   bytes in the file were less than 127.  These days, it is not the case
        ///   that all text files have all bytes less than 127.  Any unicode file
        ///   may have bytes that are above 0x7f.  The zip specification has nothing
        ///   to say on this topic. Therefore, it's not clear what IsText really
        ///   means.
        /// </para>
        ///
        /// <para>
        ///   This property merely tells a reading application what is stored in the
        ///   metadata for an entry, without guaranteeing its validity or its
        ///   meaning.
        /// </para>
        ///
        /// <para>
        ///   When DotNetZip is used to create a zipfile, it attempts to set this
        ///   field "correctly." For example, if a file ends in ".txt", this field
        ///   will be set. Your application may override that default setting.  When
        ///   writing a zip file, you must set the property before calling
        ///   <c>Save()</c> on the ZipFile.
        /// </para>
        ///
        /// <para>
        ///   When reading a zip file, a more general way to decide just what kind
        ///   of file is contained in a particular entry is to use the file type
        ///   database stored in the operating system.  The operating system stores
        ///   a table that says, a file with .jpg extension is a JPG image file, a
        ///   file with a .xml extension is an XML document, a file with a .txt is a
        ///   pure ASCII text document, and so on.  To get this information on
        ///   Windows, <see href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
        ///   need to read and parse the registry.</see> </para>
        /// </remarks>
        ///
        /// <example>
        /// <code>
        /// using (var zip = new ZipFile())
        /// {
        ///     var e = zip.UpdateFile("Descriptions.mme", "");
        ///     e.IsText = true;
        ///     zip.Save(zipPath);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
        ///     e.IsText= True
        ///     zip.Save(zipPath)
        /// End Using
        /// </code>
        /// </example>
        // Token: 0x17000098 RID: 152
        // (get) Token: 0x060001D5 RID: 469 RVA: 0x000099BC File Offset: 0x00007BBC
        // (set) Token: 0x060001D6 RID: 470 RVA: 0x000099D4 File Offset: 0x00007BD4
        public bool IsText
        {
            get
            {
                return this._IsText;
            }
            set
            {
                this._IsText = value;
            }
        }

        /// <summary>Provides a string representation of the instance.</summary>
        /// <returns>a string representation of the instance.</returns>
        // Token: 0x060001D7 RID: 471 RVA: 0x000099E0 File Offset: 0x00007BE0
        public override string ToString()
        {
            return string.Format("ZipEntry::{0}", this.FileName);
        }

        // Token: 0x17000099 RID: 153
        // (get) Token: 0x060001D8 RID: 472 RVA: 0x00009A04 File Offset: 0x00007C04
        internal Stream ArchiveStream
        {
            get
            {
                if (this._archiveStream == null)
                {
                    if (this._container.ZipFile != null)
                    {
                        ZipFile zf = this._container.ZipFile;
                        zf.Reset(false);
                        this._archiveStream = zf.StreamForDiskNumber(this._diskNumber);
                    }
                    else
                    {
                        this._archiveStream = this._container.ZipOutputStream.OutputStream;
                    }
                }
                return this._archiveStream;
            }
        }

        // Token: 0x060001D9 RID: 473 RVA: 0x00009A84 File Offset: 0x00007C84
        private void SetFdpLoh()
        {
            long origPosition = this.ArchiveStream.Position;
            try
            {
                this.ArchiveStream.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
            }
            catch (IOException exc)
            {
                string description = string.Format("Exception seeking  entry({0}) offset(0x{1:X8}) len(0x{2:X8})", this.FileName, this._RelativeOffsetOfLocalHeader, this.ArchiveStream.Length);
                throw new BadStateException(description, exc);
            }
            byte[] block = new byte[30];
            this.ArchiveStream.Read(block, 0, block.Length);
            short filenameLength = (short)((int)block[26] + (int)block[27] * 256);
            short extraFieldLength = (short)((int)block[28] + (int)block[29] * 256);
            this.ArchiveStream.Seek((long)(filenameLength + extraFieldLength), SeekOrigin.Current);
            this._LengthOfHeader = (int)(30 + extraFieldLength + filenameLength) + ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
            this.__FileDataPosition = this._RelativeOffsetOfLocalHeader + (long)this._LengthOfHeader;
            this.ArchiveStream.Seek(origPosition, SeekOrigin.Begin);
        }

        // Token: 0x060001DA RID: 474 RVA: 0x00009B88 File Offset: 0x00007D88
        private static int GetKeyStrengthInBits(EncryptionAlgorithm a)
        {
            int result;
            if (a == EncryptionAlgorithm.WinZipAes256)
            {
                result = 256;
            }
            else if (a == EncryptionAlgorithm.WinZipAes128)
            {
                result = 128;
            }
            else
            {
                result = -1;
            }
            return result;
        }

        // Token: 0x060001DB RID: 475 RVA: 0x00009BC4 File Offset: 0x00007DC4
        internal static int GetLengthOfCryptoHeaderBytes(EncryptionAlgorithm a)
        {
            int result;
            if (a == EncryptionAlgorithm.None)
            {
                result = 0;
            }
            else if (a == EncryptionAlgorithm.WinZipAes128 || a == EncryptionAlgorithm.WinZipAes256)
            {
                int KeyStrengthInBits = ZipEntry.GetKeyStrengthInBits(a);
                int sizeOfSaltAndPv = KeyStrengthInBits / 8 / 2 + 2;
                result = sizeOfSaltAndPv;
            }
            else
            {
                if (a != EncryptionAlgorithm.PkzipWeak)
                {
                    throw new ZipException("internal error");
                }
                result = 12;
            }
            return result;
        }

        // Token: 0x1700009A RID: 154
        // (get) Token: 0x060001DC RID: 476 RVA: 0x00009C24 File Offset: 0x00007E24
        internal long FileDataPosition
        {
            get
            {
                if (this.__FileDataPosition == -1L)
                {
                    this.SetFdpLoh();
                }
                return this.__FileDataPosition;
            }
        }

        // Token: 0x1700009B RID: 155
        // (get) Token: 0x060001DD RID: 477 RVA: 0x00009C54 File Offset: 0x00007E54
        private int LengthOfHeader
        {
            get
            {
                if (this._LengthOfHeader == 0)
                {
                    this.SetFdpLoh();
                }
                return this._LengthOfHeader;
            }
        }

        /// <summary>
        ///   Extract the entry to the filesystem, starting at the current
        ///   working directory.
        /// </summary>
        ///
        /// <overloads>
        ///   This method has a bunch of overloads! One of them is sure to
        ///   be the right one for you... If you don't like these, check
        ///   out the <c>ExtractWithPassword()</c> methods.
        /// </overloads>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)" />
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This method extracts an entry from a zip file into the current
        ///   working directory.  The path of the entry as extracted is the full
        ///   path as specified in the zip archive, relative to the current
        ///   working directory.  After the file is extracted successfully, the
        ///   file attributes and timestamps are set.
        /// </para>
        ///
        /// <para>
        ///   The action taken when extraction an entry would overwrite an
        ///   existing file is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property.
        /// </para>
        ///
        /// <para>
        ///   Within the call to <c>Extract()</c>, the content for the entry is
        ///   written into a filesystem file, and then the last modified time of the
        ///   file is set according to the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property on
        ///   the entry. See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for
        ///   some details about the last modified time.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x060001DE RID: 478 RVA: 0x00009C83 File Offset: 0x00007E83
        public void Extract()
        {
            this.InternalExtract(".", null, null);
        }

        /// <summary>
        ///   Extract the entry to a file in the filesystem, using the specified
        ///   behavior when extraction would overwrite an existing file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the file is set after
        ///   extraction.
        /// </para>
        /// </remarks>
        ///
        /// <param name="extractExistingFile">
        ///   The action to take if extraction would overwrite an existing file.
        /// </param>
        // Token: 0x060001DF RID: 479 RVA: 0x00009C94 File Offset: 0x00007E94
        public void Extract(ExtractExistingFileAction extractExistingFile)
        {
            this.ExtractExistingFile = extractExistingFile;
            this.InternalExtract(".", null, null);
        }

        /// <summary>
        ///   Extracts the entry to the specified stream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The caller can specify any write-able stream, for example a <see cref="T:System.IO.FileStream" />, a <see cref="T:System.IO.MemoryStream" />, or ASP.NET's
        ///   <c>Response.OutputStream</c>.  The content will be decrypted and
        ///   decompressed as necessary. If the entry is encrypted and no password
        ///   is provided, this method will throw.
        /// </para>
        /// <para>
        ///   The position on the stream is not reset by this method before it extracts.
        ///   You may want to call stream.Seek() before calling ZipEntry.Extract().
        /// </para>
        /// </remarks>
        ///
        /// <param name="stream">
        ///   the stream to which the entry should be extracted.
        /// </param>
        // Token: 0x060001E0 RID: 480 RVA: 0x00009CAD File Offset: 0x00007EAD
        public void Extract(Stream stream)
        {
            this.InternalExtract(null, stream, null);
        }

        /// <summary>
        ///   Extract the entry to the filesystem, starting at the specified base
        ///   directory.
        /// </summary>
        ///
        /// <param name="baseDirectory">the pathname of the base directory</param>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />
        ///
        /// <example>
        /// This example extracts only the entries in a zip file that are .txt files,
        /// into a directory called "textfiles".
        /// <code lang="C#">
        /// using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
        /// {
        ///   foreach (string s1 in zip.EntryFilenames)
        ///   {
        ///     if (s1.EndsWith(".txt"))
        ///     {
        ///       zip[s1].Extract("textfiles");
        ///     }
        ///   }
        /// }
        /// </code>
        /// <code lang="VB">
        ///   Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
        ///       Dim s1 As String
        ///       For Each s1 In zip.EntryFilenames
        ///           If s1.EndsWith(".txt") Then
        ///               zip(s1).Extract("textfiles")
        ///           End If
        ///       Next
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Using this method, existing entries in the filesystem will not be
        ///   overwritten. If you would like to force the overwrite of existing
        ///   files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property, or call
        ///   <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />.
        /// </para>
        ///
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the created file is set.
        /// </para>
        /// </remarks>
        // Token: 0x060001E1 RID: 481 RVA: 0x00009CBA File Offset: 0x00007EBA
        public void Extract(string baseDirectory)
        {
            this.InternalExtract(baseDirectory, null, null);
        }

        /// <summary>
        ///   Extract the entry to the filesystem, starting at the specified base
        ///   directory, and using the specified behavior when extraction would
        ///   overwrite an existing file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the created file is set.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// <code lang="C#">
        /// String sZipPath = "Airborne.zip";
        /// String sFilePath = "Readme.txt";
        /// String sRootFolder = "Digado";
        /// using (ZipFile zip = ZipFile.Read(sZipPath))
        /// {
        ///   if (zip.EntryFileNames.Contains(sFilePath))
        ///   {
        ///     // use the string indexer on the zip file
        ///     zip[sFileName].Extract(sRootFolder,
        ///                            ExtractExistingFileAction.OverwriteSilently);
        ///   }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim sZipPath as String = "Airborne.zip"
        /// Dim sFilePath As String = "Readme.txt"
        /// Dim sRootFolder As String = "Digado"
        /// Using zip As ZipFile = ZipFile.Read(sZipPath)
        ///   If zip.EntryFileNames.Contains(sFilePath)
        ///     ' use the string indexer on the zip file
        ///     zip(sFilePath).Extract(sRootFolder, _
        ///                            ExtractExistingFileAction.OverwriteSilently)
        ///   End If
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="baseDirectory">the pathname of the base directory</param>
        /// <param name="extractExistingFile">
        /// The action to take if extraction would overwrite an existing file.
        /// </param>
        // Token: 0x060001E2 RID: 482 RVA: 0x00009CC7 File Offset: 0x00007EC7
        public void Extract(string baseDirectory, ExtractExistingFileAction extractExistingFile)
        {
            this.ExtractExistingFile = extractExistingFile;
            this.InternalExtract(baseDirectory, null, null);
        }

        /// <summary>
        ///   Extract the entry to the filesystem, using the current working directory
        ///   and the specified password.
        /// </summary>
        ///
        /// <overloads>
        ///   This method has a bunch of overloads! One of them is sure to be
        ///   the right one for you...
        /// </overloads>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Existing entries in the filesystem will not be overwritten. If you
        ///   would like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call
        ///   <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.
        /// </para>
        ///
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for some
        ///   details about how the "last modified" time of the created file is
        ///   set.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///   In this example, entries that use encryption are extracted using a
        ///   particular password.
        /// <code>
        /// using (var zip = ZipFile.Read(FilePath))
        /// {
        ///     foreach (ZipEntry e in zip)
        ///     {
        ///         if (e.UsesEncryption)
        ///             e.ExtractWithPassword("Secret!");
        ///         else
        ///             e.Extract();
        ///     }
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(FilePath)
        ///     Dim e As ZipEntry
        ///     For Each e In zip
        ///         If (e.UsesEncryption)
        ///           e.ExtractWithPassword("Secret!")
        ///         Else
        ///           e.Extract
        ///         End If
        ///     Next
        /// End Using
        /// </code>
        /// </example>
        /// <param name="password">The Password to use for decrypting the entry.</param>
        // Token: 0x060001E3 RID: 483 RVA: 0x00009CDC File Offset: 0x00007EDC
        public void ExtractWithPassword(string password)
        {
            this.InternalExtract(".", null, password);
        }

        /// <summary>
        ///   Extract the entry to the filesystem, starting at the specified base
        ///   directory, and using the specified password.
        /// </summary>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        /// <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)" />
        ///
        /// <remarks>
        /// <para>
        ///   Existing entries in the filesystem will not be overwritten. If you
        ///   would like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call
        ///   <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.
        /// </para>
        ///
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the created file is set.
        /// </para>
        /// </remarks>
        ///
        /// <param name="baseDirectory">The pathname of the base directory.</param>
        /// <param name="password">The Password to use for decrypting the entry.</param>
        // Token: 0x060001E4 RID: 484 RVA: 0x00009CED File Offset: 0x00007EED
        public void ExtractWithPassword(string baseDirectory, string password)
        {
            this.InternalExtract(baseDirectory, null, password);
        }

        /// <summary>
        ///   Extract the entry to a file in the filesystem, relative to the
        ///   current directory, using the specified behavior when extraction
        ///   would overwrite an existing file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the created file is set.
        /// </para>
        /// </remarks>
        ///
        /// <param name="password">The Password to use for decrypting the entry.</param>
        ///
        /// <param name="extractExistingFile">
        /// The action to take if extraction would overwrite an existing file.
        /// </param>
        // Token: 0x060001E5 RID: 485 RVA: 0x00009CFA File Offset: 0x00007EFA
        public void ExtractWithPassword(ExtractExistingFileAction extractExistingFile, string password)
        {
            this.ExtractExistingFile = extractExistingFile;
            this.InternalExtract(".", null, password);
        }

        /// <summary>
        ///   Extract the entry to the filesystem, starting at the specified base
        ///   directory, and using the specified behavior when extraction would
        ///   overwrite an existing file.
        /// </summary>
        ///
        /// <remarks>
        ///   See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
        ///   details about how the last modified time of the created file is set.
        /// </remarks>
        ///
        /// <param name="baseDirectory">the pathname of the base directory</param>
        ///
        /// <param name="extractExistingFile">The action to take if extraction would
        /// overwrite an existing file.</param>
        ///
        /// <param name="password">The Password to use for decrypting the entry.</param>
        // Token: 0x060001E6 RID: 486 RVA: 0x00009D13 File Offset: 0x00007F13
        public void ExtractWithPassword(string baseDirectory, ExtractExistingFileAction extractExistingFile, string password)
        {
            this.ExtractExistingFile = extractExistingFile;
            this.InternalExtract(baseDirectory, null, password);
        }

        /// <summary>
        ///   Extracts the entry to the specified stream, using the specified
        ///   Password.  For example, the caller could extract to Console.Out, or
        ///   to a MemoryStream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The caller can specify any write-able stream, for example a <see cref="T:System.IO.FileStream" />, a <see cref="T:System.IO.MemoryStream" />, or ASP.NET's
        ///   <c>Response.OutputStream</c>.  The content will be decrypted and
        ///   decompressed as necessary. If the entry is encrypted and no password
        ///   is provided, this method will throw.
        /// </para>
        /// <para>
        ///   The position on the stream is not reset by this method before it extracts.
        ///   You may want to call stream.Seek() before calling ZipEntry.Extract().
        /// </para>
        /// </remarks>
        ///
        ///
        /// <param name="stream">
        ///   the stream to which the entry should be extracted.
        /// </param>
        /// <param name="password">
        ///   The password to use for decrypting the entry.
        /// </param>
        // Token: 0x060001E7 RID: 487 RVA: 0x00009D28 File Offset: 0x00007F28
        public void ExtractWithPassword(Stream stream, string password)
        {
            this.InternalExtract(null, stream, password);
        }

        /// <summary>
        ///   Opens a readable stream corresponding to the zip entry in the
        ///   archive.  The stream decompresses and decrypts as necessary, as it
        ///   is read.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   DotNetZip offers a variety of ways to extract entries from a zip
        ///   file.  This method allows an application to extract an entry by
        ///   reading a <see cref="T:System.IO.Stream" />.
        /// </para>
        ///
        /// <para>
        ///   The return value is of type <see cref="T:Ionic.Crc.CrcCalculatorStream" />.  Use it as you would any
        ///   stream for reading.  When an application calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> on that stream, it will
        ///   receive data from the zip entry that is decrypted and decompressed
        ///   as necessary.
        /// </para>
        ///
        /// <para>
        ///   <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
        ///   CRC32 checksum on the bytes of the stream as it is read.  The CRC
        ///   value is available in the <see cref="P:Ionic.Crc.CrcCalculatorStream.Crc" /> property on the
        ///   <c>CrcCalculatorStream</c>.  When the read is complete, your
        ///   application
        ///   <em>should</em> check this CRC against the <see cref="P:Ionic.Zip.ZipEntry.Crc" />
        ///   property on the <c>ZipEntry</c> to validate the content of the
        ///   ZipEntry. You don't have to validate the entry using the CRC, but
        ///   you should, to verify integrity. Check the example for how to do
        ///   this.
        /// </para>
        ///
        /// <para>
        ///   If the entry is protected with a password, then you need to provide
        ///   a password prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader" />, either by
        ///   setting the <see cref="P:Ionic.Zip.ZipEntry.Password" /> property on the entry, or the
        ///   <see cref="P:Ionic.Zip.ZipFile.Password" /> property on the <c>ZipFile</c>
        ///   itself. Or, you can use <see cref="M:Ionic.Zip.ZipEntry.OpenReader(System.String)" />, the
        ///   overload of OpenReader that accepts a password parameter.
        /// </para>
        ///
        /// <para>
        ///   If you want to extract entry data into a write-able stream that is
        ///   already opened, like a <see cref="T:System.IO.FileStream" />, do not
        ///   use this method. Instead, use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />.
        /// </para>
        ///
        /// <para>
        ///   Your application may use only one stream created by OpenReader() at
        ///   a time, and you should not call other Extract methods before
        ///   completing your reads on a stream obtained from OpenReader().  This
        ///   is because there is really only one source stream for the compressed
        ///   content.  A call to OpenReader() seeks in the source stream, to the
        ///   beginning of the compressed content.  A subsequent call to
        ///   OpenReader() on a different entry will seek to a different position
        ///   in the source stream, as will a call to Extract() or one of its
        ///   overloads.  This will corrupt the state for the decompressing stream
        ///   from the original call to OpenReader().
        /// </para>
        ///
        /// <para>
        ///    The <c>OpenReader()</c> method works only when the ZipEntry is
        ///    obtained from an instance of <c>ZipFile</c>. This method will throw
        ///    an exception if the ZipEntry is obtained from a <see cref="T:Ionic.Zip.ZipInputStream" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///   This example shows how to open a zip archive, then read in a named
        ///   entry via a stream. After the read loop is complete, the code
        ///   compares the calculated during the read loop with the expected CRC
        ///   on the <c>ZipEntry</c>, to verify the extraction.
        /// <code>
        /// using (ZipFile zip = new ZipFile(ZipFileToRead))
        /// {
        ///   ZipEntry e1= zip["Elevation.mp3"];
        ///   using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
        ///   {
        ///     byte[] buffer = new byte[4096];
        ///     int n, totalBytesRead= 0;
        ///     do {
        ///       n = s.Read(buffer,0, buffer.Length);
        ///       totalBytesRead+=n;
        ///     } while (n&gt;0);
        ///      if (s.Crc32 != e1.Crc32)
        ///       throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
        ///      if (totalBytesRead != e1.UncompressedSize)
        ///       throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
        ///   }
        /// }
        /// </code>
        /// <code lang="VB">
        ///   Using zip As New ZipFile(ZipFileToRead)
        ///       Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
        ///       Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
        ///           Dim n As Integer
        ///           Dim buffer As Byte() = New Byte(4096) {}
        ///           Dim totalBytesRead As Integer = 0
        ///           Do
        ///               n = s.Read(buffer, 0, buffer.Length)
        ///               totalBytesRead = (totalBytesRead + n)
        ///           Loop While (n &gt; 0)
        ///           If (s.Crc32 &lt;&gt; e1.Crc32) Then
        ///               Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
        ///           End If
        ///           If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
        ///               Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
        ///           End If
        ///       End Using
        ///   End Using
        /// </code>
        /// </example>
        /// <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />
        /// <returns>The Stream for reading.</returns>
        // Token: 0x060001E8 RID: 488 RVA: 0x00009D38 File Offset: 0x00007F38
        public CrcCalculatorStream OpenReader()
        {
            if (this._container.ZipFile == null)
            {
                throw new InvalidOperationException("Use OpenReader() only with ZipFile.");
            }
            return this.InternalOpenReader(this._Password ?? this._container.Password);
        }

        /// <summary>
        ///   Opens a readable stream for an encrypted zip entry in the archive.
        ///   The stream decompresses and decrypts as necessary, as it is read.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> method for
        ///   full details. This overload allows the application to specify a
        ///   password for the <c>ZipEntry</c> to be read.
        /// </para>
        /// </remarks>
        ///
        /// <param name="password">The password to use for decrypting the entry.</param>
        /// <returns>The Stream for reading.</returns>
        // Token: 0x060001E9 RID: 489 RVA: 0x00009D88 File Offset: 0x00007F88
        public CrcCalculatorStream OpenReader(string password)
        {
            if (this._container.ZipFile == null)
            {
                throw new InvalidOperationException("Use OpenReader() only with ZipFile.");
            }
            return this.InternalOpenReader(password);
        }

        // Token: 0x060001EA RID: 490 RVA: 0x00009DC4 File Offset: 0x00007FC4
        internal CrcCalculatorStream InternalOpenReader(string password)
        {
            this.ValidateCompression();
            this.ValidateEncryption();
            this.SetupCryptoForExtract(password);
            if (this._Source != ZipEntrySource.ZipFile)
            {
                throw new BadStateException("You must call ZipFile.Save before calling OpenReader");
            }
            long LeftToRead = (this._CompressionMethod_FromZipFile == 0) ? this._CompressedFileDataSize : this.UncompressedSize;
            Stream input = this.ArchiveStream;
            this.ArchiveStream.Seek(this.FileDataPosition, SeekOrigin.Begin);
            this._inputDecryptorStream = this.GetExtractDecryptor(input);
            Stream input2 = this.GetExtractDecompressor(this._inputDecryptorStream);
            return new CrcCalculatorStream(input2, LeftToRead);
        }

        // Token: 0x060001EB RID: 491 RVA: 0x00009E58 File Offset: 0x00008058
        private void OnExtractProgress(long bytesWritten, long totalBytesToWrite)
        {
            if (this._container.ZipFile != null)
            {
                this._ioOperationCanceled = this._container.ZipFile.OnExtractBlock(this, bytesWritten, totalBytesToWrite);
            }
        }

        // Token: 0x060001EC RID: 492 RVA: 0x00009E94 File Offset: 0x00008094
        private void OnBeforeExtract(string path)
        {
            if (this._container.ZipFile != null)
            {
                if (!this._container.ZipFile._inExtractAll)
                {
                    this._ioOperationCanceled = this._container.ZipFile.OnSingleEntryExtract(this, path, true);
                }
            }
        }

        // Token: 0x060001ED RID: 493 RVA: 0x00009EE8 File Offset: 0x000080E8
        private void OnAfterExtract(string path)
        {
            if (this._container.ZipFile != null)
            {
                if (!this._container.ZipFile._inExtractAll)
                {
                    this._container.ZipFile.OnSingleEntryExtract(this, path, false);
                }
            }
        }

        // Token: 0x060001EE RID: 494 RVA: 0x00009F34 File Offset: 0x00008134
        private void OnExtractExisting(string path)
        {
            if (this._container.ZipFile != null)
            {
                this._ioOperationCanceled = this._container.ZipFile.OnExtractExisting(this, path);
            }
        }

        // Token: 0x060001EF RID: 495 RVA: 0x00009F6C File Offset: 0x0000816C
        private static void ReallyDelete(string fileName)
        {
            if ((File.GetAttributes(fileName) & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
            {
                File.SetAttributes(fileName, FileAttributes.Normal);
            }
            File.Delete(fileName);
        }

        // Token: 0x060001F0 RID: 496 RVA: 0x00009FA0 File Offset: 0x000081A0
        private void WriteStatus(string format, params object[] args)
        {
            if (this._container.ZipFile != null && this._container.ZipFile.Verbose)
            {
                this._container.ZipFile.StatusMessageTextWriter.WriteLine(format, args);
            }
        }

        // Token: 0x060001F1 RID: 497 RVA: 0x00009FF0 File Offset: 0x000081F0
        private void InternalExtract(string baseDir, Stream outstream, string password)
        {
            if (this._container == null)
            {
                throw new BadStateException("This entry is an orphan");
            }
            if (this._container.ZipFile == null)
            {
                throw new InvalidOperationException("Use Extract() only with ZipFile.");
            }
            this._container.ZipFile.Reset(false);
            if (this._Source != ZipEntrySource.ZipFile)
            {
                throw new BadStateException("You must call ZipFile.Save before calling any Extract method");
            }
            this.OnBeforeExtract(baseDir);
            this._ioOperationCanceled = false;
            string targetFileName = null;
            Stream output = null;
            bool fileExistsBeforeExtraction = false;
            bool checkLaterForResetDirTimes = false;
            try
            {
                this.ValidateCompression();
                this.ValidateEncryption();
                if (this.ValidateOutput(baseDir, outstream, out targetFileName))
                {
                    this.WriteStatus("extract dir {0}...", new object[]
                    {
                        targetFileName
                    });
                    this.OnAfterExtract(baseDir);
                }
                else
                {
                    if (targetFileName != null)
                    {
                        if (File.Exists(targetFileName))
                        {
                            fileExistsBeforeExtraction = true;
                            int rc = this.CheckExtractExistingFile(baseDir, targetFileName);
                            if (rc == 2)
                            {
                                goto IL_36F;
                            }
                            if (rc == 1)
                            {
                                return;
                            }
                        }
                    }
                    string p = password ?? (this._Password ?? this._container.Password);
                    if (this._Encryption_FromZipFile != EncryptionAlgorithm.None)
                    {
                        if (p == null)
                        {
                            throw new BadPasswordException();
                        }
                        this.SetupCryptoForExtract(p);
                    }
                    if (targetFileName != null)
                    {
                        this.WriteStatus("extract file {0}...", new object[]
                        {
                            targetFileName
                        });
                        targetFileName += ".tmp";
                        string dirName = Path.GetDirectoryName(targetFileName);
                        if (!Directory.Exists(dirName))
                        {
                            Directory.CreateDirectory(dirName);
                        }
                        else if (this._container.ZipFile != null)
                        {
                            checkLaterForResetDirTimes = this._container.ZipFile._inExtractAll;
                        }
                        output = new FileStream(targetFileName, FileMode.CreateNew);
                    }
                    else
                    {
                        this.WriteStatus("extract entry {0} to stream...", new object[]
                        {
                            this.FileName
                        });
                        output = outstream;
                    }
                    if (!this._ioOperationCanceled)
                    {
                        int ActualCrc32 = this.ExtractOne(output);
                        if (!this._ioOperationCanceled)
                        {
                            this.VerifyCrcAfterExtract(ActualCrc32);
                            if (targetFileName != null)
                            {
                                output.Close();
                                output = null;
                                string tmpName = targetFileName;
                                string zombie = null;
                                targetFileName = tmpName.Substring(0, tmpName.Length - 4);
                                if (fileExistsBeforeExtraction)
                                {
                                    zombie = targetFileName + ".PendingOverwrite";
                                    File.Move(targetFileName, zombie);
                                }
                                File.Move(tmpName, targetFileName);
                                this._SetTimes(targetFileName, true);
                                if (zombie != null && File.Exists(zombie))
                                {
                                    ZipEntry.ReallyDelete(zombie);
                                }
                                if (checkLaterForResetDirTimes)
                                {
                                    if (this.FileName.IndexOf('/') != -1)
                                    {
                                        string dirname = Path.GetDirectoryName(this.FileName);
                                        if (this._container.ZipFile[dirname] == null)
                                        {
                                            this._SetTimes(Path.GetDirectoryName(targetFileName), false);
                                        }
                                    }
                                }
                                if (((int)this._VersionMadeBy & 65280) == 2560 || ((int)this._VersionMadeBy & 65280) == 0)
                                {
                                    File.SetAttributes(targetFileName, (FileAttributes)this._ExternalFileAttrs);
                                }
                            }
                            this.OnAfterExtract(baseDir);
                        }
                    }
                    IL_36F:;
                }
            }
            catch (Exception)
            {
                this._ioOperationCanceled = true;
                throw;
            }
            finally
            {
                if (this._ioOperationCanceled)
                {
                    if (targetFileName != null)
                    {
                        try
                        {
                            if (output != null)
                            {
                                output.Close();
                            }
                            if (File.Exists(targetFileName) && !fileExistsBeforeExtraction)
                            {
                                File.Delete(targetFileName);
                            }
                        }
                        finally
                        {
                        }
                    }
                }
            }
        }

        // Token: 0x060001F2 RID: 498 RVA: 0x0000A420 File Offset: 0x00008620
        internal void VerifyCrcAfterExtract(int actualCrc32)
        {
            if (actualCrc32 != this._Crc32)
            {
                if ((this.Encryption != EncryptionAlgorithm.WinZipAes128 && this.Encryption != EncryptionAlgorithm.WinZipAes256) || this._WinZipAesMethod != 2)
                {
                    throw new BadCrcException("CRC error: the file being extracted appears to be corrupted. " + string.Format("Expected 0x{0:X8}, Actual 0x{1:X8}", this._Crc32, actualCrc32));
                }
            }
            if (this.UncompressedSize != 0L)
            {
                if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                {
                    WinZipAesCipherStream wzs = this._inputDecryptorStream as WinZipAesCipherStream;
                    this._aesCrypto_forExtract.CalculatedMac = wzs.FinalAuthentication;
                    this._aesCrypto_forExtract.ReadAndVerifyMac(this.ArchiveStream);
                }
            }
        }

        // Token: 0x060001F3 RID: 499 RVA: 0x0000A4EC File Offset: 0x000086EC
        private int CheckExtractExistingFile(string baseDir, string targetFileName)
        {
            int loop = 0;
            for (; ; )
            {
                switch (this.ExtractExistingFile)
                {
                    case ExtractExistingFileAction.OverwriteSilently:
                        goto IL_26;
                    case ExtractExistingFileAction.DoNotOverwrite:
                        goto IL_45;
                    case ExtractExistingFileAction.InvokeExtractProgressEvent:
                        if (loop > 0)
                        {
                            goto Block_2;
                        }
                        this.OnExtractExisting(baseDir);
                        if (this._ioOperationCanceled)
                        {
                            goto Block_3;
                        }
                        loop++;
                        continue;
                }
                break;
            }
            goto IL_A9;
            IL_26:
            this.WriteStatus("the file {0} exists; will overwrite it...", new object[]
            {
                targetFileName
            });
            return 0;
            IL_45:
            this.WriteStatus("the file {0} exists; not extracting entry...", new object[]
            {
                this.FileName
            });
            this.OnAfterExtract(baseDir);
            return 1;
            Block_2:
            throw new ZipException(string.Format("The file {0} already exists.", targetFileName));
            Block_3:
            return 2;
            IL_A9:
            throw new ZipException(string.Format("The file {0} already exists.", targetFileName));
        }

        // Token: 0x060001F4 RID: 500 RVA: 0x0000A5C4 File Offset: 0x000087C4
        private void _CheckRead(int nbytes)
        {
            if (nbytes == 0)
            {
                throw new BadReadException(string.Format("bad read of entry {0} from compressed archive.", this.FileName));
            }
        }

        // Token: 0x060001F5 RID: 501 RVA: 0x0000A5F4 File Offset: 0x000087F4
        private int ExtractOne(Stream output)
        {
            int CrcResult = 0;
            Stream input = this.ArchiveStream;
            try
            {
                input.Seek(this.FileDataPosition, SeekOrigin.Begin);
                byte[] bytes = new byte[this.BufferSize];
                long LeftToRead = (this._CompressionMethod_FromZipFile != 0) ? this.UncompressedSize : this._CompressedFileDataSize;
                this._inputDecryptorStream = this.GetExtractDecryptor(input);
                Stream input2 = this.GetExtractDecompressor(this._inputDecryptorStream);
                long bytesWritten = 0L;
                using (CrcCalculatorStream s = new CrcCalculatorStream(input2))
                {
                    while (LeftToRead > 0L)
                    {
                        int len = (LeftToRead > (long)bytes.Length) ? bytes.Length : ((int)LeftToRead);
                        int i = s.Read(bytes, 0, len);
                        this._CheckRead(i);
                        output.Write(bytes, 0, i);
                        LeftToRead -= (long)i;
                        bytesWritten += (long)i;
                        this.OnExtractProgress(bytesWritten, this.UncompressedSize);
                        if (this._ioOperationCanceled)
                        {
                            break;
                        }
                    }
                    CrcResult = s.Crc;
                }
            }
            finally
            {
                ZipSegmentedStream zss = input as ZipSegmentedStream;
                if (zss != null)
                {
                    zss.Dispose();
                    this._archiveStream = null;
                }
            }
            return CrcResult;
        }

        // Token: 0x060001F6 RID: 502 RVA: 0x0000A744 File Offset: 0x00008944
        internal Stream GetExtractDecompressor(Stream input2)
        {
            short compressionMethod_FromZipFile = this._CompressionMethod_FromZipFile;
            Stream result;
            if (compressionMethod_FromZipFile != 0)
            {
                if (compressionMethod_FromZipFile != 8)
                {
                    if (compressionMethod_FromZipFile != 12)
                    {
                        result = null;
                    }
                    else
                    {
                        result = new BZip2InputStream(input2, true);
                    }
                }
                else
                {
                    result = new DeflateStream(input2, CompressionMode.Decompress, true);
                }
            }
            else
            {
                result = input2;
            }
            return result;
        }

        // Token: 0x060001F7 RID: 503 RVA: 0x0000A788 File Offset: 0x00008988
        internal Stream GetExtractDecryptor(Stream input)
        {
            Stream input2;
            if (this._Encryption_FromZipFile == EncryptionAlgorithm.PkzipWeak)
            {
                input2 = new ZipCipherStream(input, this._zipCrypto_forExtract, CryptoMode.Decrypt);
            }
            else if (this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes128 || this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes256)
            {
                input2 = new WinZipAesCipherStream(input, this._aesCrypto_forExtract, this._CompressedFileDataSize, CryptoMode.Decrypt);
            }
            else
            {
                input2 = input;
            }
            return input2;
        }

        // Token: 0x060001F8 RID: 504 RVA: 0x0000A7F4 File Offset: 0x000089F4
        internal void _SetTimes(string fileOrDirectory, bool isFile)
        {
            try
            {
                if (this._ntfsTimesAreSet)
                {
                    if (isFile)
                    {
                        if (File.Exists(fileOrDirectory))
                        {
                            File.SetCreationTimeUtc(fileOrDirectory, this._Ctime);
                            File.SetLastAccessTimeUtc(fileOrDirectory, this._Atime);
                            File.SetLastWriteTimeUtc(fileOrDirectory, this._Mtime);
                        }
                    }
                    else if (Directory.Exists(fileOrDirectory))
                    {
                        Directory.SetCreationTimeUtc(fileOrDirectory, this._Ctime);
                        Directory.SetLastAccessTimeUtc(fileOrDirectory, this._Atime);
                        Directory.SetLastWriteTimeUtc(fileOrDirectory, this._Mtime);
                    }
                }
                else
                {
                    DateTime AdjustedLastModified = SharedUtilities.AdjustTime_Reverse(this.LastModified);
                    if (isFile)
                    {
                        File.SetLastWriteTime(fileOrDirectory, AdjustedLastModified);
                    }
                    else
                    {
                        Directory.SetLastWriteTime(fileOrDirectory, AdjustedLastModified);
                    }
                }
            }
            catch (IOException ioexc)
            {
                this.WriteStatus("failed to set time on {0}: {1}", new object[]
                {
                    fileOrDirectory,
                    ioexc.Message
                });
            }
        }

        // Token: 0x1700009C RID: 156
        // (get) Token: 0x060001F9 RID: 505 RVA: 0x0000A8F0 File Offset: 0x00008AF0
        private string UnsupportedAlgorithm
        {
            get
            {
                string alg = string.Empty;
                uint unsupportedAlgorithmId = this._UnsupportedAlgorithmId;
                if (unsupportedAlgorithmId <= 26128u)
                {
                    if (unsupportedAlgorithmId <= 26115u)
                    {
                        if (unsupportedAlgorithmId == 0u)
                        {
                            return "--";
                        }
                        switch (unsupportedAlgorithmId)
                        {
                            case 26113u:
                                return "DES";
                            case 26114u:
                                return "RC2";
                            case 26115u:
                                return "3DES-168";
                        }
                    }
                    else
                    {
                        if (unsupportedAlgorithmId == 26121u)
                        {
                            return "3DES-112";
                        }
                        switch (unsupportedAlgorithmId)
                        {
                            case 26126u:
                                return "PKWare AES128";
                            case 26127u:
                                return "PKWare AES192";
                            case 26128u:
                                return "PKWare AES256";
                        }
                    }
                }
                else if (unsupportedAlgorithmId <= 26401u)
                {
                    if (unsupportedAlgorithmId == 26370u)
                    {
                        return "RC2";
                    }
                    switch (unsupportedAlgorithmId)
                    {
                        case 26400u:
                            return "Blowfish";
                        case 26401u:
                            return "Twofish";
                    }
                }
                else
                {
                    if (unsupportedAlgorithmId == 26625u)
                    {
                        return "RC4";
                    }
                    if (unsupportedAlgorithmId != 65535u)
                    {
                    }
                }
                return string.Format("Unknown (0x{0:X4})", this._UnsupportedAlgorithmId);
            }
        }

        // Token: 0x1700009D RID: 157
        // (get) Token: 0x060001FA RID: 506 RVA: 0x0000AA18 File Offset: 0x00008C18
        private string UnsupportedCompressionMethod
        {
            get
            {
                string meth = string.Empty;
                int compressionMethod = (int)this._CompressionMethod;
                if (compressionMethod <= 14)
                {
                    switch (compressionMethod)
                    {
                        case 0:
                            return "Store";
                        case 1:
                            return "Shrink";
                        default:
                            switch (compressionMethod)
                            {
                                case 8:
                                    return "DEFLATE";
                                case 9:
                                    return "Deflate64";
                                case 12:
                                    return "BZIP2";
                                case 14:
                                    return "LZMA";
                            }
                            break;
                    }
                }
                else
                {
                    if (compressionMethod == 19)
                    {
                        return "LZ77";
                    }
                    if (compressionMethod == 98)
                    {
                        return "PPMd";
                    }
                }
                return string.Format("Unknown (0x{0:X4})", this._CompressionMethod);
            }
        }

        // Token: 0x060001FB RID: 507 RVA: 0x0000AAD8 File Offset: 0x00008CD8
        internal void ValidateEncryption()
        {
            if (this.Encryption == EncryptionAlgorithm.PkzipWeak || this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256 || this.Encryption == EncryptionAlgorithm.None)
            {
                return;
            }
            if (this._UnsupportedAlgorithmId != 0u)
            {
                throw new ZipException(string.Format("Cannot extract: Entry {0} is encrypted with an algorithm not supported by DotNetZip: {1}", this.FileName, this.UnsupportedAlgorithm));
            }
            throw new ZipException(string.Format("Cannot extract: Entry {0} uses an unsupported encryption algorithm ({1:X2})", this.FileName, (int)this.Encryption));
        }

        // Token: 0x060001FC RID: 508 RVA: 0x0000AB5C File Offset: 0x00008D5C
        private void ValidateCompression()
        {
            if (this._CompressionMethod_FromZipFile != 0 && this._CompressionMethod_FromZipFile != 8 && this._CompressionMethod_FromZipFile != 12)
            {
                throw new ZipException(string.Format("Entry {0} uses an unsupported compression method (0x{1:X2}, {2})", this.FileName, this._CompressionMethod_FromZipFile, this.UnsupportedCompressionMethod));
            }
        }

        // Token: 0x060001FD RID: 509 RVA: 0x0000ABB4 File Offset: 0x00008DB4
        private void SetupCryptoForExtract(string password)
        {
            if (this._Encryption_FromZipFile != EncryptionAlgorithm.None)
            {
                if (this._Encryption_FromZipFile == EncryptionAlgorithm.PkzipWeak)
                {
                    if (password == null)
                    {
                        throw new ZipException("Missing password.");
                    }
                    this.ArchiveStream.Seek(this.FileDataPosition - 12L, SeekOrigin.Begin);
                    this._zipCrypto_forExtract = ZipCrypto.ForRead(password, this);
                }
                else if (this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes128 || this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes256)
                {
                    if (password == null)
                    {
                        throw new ZipException("Missing password.");
                    }
                    if (this._aesCrypto_forExtract != null)
                    {
                        this._aesCrypto_forExtract.Password = password;
                    }
                    else
                    {
                        int sizeOfSaltAndPv = ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
                        this.ArchiveStream.Seek(this.FileDataPosition - (long)sizeOfSaltAndPv, SeekOrigin.Begin);
                        int keystrength = ZipEntry.GetKeyStrengthInBits(this._Encryption_FromZipFile);
                        this._aesCrypto_forExtract = WinZipAesCrypto.ReadFromStream(password, keystrength, this.ArchiveStream);
                    }
                }
            }
        }

        /// <summary>
        /// Validates that the args are consistent.
        /// </summary>
        /// <remarks>
        /// Only one of {baseDir, outStream} can be non-null.
        /// If baseDir is non-null, then the outputFile is created.
        /// </remarks>
        // Token: 0x060001FE RID: 510 RVA: 0x0000ACC0 File Offset: 0x00008EC0
        private bool ValidateOutput(string basedir, Stream outstream, out string outFileName)
        {
            bool result;
            if (basedir != null)
            {
                string f = this.FileName.Replace("\\", "/");
                if (f.IndexOf(':') == 1)
                {
                    f = f.Substring(2);
                }
                if (f.StartsWith("/"))
                {
                    f = f.Substring(1);
                }
                if (this._container.ZipFile.FlattenFoldersOnExtract)
                {
                    outFileName = Path.Combine(basedir, (f.IndexOf('/') != -1) ? Path.GetFileName(f) : f);
                }
                else
                {
                    outFileName = Path.Combine(basedir, f);
                }
                outFileName = outFileName.Replace("/", "\\");
                if (this.IsDirectory || this.FileName.EndsWith("/"))
                {
                    if (!Directory.Exists(outFileName))
                    {
                        Directory.CreateDirectory(outFileName);
                        this._SetTimes(outFileName, false);
                    }
                    else if (this.ExtractExistingFile == ExtractExistingFileAction.OverwriteSilently)
                    {
                        this._SetTimes(outFileName, false);
                    }
                    result = true;
                }
                else
                {
                    result = false;
                }
            }
            else
            {
                if (outstream == null)
                {
                    throw new ArgumentNullException("outstream");
                }
                outFileName = null;
                result = (this.IsDirectory || this.FileName.EndsWith("/"));
            }
            return result;
        }

        // Token: 0x060001FF RID: 511 RVA: 0x0000AE20 File Offset: 0x00009020
        private void ReadExtraField()
        {
            this._readExtraDepth++;
            long posn = this.ArchiveStream.Position;
            this.ArchiveStream.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
            byte[] block = new byte[30];
            this.ArchiveStream.Read(block, 0, block.Length);
            int i = 26;
            short filenameLength = (short)((int)block[i++] + (int)block[i++] * 256);
            short extraFieldLength = (short)((int)block[i++] + (int)block[i++] * 256);
            this.ArchiveStream.Seek((long)filenameLength, SeekOrigin.Current);
            this.ProcessExtraField(this.ArchiveStream, extraFieldLength);
            this.ArchiveStream.Seek(posn, SeekOrigin.Begin);
            this._readExtraDepth--;
        }

        // Token: 0x06000200 RID: 512 RVA: 0x0000AEE0 File Offset: 0x000090E0
        private static bool ReadHeader(ZipEntry ze, Encoding defaultEncoding)
        {
            int bytesRead = 0;
            ze._RelativeOffsetOfLocalHeader = ze.ArchiveStream.Position;
            int signature = SharedUtilities.ReadEntrySignature(ze.ArchiveStream);
            bytesRead += 4;
            bool result;
            if (ZipEntry.IsNotValidSig(signature))
            {
                ze.ArchiveStream.Seek(-4L, SeekOrigin.Current);
                if (ZipEntry.IsNotValidZipDirEntrySig(signature) && (long)signature != 101010256L)
                {
                    throw new BadReadException(string.Format("  Bad signature (0x{0:X8}) at position  0x{1:X8}", signature, ze.ArchiveStream.Position));
                }
                result = false;
            }
            else
            {
                byte[] block = new byte[26];
                int i = ze.ArchiveStream.Read(block, 0, block.Length);
                if (i != block.Length)
                {
                    result = false;
                }
                else
                {
                    bytesRead += i;
                    int j = 0;
                    ze._VersionNeeded = (short)((int)block[j++] + (int)block[j++] * 256);
                    ze._BitField = (short)((int)block[j++] + (int)block[j++] * 256);
                    ze._CompressionMethod_FromZipFile = (ze._CompressionMethod = (short)((int)block[j++] + (int)block[j++] * 256));
                    ze._TimeBlob = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                    ze._LastModified = SharedUtilities.PackedToDateTime(ze._TimeBlob);
                    ze._timestamp |= ZipEntryTimestamp.DOS;
                    if ((ze._BitField & 1) == 1)
                    {
                        ze._Encryption_FromZipFile = (ze._Encryption = EncryptionAlgorithm.PkzipWeak);
                        ze._sourceIsEncrypted = true;
                    }
                    ze._Crc32 = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                    ze._CompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                    ze._UncompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                    if ((uint)ze._CompressedSize == 4294967295u || (uint)ze._UncompressedSize == 4294967295u)
                    {
                        ze._InputUsesZip64 = true;
                    }
                    short filenameLength = (short)((int)block[j++] + (int)block[j++] * 256);
                    short extraFieldLength = (short)((int)block[j++] + (int)block[j++] * 256);
                    block = new byte[(int)filenameLength];
                    i = ze.ArchiveStream.Read(block, 0, block.Length);
                    bytesRead += i;
                    if ((ze._BitField & 2048) == 2048)
                    {
                        ze.AlternateEncoding = Encoding.UTF8;
                        ze.AlternateEncodingUsage = ZipOption.Always;
                    }
                    ze._FileNameInArchive = ze.AlternateEncoding.GetString(block, 0, block.Length);
                    if (ze._FileNameInArchive.EndsWith("/"))
                    {
                        ze.MarkAsDirectory();
                    }
                    bytesRead += ze.ProcessExtraField(ze.ArchiveStream, extraFieldLength);
                    ze._LengthOfTrailer = 0;
                    if (!ze._FileNameInArchive.EndsWith("/") && (ze._BitField & 8) == 8)
                    {
                        long posn = ze.ArchiveStream.Position;
                        bool wantMore = true;
                        long SizeOfDataRead = 0L;
                        int tries = 0;
                        while (wantMore)
                        {
                            tries++;
                            if (ze._container.ZipFile != null)
                            {
                                ze._container.ZipFile.OnReadBytes(ze);
                            }
                            long d = SharedUtilities.FindSignature(ze.ArchiveStream, 134695760);
                            if (d == -1L)
                            {
                                return false;
                            }
                            SizeOfDataRead += d;
                            if (ze._InputUsesZip64)
                            {
                                block = new byte[20];
                                i = ze.ArchiveStream.Read(block, 0, block.Length);
                                if (i != 20)
                                {
                                    return false;
                                }
                                j = 0;
                                ze._Crc32 = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                                ze._CompressedSize = BitConverter.ToInt64(block, j);
                                j += 8;
                                ze._UncompressedSize = BitConverter.ToInt64(block, j);
                                j += 8;
                                ze._LengthOfTrailer += 24;
                            }
                            else
                            {
                                block = new byte[12];
                                i = ze.ArchiveStream.Read(block, 0, block.Length);
                                if (i != 12)
                                {
                                    return false;
                                }
                                j = 0;
                                ze._Crc32 = (int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256;
                                ze._CompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                                ze._UncompressedSize = (long)((ulong)((int)block[j++] + (int)block[j++] * 256 + (int)block[j++] * 256 * 256 + (int)block[j++] * 256 * 256 * 256));
                                ze._LengthOfTrailer += 16;
                            }
                            wantMore = (SizeOfDataRead != ze._CompressedSize);
                            if (wantMore)
                            {
                                ze.ArchiveStream.Seek(-12L, SeekOrigin.Current);
                                SizeOfDataRead += 4L;
                            }
                        }
                        ze.ArchiveStream.Seek(posn, SeekOrigin.Begin);
                    }
                    ze._CompressedFileDataSize = ze._CompressedSize;
                    if ((ze._BitField & 1) == 1)
                    {
                        if (ze.Encryption == EncryptionAlgorithm.WinZipAes128 || ze.Encryption == EncryptionAlgorithm.WinZipAes256)
                        {
                            int bits = ZipEntry.GetKeyStrengthInBits(ze._Encryption_FromZipFile);
                            ze._aesCrypto_forExtract = WinZipAesCrypto.ReadFromStream(null, bits, ze.ArchiveStream);
                            bytesRead += ze._aesCrypto_forExtract.SizeOfEncryptionMetadata - 10;
                            ze._CompressedFileDataSize -= (long)ze._aesCrypto_forExtract.SizeOfEncryptionMetadata;
                            ze._LengthOfTrailer += 10;
                        }
                        else
                        {
                            ze._WeakEncryptionHeader = new byte[12];
                            bytesRead += ZipEntry.ReadWeakEncryptionHeader(ze._archiveStream, ze._WeakEncryptionHeader);
                            ze._CompressedFileDataSize -= 12L;
                        }
                    }
                    ze._LengthOfHeader = bytesRead;
                    ze._TotalEntrySize = (long)ze._LengthOfHeader + ze._CompressedFileDataSize + (long)ze._LengthOfTrailer;
                    result = true;
                }
            }
            return result;
        }

        // Token: 0x06000201 RID: 513 RVA: 0x0000B6A4 File Offset: 0x000098A4
        internal static int ReadWeakEncryptionHeader(Stream s, byte[] buffer)
        {
            int additionalBytesRead = s.Read(buffer, 0, 12);
            if (additionalBytesRead != 12)
            {
                throw new ZipException(string.Format("Unexpected end of data at position 0x{0:X8}", s.Position));
            }
            return additionalBytesRead;
        }

        // Token: 0x06000202 RID: 514 RVA: 0x0000B6E8 File Offset: 0x000098E8
        private static bool IsNotValidSig(int signature)
        {
            return signature != 67324752;
        }

        /// <summary>
        ///   Reads one <c>ZipEntry</c> from the given stream.  The content for
        ///   the entry does not get decompressed or decrypted.  This method
        ///   basically reads metadata, and seeks.
        /// </summary>
        /// <param name="zc">the ZipContainer this entry belongs to.</param>
        /// <param name="first">
        ///   true of this is the first entry being read from the stream.
        /// </param>
        /// <returns>the <c>ZipEntry</c> read from the stream.</returns>
        // Token: 0x06000203 RID: 515 RVA: 0x0000B708 File Offset: 0x00009908
        internal static ZipEntry ReadEntry(ZipContainer zc, bool first)
        {
            ZipFile zf = zc.ZipFile;
            Stream s = zc.ReadStream;
            Encoding defaultEncoding = zc.AlternateEncoding;
            ZipEntry entry = new ZipEntry();
            entry._Source = ZipEntrySource.ZipFile;
            entry._container = zc;
            entry._archiveStream = s;
            if (zf != null)
            {
                zf.OnReadEntry(true, null);
            }
            if (first)
            {
                ZipEntry.HandlePK00Prefix(s);
            }
            ZipEntry result;
            if (!ZipEntry.ReadHeader(entry, defaultEncoding))
            {
                result = null;
            }
            else
            {
                entry.__FileDataPosition = entry.ArchiveStream.Position;
                s.Seek(entry._CompressedFileDataSize + (long)entry._LengthOfTrailer, SeekOrigin.Current);
                ZipEntry.HandleUnexpectedDataDescriptor(entry);
                if (zf != null)
                {
                    zf.OnReadBytes(entry);
                    zf.OnReadEntry(false, entry);
                }
                result = entry;
            }
            return result;
        }

        // Token: 0x06000204 RID: 516 RVA: 0x0000B7D0 File Offset: 0x000099D0
        internal static void HandlePK00Prefix(Stream s)
        {
            uint datum = (uint)SharedUtilities.ReadInt(s);
            if (datum != 808471376u)
            {
                s.Seek(-4L, SeekOrigin.Current);
            }
        }

        // Token: 0x06000205 RID: 517 RVA: 0x0000B800 File Offset: 0x00009A00
        private static void HandleUnexpectedDataDescriptor(ZipEntry entry)
        {
            Stream s = entry.ArchiveStream;
            uint datum = (uint)SharedUtilities.ReadInt(s);
            if ((ulong)datum == (ulong)((long)entry._Crc32))
            {
                int sz = SharedUtilities.ReadInt(s);
                if ((long)sz == entry._CompressedSize)
                {
                    sz = SharedUtilities.ReadInt(s);
                    if ((long)sz != entry._UncompressedSize)
                    {
                        s.Seek(-12L, SeekOrigin.Current);
                    }
                }
                else
                {
                    s.Seek(-8L, SeekOrigin.Current);
                }
            }
            else
            {
                s.Seek(-4L, SeekOrigin.Current);
            }
        }

        /// <summary>
        ///   Finds a particular segment in the given extra field.
        ///   This is used when modifying a previously-generated
        ///   extra field, in particular when removing the AES crypto
        ///   segment in the extra field.
        /// </summary>
        // Token: 0x06000206 RID: 518 RVA: 0x0000B894 File Offset: 0x00009A94
        internal static int FindExtraFieldSegment(byte[] extra, int offx, ushort targetHeaderId)
        {
            int i = offx;
            while (i + 3 < extra.Length)
            {
                ushort headerId = (ushort)((int)extra[i++] + (int)extra[i++] * 256);
                if (headerId == targetHeaderId)
                {
                    return i - 2;
                }
                short dataSize = (short)((int)extra[i++] + (int)extra[i++] * 256);
                i += (int)dataSize;
            }
            return -1;
        }

        /// <summary>
        ///   At current cursor position in the stream, read the extra
        ///   field, and set the properties on the ZipEntry instance
        ///   appropriately.  This can be called when processing the
        ///   Extra field in the Central Directory, or in the local
        ///   header.
        /// </summary>
        // Token: 0x06000207 RID: 519 RVA: 0x0000B900 File Offset: 0x00009B00
        internal int ProcessExtraField(Stream s, short extraFieldLength)
        {
            int additionalBytesRead = 0;
            if (extraFieldLength > 0)
            {
                byte[] buffer = this._Extra = new byte[(int)extraFieldLength];
                additionalBytesRead = s.Read(buffer, 0, buffer.Length);
                long posn = s.Position - (long)additionalBytesRead;
                int i = 0;
                while (i + 3 < buffer.Length)
                {
                    int start = i;
                    ushort headerId = (ushort)((int)buffer[i++] + (int)buffer[i++] * 256);
                    short dataSize = (short)((int)buffer[i++] + (int)buffer[i++] * 256);
                    ushort num = headerId;
                    if (num <= 21589)
                    {
                        if (num <= 10)
                        {
                            if (num != 1)
                            {
                                if (num == 10)
                                {
                                    i = this.ProcessExtraFieldWindowsTimes(buffer, i, dataSize, posn);
                                }
                            }
                            else
                            {
                                i = this.ProcessExtraFieldZip64(buffer, i, dataSize, posn);
                            }
                        }
                        else if (num != 23)
                        {
                            if (num == 21589)
                            {
                                i = this.ProcessExtraFieldUnixTimes(buffer, i, dataSize, posn);
                            }
                        }
                        else
                        {
                            i = this.ProcessExtraFieldPkwareStrongEncryption(buffer, i);
                        }
                    }
                    else if (num <= 30805)
                    {
                        if (num != 22613)
                        {
                            if (num != 30805)
                            {
                            }
                        }
                        else
                        {
                            i = this.ProcessExtraFieldInfoZipTimes(buffer, i, dataSize, posn);
                        }
                    }
                    else if (num != 30837)
                    {
                        if (num == 39169)
                        {
                            i = this.ProcessExtraFieldWinZipAes(buffer, i, dataSize, posn);
                        }
                    }
                    i = start + (int)dataSize + 4;
                }
            }
            return additionalBytesRead;
        }

        // Token: 0x06000208 RID: 520 RVA: 0x0000BA6C File Offset: 0x00009C6C
        private int ProcessExtraFieldPkwareStrongEncryption(byte[] Buffer, int j)
        {
            j += 2;
            this._UnsupportedAlgorithmId = (uint)((ushort)((int)Buffer[j++] + (int)Buffer[j++] * 256));
            this._Encryption_FromZipFile = (this._Encryption = EncryptionAlgorithm.Unsupported);
            return j;
        }

        // Token: 0x06000209 RID: 521 RVA: 0x0000BAB4 File Offset: 0x00009CB4
        private int ProcessExtraFieldWinZipAes(byte[] buffer, int j, short dataSize, long posn)
        {
            if (this._CompressionMethod == 99)
            {
                if ((this._BitField & 1) != 1)
                {
                    throw new BadReadException(string.Format("  Inconsistent metadata at position 0x{0:X16}", posn));
                }
                this._sourceIsEncrypted = true;
                if (dataSize != 7)
                {
                    throw new BadReadException(string.Format("  Inconsistent size (0x{0:X4}) in WinZip AES field at position 0x{1:X16}", dataSize, posn));
                }
                this._WinZipAesMethod = BitConverter.ToInt16(buffer, j);
                j += 2;
                if (this._WinZipAesMethod != 1 && this._WinZipAesMethod != 2)
                {
                    throw new BadReadException(string.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}", this._WinZipAesMethod, posn));
                }
                short vendorId = BitConverter.ToInt16(buffer, j);
                j += 2;
                if (vendorId != 17729)
                {
                    throw new BadReadException(string.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}", vendorId, posn));
                }
                int keystrength = (buffer[j] == 1) ? 128 : ((buffer[j] == 3) ? 256 : -1);
                if (keystrength < 0)
                {
                    throw new BadReadException(string.Format("Invalid key strength ({0})", keystrength));
                }
                this._Encryption_FromZipFile = (this._Encryption = ((keystrength == 128) ? EncryptionAlgorithm.WinZipAes128 : EncryptionAlgorithm.WinZipAes256));
                j++;
                this._CompressionMethod_FromZipFile = (this._CompressionMethod = BitConverter.ToInt16(buffer, j));
                j += 2;
            }
            return j;
        }

        // Token: 0x0600020A RID: 522 RVA: 0x0000BCA4 File Offset: 0x00009EA4
        private int ProcessExtraFieldZip64(byte[] buffer, int j, short dataSize, long posn)
        {
            unchecked
            {
                this._InputUsesZip64 = true;
                if (dataSize > 28)
                {
                    throw new BadReadException(string.Format("  Inconsistent size (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}", dataSize, posn));
                }
                int remainingData = (int)dataSize;
                ZipEntry.Func<long> slurp = delegate ()
                {
                    if (remainingData < 8)
                    {
                        throw new BadReadException(string.Format("  Missing data for ZIP64 extra field, position 0x{0:X16}", posn));
                    }
                    long x = BitConverter.ToInt64(buffer, j);
                    j += 8;
                    remainingData -= 8;
                    return x;
                };
                if (this._UncompressedSize == (long)((ulong)-1))
                {
                    this._UncompressedSize = slurp();
                }
                if (this._CompressedSize == (long)((ulong)-1))
                {
                    this._CompressedSize = slurp();
                }
                if (this._RelativeOffsetOfLocalHeader == (long)((ulong)-1))
                {
                    this._RelativeOffsetOfLocalHeader = slurp();
                }
                return j;
            }
        }

        // Token: 0x0600020B RID: 523 RVA: 0x0000BD78 File Offset: 0x00009F78
        private int ProcessExtraFieldInfoZipTimes(byte[] buffer, int j, short dataSize, long posn)
        {
            if (dataSize != 12 && dataSize != 8)
            {
                throw new BadReadException(string.Format("  Unexpected size (0x{0:X4}) for InfoZip v1 extra field at position 0x{1:X16}", dataSize, posn));
            }
            int timet = BitConverter.ToInt32(buffer, j);
            this._Mtime = ZipEntry._unixEpoch.AddSeconds((double)timet);
            j += 4;
            timet = BitConverter.ToInt32(buffer, j);
            this._Atime = ZipEntry._unixEpoch.AddSeconds((double)timet);
            j += 4;
            this._Ctime = DateTime.UtcNow;
            this._ntfsTimesAreSet = true;
            this._timestamp |= ZipEntryTimestamp.InfoZip1;
            return j;
        }

        // Token: 0x0600020C RID: 524 RVA: 0x0000BE6C File Offset: 0x0000A06C
        private int ProcessExtraFieldUnixTimes(byte[] buffer, int j, short dataSize, long posn)
        {
            if (dataSize != 13 && dataSize != 9 && dataSize != 5)
            {
                throw new BadReadException(string.Format("  Unexpected size (0x{0:X4}) for Extended Timestamp extra field at position 0x{1:X16}", dataSize, posn));
            }
            int remainingData = (int)dataSize;
            ZipEntry.Func<DateTime> slurp = delegate ()
            {
                int timet = BitConverter.ToInt32(buffer, j);
                j += 4;
                remainingData -= 4;
                return ZipEntry._unixEpoch.AddSeconds((double)timet);
            };
            if (dataSize == 13 || this._readExtraDepth > 0)
            {
                byte flag = buffer[j++];
                remainingData--;
                if ((flag & 1) != 0 && remainingData >= 4)
                {
                    this._Mtime = slurp();
                }
                this._Atime = (((flag & 2) != 0 && remainingData >= 4) ? slurp() : DateTime.UtcNow);
                this._Ctime = (((flag & 4) != 0 && remainingData >= 4) ? slurp() : DateTime.UtcNow);
                this._timestamp |= ZipEntryTimestamp.Unix;
                this._ntfsTimesAreSet = true;
                this._emitUnixTimes = true;
            }
            else
            {
                this.ReadExtraField();
            }
            return j;
        }

        // Token: 0x0600020D RID: 525 RVA: 0x0000BFBC File Offset: 0x0000A1BC
        private int ProcessExtraFieldWindowsTimes(byte[] buffer, int j, short dataSize, long posn)
        {
            if (dataSize != 32)
            {
                throw new BadReadException(string.Format("  Unexpected size (0x{0:X4}) for NTFS times extra field at position 0x{1:X16}", dataSize, posn));
            }
            j += 4;
            short timetag = (short)((int)buffer[j] + (int)buffer[j + 1] * 256);
            short addlsize = (short)((int)buffer[j + 2] + (int)buffer[j + 3] * 256);
            j += 4;
            if (timetag == 1 && addlsize == 24)
            {
                long z = BitConverter.ToInt64(buffer, j);
                this._Mtime = DateTime.FromFileTimeUtc(z);
                j += 8;
                z = BitConverter.ToInt64(buffer, j);
                this._Atime = DateTime.FromFileTimeUtc(z);
                j += 8;
                z = BitConverter.ToInt64(buffer, j);
                this._Ctime = DateTime.FromFileTimeUtc(z);
                j += 8;
                this._ntfsTimesAreSet = true;
                this._timestamp |= ZipEntryTimestamp.Windows;
                this._emitNtfsTimes = true;
            }
            return j;
        }

        // Token: 0x0600020E RID: 526 RVA: 0x0000C0A4 File Offset: 0x0000A2A4
        internal void WriteCentralDirectoryEntry(Stream s)
        {
            unchecked
            {
                byte[] bytes = new byte[4096];
                int i = 0;
                bytes[i++] = 80;
                bytes[i++] = 75;
                bytes[i++] = 1;
                bytes[i++] = 2;
                bytes[i++] = (byte)(this._VersionMadeBy & 255);
                bytes[i++] = (byte)(((int)this._VersionMadeBy & 65280) >> 8);
                short vNeeded = (short)((this.VersionNeeded != 0) ? this.VersionNeeded : 20);
                if (this._OutputUsesZip64 == null)
                {
                    this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always);
                }
                short versionNeededToExtract = (short)(this._OutputUsesZip64.Value ? 45 : vNeeded);
                if (this.CompressionMethod == CompressionMethod.BZip2)
                {
                    versionNeededToExtract = 46;
                }
                bytes[i++] = (byte)(versionNeededToExtract & 255);
                bytes[i++] = (byte)(((int)versionNeededToExtract & 65280) >> 8);
                bytes[i++] = (byte)(this._BitField & 255);
                bytes[i++] = (byte)(((int)this._BitField & 65280) >> 8);
                bytes[i++] = (byte)(this._CompressionMethod & 255);
                bytes[i++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
                if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                {
                    i -= 2;
                    bytes[i++] = 99;
                    bytes[i++] = 0;
                }
                bytes[i++] = (byte)(this._TimeBlob & 255);
                bytes[i++] = (byte)((this._TimeBlob & 65280) >> 8);
                bytes[i++] = (byte)((this._TimeBlob & 16711680) >> 16);
                bytes[i++] = (byte)(((long)this._TimeBlob & (long)((ulong)-16777216)) >> 24);
                bytes[i++] = (byte)(this._Crc32 & 255);
                bytes[i++] = (byte)((this._Crc32 & 65280) >> 8);
                bytes[i++] = (byte)((this._Crc32 & 16711680) >> 16);
                bytes[i++] = (byte)(((long)this._Crc32 & (long)((ulong)-16777216)) >> 24);
                if (this._OutputUsesZip64.Value)
                {
                    for (int j = 0; j < 8; j++)
                    {
                        bytes[i++] = byte.MaxValue;
                    }
                }
                else
                {
                    bytes[i++] = (byte)(this._CompressedSize & 255L);
                    bytes[i++] = (byte)((this._CompressedSize & 65280L) >> 8);
                    bytes[i++] = (byte)((this._CompressedSize & 16711680L) >> 16);
                    bytes[i++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
                    bytes[i++] = (byte)(this._UncompressedSize & 255L);
                    bytes[i++] = (byte)((this._UncompressedSize & 65280L) >> 8);
                    bytes[i++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
                    bytes[i++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
                }
                byte[] fileNameBytes = this.GetEncodedFileNameBytes();
                short filenameLength = (short)fileNameBytes.Length;
                bytes[i++] = (byte)(filenameLength & 255);
                bytes[i++] = (byte)(((int)filenameLength & 65280) >> 8);
                this._presumeZip64 = this._OutputUsesZip64.Value;
                this._Extra = this.ConstructExtraField(true);
                short extraFieldLength = (short)((this._Extra == null) ? 0 : this._Extra.Length);
                bytes[i++] = (byte)(extraFieldLength & 255);
                bytes[i++] = (byte)(((int)extraFieldLength & 65280) >> 8);
                int commentLength = (this._CommentBytes == null) ? 0 : this._CommentBytes.Length;
                if (commentLength + i > bytes.Length)
                {
                    commentLength = bytes.Length - i;
                }
                bytes[i++] = (byte)(commentLength & 255);
                bytes[i++] = (byte)((commentLength & 65280) >> 8);
                bool segmented = this._container.ZipFile != null && this._container.ZipFile.MaxOutputSegmentSize != 0;
                if (segmented)
                {
                    bytes[i++] = (byte)(this._diskNumber & 255u);
                    bytes[i++] = (byte)((this._diskNumber & 65280u) >> 8);
                }
                else
                {
                    bytes[i++] = 0;
                    bytes[i++] = 0;
                }
                bytes[i++] = (byte)(this._IsText ? 1 : 0);
                bytes[i++] = 0;
                bytes[i++] = (byte)(this._ExternalFileAttrs & 255);
                bytes[i++] = (byte)((this._ExternalFileAttrs & 65280) >> 8);
                bytes[i++] = (byte)((this._ExternalFileAttrs & 16711680) >> 16);
                bytes[i++] = (byte)(((long)this._ExternalFileAttrs & (long)((ulong)-16777216)) >> 24);
                if (this._RelativeOffsetOfLocalHeader > (long)((ulong)-1))
                {
                    bytes[i++] = byte.MaxValue;
                    bytes[i++] = byte.MaxValue;
                    bytes[i++] = byte.MaxValue;
                    bytes[i++] = byte.MaxValue;
                }
                else
                {
                    bytes[i++] = (byte)(this._RelativeOffsetOfLocalHeader & 255L);
                    bytes[i++] = (byte)((this._RelativeOffsetOfLocalHeader & 65280L) >> 8);
                    bytes[i++] = (byte)((this._RelativeOffsetOfLocalHeader & 16711680L) >> 16);
                    bytes[i++] = (byte)((this._RelativeOffsetOfLocalHeader & (long)((ulong)-16777216)) >> 24);
                }
                Buffer.BlockCopy(fileNameBytes, 0, bytes, i, (int)filenameLength);
                i += (int)filenameLength;
                if (this._Extra != null)
                {
                    byte[] h = this._Extra;
                    int offx = 0;
                    Buffer.BlockCopy(h, offx, bytes, i, (int)extraFieldLength);
                    i += (int)extraFieldLength;
                }
                if (commentLength != 0)
                {
                    Buffer.BlockCopy(this._CommentBytes, 0, bytes, i, commentLength);
                    i += commentLength;
                }
                s.Write(bytes, 0, i);
            }
        }

        // Token: 0x0600020F RID: 527 RVA: 0x0000C6A0 File Offset: 0x0000A8A0
        private byte[] ConstructExtraField(bool forCentralDirectory)
        {
            List<byte[]> listOfBlocks = new List<byte[]>();
            if (this._container.Zip64 == Zip64Option.Always || (this._container.Zip64 == Zip64Option.AsNecessary && (!forCentralDirectory || this._entryRequiresZip64.Value)))
            {
                int sz = 4 + (forCentralDirectory ? 28 : 16);
                byte[] block = new byte[sz];
                int i = 0;
                if (this._presumeZip64 || forCentralDirectory)
                {
                    block[i++] = 1;
                    block[i++] = 0;
                }
                else
                {
                    block[i++] = 153;
                    block[i++] = 153;
                }
                block[i++] = (byte)(sz - 4);
                block[i++] = 0;
                Array.Copy(BitConverter.GetBytes(this._UncompressedSize), 0, block, i, 8);
                i += 8;
                Array.Copy(BitConverter.GetBytes(this._CompressedSize), 0, block, i, 8);
                i += 8;
                if (forCentralDirectory)
                {
                    Array.Copy(BitConverter.GetBytes(this._RelativeOffsetOfLocalHeader), 0, block, i, 8);
                    i += 8;
                    Array.Copy(BitConverter.GetBytes(0), 0, block, i, 4);
                }
                listOfBlocks.Add(block);
            }
            if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
            {
                byte[] block = new byte[11];
                int i = 0;
                block[i++] = 1;
                block[i++] = 153;
                block[i++] = 7;
                block[i++] = 0;
                block[i++] = 1;
                block[i++] = 0;
                block[i++] = 65;
                block[i++] = 69;
                int keystrength = ZipEntry.GetKeyStrengthInBits(this.Encryption);
                if (keystrength == 128)
                {
                    block[i] = 1;
                }
                else if (keystrength == 256)
                {
                    block[i] = 3;
                }
                else
                {
                    block[i] = byte.MaxValue;
                }
                i++;
                block[i++] = (byte)(this._CompressionMethod & 255);
                block[i++] = (byte)((int)this._CompressionMethod & 65280);
                listOfBlocks.Add(block);
            }
            if (this._ntfsTimesAreSet && this._emitNtfsTimes)
            {
                byte[] block = new byte[36];
                int i = 0;
                block[i++] = 10;
                block[i++] = 0;
                block[i++] = 32;
                block[i++] = 0;
                i += 4;
                block[i++] = 1;
                block[i++] = 0;
                block[i++] = 24;
                block[i++] = 0;
                long z = this._Mtime.ToFileTime();
                Array.Copy(BitConverter.GetBytes(z), 0, block, i, 8);
                i += 8;
                z = this._Atime.ToFileTime();
                Array.Copy(BitConverter.GetBytes(z), 0, block, i, 8);
                i += 8;
                z = this._Ctime.ToFileTime();
                Array.Copy(BitConverter.GetBytes(z), 0, block, i, 8);
                i += 8;
                listOfBlocks.Add(block);
            }
            if (this._ntfsTimesAreSet && this._emitUnixTimes)
            {
                int len = 9;
                if (!forCentralDirectory)
                {
                    len += 8;
                }
                byte[] block = new byte[len];
                int i = 0;
                block[i++] = 85;
                block[i++] = 84;
                block[i++] = (byte)(len - 4);
                block[i++] = 0;
                block[i++] = 7;
                int z2 = (int)(this._Mtime - ZipEntry._unixEpoch).TotalSeconds;
                Array.Copy(BitConverter.GetBytes(z2), 0, block, i, 4);
                i += 4;
                if (!forCentralDirectory)
                {
                    z2 = (int)(this._Atime - ZipEntry._unixEpoch).TotalSeconds;
                    Array.Copy(BitConverter.GetBytes(z2), 0, block, i, 4);
                    i += 4;
                    z2 = (int)(this._Ctime - ZipEntry._unixEpoch).TotalSeconds;
                    Array.Copy(BitConverter.GetBytes(z2), 0, block, i, 4);
                    i += 4;
                }
                listOfBlocks.Add(block);
            }
            byte[] aggregateBlock = null;
            if (listOfBlocks.Count > 0)
            {
                int totalLength = 0;
                int current = 0;
                for (int i = 0; i < listOfBlocks.Count; i++)
                {
                    totalLength += listOfBlocks[i].Length;
                }
                aggregateBlock = new byte[totalLength];
                for (int i = 0; i < listOfBlocks.Count; i++)
                {
                    Array.Copy(listOfBlocks[i], 0, aggregateBlock, current, listOfBlocks[i].Length);
                    current += listOfBlocks[i].Length;
                }
            }
            return aggregateBlock;
        }

        // Token: 0x06000210 RID: 528 RVA: 0x0000CB3C File Offset: 0x0000AD3C
        private string NormalizeFileName()
        {
            string SlashFixed = this.FileName.Replace("\\", "/");
            string s;
            if (this._TrimVolumeFromFullyQualifiedPaths && this.FileName.Length >= 3 && this.FileName[1] == ':' && SlashFixed[2] == '/')
            {
                s = SlashFixed.Substring(3);
            }
            else if (this.FileName.Length >= 4 && SlashFixed[0] == '/' && SlashFixed[1] == '/')
            {
                int i = SlashFixed.IndexOf('/', 2);
                if (i == -1)
                {
                    throw new ArgumentException("The path for that entry appears to be badly formatted");
                }
                s = SlashFixed.Substring(i + 1);
            }
            else if (this.FileName.Length >= 3 && SlashFixed[0] == '.' && SlashFixed[1] == '/')
            {
                s = SlashFixed.Substring(2);
            }
            else
            {
                s = SlashFixed;
            }
            return s;
        }

        /// <summary>
        ///   generate and return a byte array that encodes the filename
        ///   for the entry.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     side effects: generate and store into _CommentBytes the
        ///     byte array for any comment attached to the entry. Also
        ///     sets _actualEncoding to indicate the actual encoding
        ///     used. The same encoding is used for both filename and
        ///     comment.
        ///   </para>
        /// </remarks>
        // Token: 0x06000211 RID: 529 RVA: 0x0000CC5C File Offset: 0x0000AE5C
        private byte[] GetEncodedFileNameBytes()
        {
            string s = this.NormalizeFileName();
            switch (this.AlternateEncodingUsage)
            {
                case ZipOption.Default:
                    if (this._Comment != null && this._Comment.Length != 0)
                    {
                        this._CommentBytes = ZipEntry.ibm437.GetBytes(this._Comment);
                    }
                    this._actualEncoding = ZipEntry.ibm437;
                    return ZipEntry.ibm437.GetBytes(s);
                case ZipOption.Always:
                    if (this._Comment != null && this._Comment.Length != 0)
                    {
                        this._CommentBytes = this.AlternateEncoding.GetBytes(this._Comment);
                    }
                    this._actualEncoding = this.AlternateEncoding;
                    return this.AlternateEncoding.GetBytes(s);
            }
            byte[] result = ZipEntry.ibm437.GetBytes(s);
            string s2 = ZipEntry.ibm437.GetString(result, 0, result.Length);
            this._CommentBytes = null;
            byte[] result2;
            if (s2 != s)
            {
                result = this.AlternateEncoding.GetBytes(s);
                if (this._Comment != null && this._Comment.Length != 0)
                {
                    this._CommentBytes = this.AlternateEncoding.GetBytes(this._Comment);
                }
                this._actualEncoding = this.AlternateEncoding;
                result2 = result;
            }
            else
            {
                this._actualEncoding = ZipEntry.ibm437;
                if (this._Comment == null || this._Comment.Length == 0)
                {
                    result2 = result;
                }
                else
                {
                    byte[] cbytes = ZipEntry.ibm437.GetBytes(this._Comment);
                    string c2 = ZipEntry.ibm437.GetString(cbytes, 0, cbytes.Length);
                    if (c2 != this.Comment)
                    {
                        result = this.AlternateEncoding.GetBytes(s);
                        this._CommentBytes = this.AlternateEncoding.GetBytes(this._Comment);
                        this._actualEncoding = this.AlternateEncoding;
                        result2 = result;
                    }
                    else
                    {
                        this._CommentBytes = cbytes;
                        result2 = result;
                    }
                }
            }
            return result2;
        }

        // Token: 0x06000212 RID: 530 RVA: 0x0000CE74 File Offset: 0x0000B074
        private bool WantReadAgain()
        {
            return this._UncompressedSize >= 16L && this._CompressionMethod != 0 && this.CompressionLevel != CompressionLevel.None && this._CompressedSize >= this._UncompressedSize && (this._Source != ZipEntrySource.Stream || this._sourceStream.CanSeek) && (this._aesCrypto_forWrite == null || this.CompressedSize - (long)this._aesCrypto_forWrite.SizeOfEncryptionMetadata > this.UncompressedSize + 16L) && (this._zipCrypto_forWrite == null || this.CompressedSize - 12L > this.UncompressedSize);
        }

        // Token: 0x06000213 RID: 531 RVA: 0x0000CF60 File Offset: 0x0000B160
        private void MaybeUnsetCompressionMethodForWriting(int cycle)
        {
            if (cycle > 1)
            {
                this._CompressionMethod = 0;
            }
            else if (this.IsDirectory)
            {
                this._CompressionMethod = 0;
            }
            else if (this._Source != ZipEntrySource.ZipFile)
            {
                if (this._Source == ZipEntrySource.Stream)
                {
                    if (this._sourceStream != null && this._sourceStream.CanSeek)
                    {
                        long fileLength = this._sourceStream.Length;
                        if (fileLength == 0L)
                        {
                            this._CompressionMethod = 0;
                            return;
                        }
                    }
                }
                else if (this._Source == ZipEntrySource.FileSystem && SharedUtilities.GetFileLength(this.LocalFileName) == 0L)
                {
                    this._CompressionMethod = 0;
                    return;
                }
                if (this.SetCompression != null)
                {
                    this.CompressionLevel = this.SetCompression(this.LocalFileName, this._FileNameInArchive);
                }
                if (this.CompressionLevel == CompressionLevel.None && this.CompressionMethod == CompressionMethod.Deflate)
                {
                    this._CompressionMethod = 0;
                }
            }
        }

        // Token: 0x06000214 RID: 532 RVA: 0x0000D088 File Offset: 0x0000B288
        internal void WriteHeader(Stream s, int cycle)
        {
            unchecked
            {
                CountingStream counter = s as CountingStream;
                this._future_ROLH = ((counter != null) ? counter.ComputedPosition : s.Position);
                int i = 0;
                byte[] block = new byte[30];
                block[i++] = 80;
                block[i++] = 75;
                block[i++] = 3;
                block[i++] = 4;
                this._presumeZip64 = (this._container.Zip64 == Zip64Option.Always || (this._container.Zip64 == Zip64Option.AsNecessary && !s.CanSeek));
                short VersionNeededToExtract = (short)(this._presumeZip64 ? 45 : 20);
                if (this.CompressionMethod == CompressionMethod.BZip2)
                {
                    VersionNeededToExtract = 46;
                }
                block[i++] = (byte)(VersionNeededToExtract & 255);
                block[i++] = (byte)(((int)VersionNeededToExtract & 65280) >> 8);
                byte[] fileNameBytes = this.GetEncodedFileNameBytes();
                short filenameLength = (short)fileNameBytes.Length;
                if (this._Encryption == EncryptionAlgorithm.None)
                {
                    this._BitField &= -2;
                }
                else
                {
                    this._BitField |= 1;
                }
                if (this._actualEncoding.CodePage == Encoding.UTF8.CodePage)
                {
                    this._BitField |= 2048;
                }
                if (this.IsDirectory || cycle == 99)
                {
                    this._BitField &= -9;
                    this._BitField &= -2;
                    this.Encryption = EncryptionAlgorithm.None;
                    this.Password = null;
                }
                else if (!s.CanSeek)
                {
                    this._BitField |= 8;
                }
                block[i++] = (byte)(this._BitField & 255);
                block[i++] = (byte)(((int)this._BitField & 65280) >> 8);
                if (this.__FileDataPosition == -1L)
                {
                    this._CompressedSize = 0L;
                    this._crcCalculated = false;
                }
                this.MaybeUnsetCompressionMethodForWriting(cycle);
                block[i++] = (byte)(this._CompressionMethod & 255);
                block[i++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
                if (cycle == 99)
                {
                    this.SetZip64Flags();
                }
                else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                {
                    i -= 2;
                    block[i++] = 99;
                    block[i++] = 0;
                }
                this._TimeBlob = SharedUtilities.DateTimeToPacked(this.LastModified);
                block[i++] = (byte)(this._TimeBlob & 255);
                block[i++] = (byte)((this._TimeBlob & 65280) >> 8);
                block[i++] = (byte)((this._TimeBlob & 16711680) >> 16);
                block[i++] = (byte)(((long)this._TimeBlob & (long)((ulong)-16777216)) >> 24);
                block[i++] = (byte)(this._Crc32 & 255);
                block[i++] = (byte)((this._Crc32 & 65280) >> 8);
                block[i++] = (byte)((this._Crc32 & 16711680) >> 16);
                block[i++] = (byte)(((long)this._Crc32 & (long)((ulong)-16777216)) >> 24);
                if (this._presumeZip64)
                {
                    for (int j = 0; j < 8; j++)
                    {
                        block[i++] = byte.MaxValue;
                    }
                }
                else
                {
                    block[i++] = (byte)(this._CompressedSize & 255L);
                    block[i++] = (byte)((this._CompressedSize & 65280L) >> 8);
                    block[i++] = (byte)((this._CompressedSize & 16711680L) >> 16);
                    block[i++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
                    block[i++] = (byte)(this._UncompressedSize & 255L);
                    block[i++] = (byte)((this._UncompressedSize & 65280L) >> 8);
                    block[i++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
                    block[i++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
                }
                block[i++] = (byte)(filenameLength & 255);
                block[i++] = (byte)(((int)filenameLength & 65280) >> 8);
                this._Extra = this.ConstructExtraField(false);
                short extraFieldLength = (short)((this._Extra == null) ? 0 : this._Extra.Length);
                block[i++] = (byte)(extraFieldLength & 255);
                block[i++] = (byte)(((int)extraFieldLength & 65280) >> 8);
                byte[] bytes = new byte[i + (int)filenameLength + (int)extraFieldLength];
                Buffer.BlockCopy(block, 0, bytes, 0, i);
                Buffer.BlockCopy(fileNameBytes, 0, bytes, i, fileNameBytes.Length);
                i += fileNameBytes.Length;
                if (this._Extra != null)
                {
                    Buffer.BlockCopy(this._Extra, 0, bytes, i, this._Extra.Length);
                    i += this._Extra.Length;
                }
                this._LengthOfHeader = i;
                ZipSegmentedStream zss = s as ZipSegmentedStream;
                if (zss != null)
                {
                    zss.ContiguousWrite = true;
                    uint requiredSegment = zss.ComputeSegment(i);
                    if (requiredSegment != zss.CurrentSegment)
                    {
                        this._future_ROLH = 0L;
                    }
                    else
                    {
                        this._future_ROLH = zss.Position;
                    }
                    this._diskNumber = requiredSegment;
                }
                if (this._container.Zip64 == Zip64Option.Default && (uint)this._RelativeOffsetOfLocalHeader >= 4294967295u)
                {
                    throw new ZipException("Offset within the zip archive exceeds 0xFFFFFFFF. Consider setting the UseZip64WhenSaving property on the ZipFile instance.");
                }
                s.Write(bytes, 0, i);
                if (zss != null)
                {
                    zss.ContiguousWrite = false;
                }
                this._EntryHeader = bytes;
            }
        }

        // Token: 0x06000215 RID: 533 RVA: 0x0000D638 File Offset: 0x0000B838
        private int FigureCrc32()
        {
            if (!this._crcCalculated)
            {
                Stream input = null;
                if (this._Source == ZipEntrySource.WriteDelegate)
                {
                    CrcCalculatorStream output = new CrcCalculatorStream(Stream.Null);
                    this._WriteDelegate(this.FileName, output);
                    this._Crc32 = output.Crc;
                }
                else if (this._Source != ZipEntrySource.ZipFile)
                {
                    if (this._Source == ZipEntrySource.Stream)
                    {
                        this.PrepSourceStream();
                        input = this._sourceStream;
                    }
                    else if (this._Source == ZipEntrySource.JitStream)
                    {
                        if (this._sourceStream == null)
                        {
                            this._sourceStream = this._OpenDelegate(this.FileName);
                        }
                        this.PrepSourceStream();
                        input = this._sourceStream;
                    }
                    else if (this._Source != ZipEntrySource.ZipOutputStream)
                    {
                        input = File.Open(this.LocalFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                    }
                    CRC32 crc32 = new CRC32();
                    this._Crc32 = crc32.GetCrc32(input);
                    if (this._sourceStream == null)
                    {
                        input.Dispose();
                    }
                }
                this._crcCalculated = true;
            }
            return this._Crc32;
        }

        /// <summary>
        ///   Stores the position of the entry source stream, or, if the position is
        ///   already stored, seeks to that position.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method is called in prep for reading the source stream.  If PKZIP
        ///   encryption is used, then we need to calc the CRC32 before doing the
        ///   encryption, because the CRC is used in the 12th byte of the PKZIP
        ///   encryption header.  So, we need to be able to seek backward in the source
        ///   when saving the ZipEntry. This method is called from the place that
        ///   calculates the CRC, and also from the method that does the encryption of
        ///   the file data.
        /// </para>
        ///
        /// <para>
        ///   The first time through, this method sets the _sourceStreamOriginalPosition
        ///   field. Subsequent calls to this method seek to that position.
        /// </para>
        /// </remarks>
        // Token: 0x06000216 RID: 534 RVA: 0x0000D790 File Offset: 0x0000B990
        private void PrepSourceStream()
        {
            if (this._sourceStream == null)
            {
                throw new ZipException(string.Format("The input stream is null for entry '{0}'.", this.FileName));
            }
            if (this._sourceStreamOriginalPosition != null)
            {
                this._sourceStream.Position = this._sourceStreamOriginalPosition.Value;
            }
            else if (this._sourceStream.CanSeek)
            {
                this._sourceStreamOriginalPosition = new long?(this._sourceStream.Position);
            }
            else if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
            {
                if (this._Source != ZipEntrySource.ZipFile && (this._BitField & 8) != 8)
                {
                    throw new ZipException("It is not possible to use PKZIP encryption on a non-seekable input stream");
                }
            }
        }

        /// <summary>
        /// Copy metadata that may have been changed by the app.  We do this when
        /// resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
        /// tries to party on that file some more, we may need to Reset() it , which
        /// means re-reading the entries and then copying the metadata.  I think.
        /// </summary>
        // Token: 0x06000217 RID: 535 RVA: 0x0000D858 File Offset: 0x0000BA58
        internal void CopyMetaData(ZipEntry source)
        {
            this.__FileDataPosition = source.__FileDataPosition;
            this.CompressionMethod = source.CompressionMethod;
            this._CompressionMethod_FromZipFile = source._CompressionMethod_FromZipFile;
            this._CompressedFileDataSize = source._CompressedFileDataSize;
            this._UncompressedSize = source._UncompressedSize;
            this._BitField = source._BitField;
            this._Source = source._Source;
            this._LastModified = source._LastModified;
            this._Mtime = source._Mtime;
            this._Atime = source._Atime;
            this._Ctime = source._Ctime;
            this._ntfsTimesAreSet = source._ntfsTimesAreSet;
            this._emitUnixTimes = source._emitUnixTimes;
            this._emitNtfsTimes = source._emitNtfsTimes;
        }

        // Token: 0x06000218 RID: 536 RVA: 0x0000D910 File Offset: 0x0000BB10
        private void OnWriteBlock(long bytesXferred, long totalBytesToXfer)
        {
            if (this._container.ZipFile != null)
            {
                this._ioOperationCanceled = this._container.ZipFile.OnSaveBlock(this, bytesXferred, totalBytesToXfer);
            }
        }

        // Token: 0x06000219 RID: 537 RVA: 0x0000D94C File Offset: 0x0000BB4C
        private void _WriteEntryData(Stream s)
        {
            Stream input = null;
            long fdp = -1L;
            try
            {
                fdp = s.Position;
            }
            catch (Exception)
            {
            }
            try
            {
                long fileLength = this.SetInputAndFigureFileLength(ref input);
                CountingStream entryCounter = new CountingStream(s);
                Stream encryptor;
                Stream compressor;
                if (fileLength != 0L)
                {
                    encryptor = this.MaybeApplyEncryption(entryCounter);
                    compressor = this.MaybeApplyCompression(encryptor, fileLength);
                }
                else
                {
                    compressor = (encryptor = entryCounter);
                }
                CrcCalculatorStream output = new CrcCalculatorStream(compressor, true);
                if (this._Source == ZipEntrySource.WriteDelegate)
                {
                    this._WriteDelegate(this.FileName, output);
                }
                else
                {
                    byte[] buffer = new byte[this.BufferSize];
                    int i;
                    while ((i = SharedUtilities.ReadWithRetry(input, buffer, 0, buffer.Length, this.FileName)) != 0)
                    {
                        output.Write(buffer, 0, i);
                        this.OnWriteBlock(output.TotalBytesSlurped, fileLength);
                        if (this._ioOperationCanceled)
                        {
                            break;
                        }
                    }
                }
                this.FinishOutputStream(s, entryCounter, encryptor, compressor, output);
            }
            finally
            {
                if (this._Source == ZipEntrySource.JitStream)
                {
                    if (this._CloseDelegate != null)
                    {
                        this._CloseDelegate(this.FileName, input);
                    }
                }
                else if (input is FileStream)
                {
                    input.Dispose();
                }
            }
            if (!this._ioOperationCanceled)
            {
                this.__FileDataPosition = fdp;
                this.PostProcessOutput(s);
            }
        }

        /// <summary>
        ///   Set the input stream and get its length, if possible.  The length is
        ///   used for progress updates, AND, to allow an optimization in case of
        ///   a stream/file of zero length. In that case we skip the Encrypt and
        ///   compression Stream. (like DeflateStream or BZip2OutputStream)
        /// </summary>
        // Token: 0x0600021A RID: 538 RVA: 0x0000DAE4 File Offset: 0x0000BCE4
        private long SetInputAndFigureFileLength(ref Stream input)
        {
            long fileLength = -1L;
            if (this._Source == ZipEntrySource.Stream)
            {
                this.PrepSourceStream();
                input = this._sourceStream;
                try
                {
                    fileLength = this._sourceStream.Length;
                }
                catch (NotSupportedException)
                {
                }
            }
            else if (this._Source == ZipEntrySource.ZipFile)
            {
                string pwd = (this._Encryption_FromZipFile == EncryptionAlgorithm.None) ? null : (this._Password ?? this._container.Password);
                this._sourceStream = this.InternalOpenReader(pwd);
                this.PrepSourceStream();
                input = this._sourceStream;
                fileLength = this._sourceStream.Length;
            }
            else if (this._Source == ZipEntrySource.JitStream)
            {
                if (this._sourceStream == null)
                {
                    this._sourceStream = this._OpenDelegate(this.FileName);
                }
                this.PrepSourceStream();
                input = this._sourceStream;
                try
                {
                    fileLength = this._sourceStream.Length;
                }
                catch (NotSupportedException)
                {
                }
            }
            else if (this._Source == ZipEntrySource.FileSystem)
            {
                FileShare fs = FileShare.ReadWrite;
                fs |= FileShare.Delete;
                input = File.Open(this.LocalFileName, FileMode.Open, FileAccess.Read, fs);
                fileLength = input.Length;
            }
            return fileLength;
        }

        // Token: 0x0600021B RID: 539 RVA: 0x0000DC4C File Offset: 0x0000BE4C
        internal void FinishOutputStream(Stream s, CountingStream entryCounter, Stream encryptor, Stream compressor, CrcCalculatorStream output)
        {
            if (output != null)
            {
                output.Close();
                if (compressor is DeflateStream)
                {
                    compressor.Close();
                }
                else if (compressor is BZip2OutputStream)
                {
                    compressor.Close();
                }
                else if (compressor is ParallelBZip2OutputStream)
                {
                    compressor.Close();
                }
                else if (compressor is ParallelDeflateOutputStream)
                {
                    compressor.Close();
                }
                encryptor.Flush();
                encryptor.Close();
                this._LengthOfTrailer = 0;
                this._UncompressedSize = output.TotalBytesSlurped;
                WinZipAesCipherStream wzacs = encryptor as WinZipAesCipherStream;
                if (wzacs != null && this._UncompressedSize > 0L)
                {
                    s.Write(wzacs.FinalAuthentication, 0, 10);
                    this._LengthOfTrailer += 10;
                }
                this._CompressedFileDataSize = entryCounter.BytesWritten;
                this._CompressedSize = this._CompressedFileDataSize;
                this._Crc32 = output.Crc;
                this.StoreRelativeOffset();
            }
        }

        // Token: 0x0600021C RID: 540 RVA: 0x0000DD60 File Offset: 0x0000BF60
        internal void PostProcessOutput(Stream s)
        {
            unchecked
            {
                CountingStream s2 = s as CountingStream;
                if (this._UncompressedSize == 0L && this._CompressedSize == 0L)
                {
                    if (this._Source == ZipEntrySource.ZipOutputStream)
                    {
                        return;
                    }
                    if (this._Password != null)
                    {
                        int headerBytesToRetract = 0;
                        if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
                        {
                            headerBytesToRetract = 12;
                        }
                        else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                        {
                            headerBytesToRetract = this._aesCrypto_forWrite._Salt.Length + this._aesCrypto_forWrite.GeneratedPV.Length;
                        }
                        if (this._Source == ZipEntrySource.ZipOutputStream && !s.CanSeek)
                        {
                            throw new ZipException("Zero bytes written, encryption in use, and non-seekable output.");
                        }
                        if (this.Encryption != EncryptionAlgorithm.None)
                        {
                            s.Seek((long)(-1 * headerBytesToRetract), SeekOrigin.Current);
                            s.SetLength(s.Position);
                            if (s2 != null)
                            {
                                s2.Adjust((long)headerBytesToRetract);
                            }
                            this._LengthOfHeader -= headerBytesToRetract;
                            this.__FileDataPosition -= (long)headerBytesToRetract;
                        }
                        this._Password = null;
                        this._BitField &= -2;
                        int i = 6;
                        this._EntryHeader[i++] = (byte)(this._BitField & 255);
                        this._EntryHeader[i++] = (byte)(((int)this._BitField & 65280) >> 8);
                        if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                        {
                            short fnLength = (short)((int)this._EntryHeader[26] + (int)this._EntryHeader[27] * 256);
                            int offx = (int)(30 + fnLength);
                            int aesIndex = ZipEntry.FindExtraFieldSegment(this._EntryHeader, offx, 39169);
                            if (aesIndex >= 0)
                            {
                                this._EntryHeader[aesIndex++] = 153;
                                this._EntryHeader[aesIndex++] = 153;
                            }
                        }
                    }
                    this.CompressionMethod = CompressionMethod.None;
                    this.Encryption = EncryptionAlgorithm.None;
                }
                else if (this._zipCrypto_forWrite != null || this._aesCrypto_forWrite != null)
                {
                    if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
                    {
                        this._CompressedSize += 12L;
                    }
                    else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                    {
                        this._CompressedSize += (long)this._aesCrypto_forWrite.SizeOfEncryptionMetadata;
                    }
                }
                int j = 8;
                this._EntryHeader[j++] = (byte)(this._CompressionMethod & 255);
                this._EntryHeader[j++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
                j = 14;
                this._EntryHeader[j++] = (byte)(this._Crc32 & 255);
                this._EntryHeader[j++] = (byte)((this._Crc32 & 65280) >> 8);
                this._EntryHeader[j++] = (byte)((this._Crc32 & 16711680) >> 16);
                this._EntryHeader[j++] = (byte)(((long)this._Crc32 & (long)((ulong)-16777216)) >> 24);
                this.SetZip64Flags();
                short filenameLength = (short)((int)this._EntryHeader[26] + (int)this._EntryHeader[27] * 256);
                short extraFieldLength = (short)((int)this._EntryHeader[28] + (int)this._EntryHeader[29] * 256);
                if (this._OutputUsesZip64.Value)
                {
                    this._EntryHeader[4] = 45;
                    this._EntryHeader[5] = 0;
                    for (int i = 0; i < 8; i++)
                    {
                        this._EntryHeader[j++] = byte.MaxValue;
                    }
                    j = (int)(30 + filenameLength);
                    this._EntryHeader[j++] = 1;
                    this._EntryHeader[j++] = 0;
                    j += 2;
                    Array.Copy(BitConverter.GetBytes(this._UncompressedSize), 0, this._EntryHeader, j, 8);
                    j += 8;
                    Array.Copy(BitConverter.GetBytes(this._CompressedSize), 0, this._EntryHeader, j, 8);
                }
                else
                {
                    this._EntryHeader[4] = 20;
                    this._EntryHeader[5] = 0;
                    j = 18;
                    this._EntryHeader[j++] = (byte)(this._CompressedSize & 255L);
                    this._EntryHeader[j++] = (byte)((this._CompressedSize & 65280L) >> 8);
                    this._EntryHeader[j++] = (byte)((this._CompressedSize & 16711680L) >> 16);
                    this._EntryHeader[j++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
                    this._EntryHeader[j++] = (byte)(this._UncompressedSize & 255L);
                    this._EntryHeader[j++] = (byte)((this._UncompressedSize & 65280L) >> 8);
                    this._EntryHeader[j++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
                    this._EntryHeader[j++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
                    if (extraFieldLength != 0)
                    {
                        j = (int)(30 + filenameLength);
                        short DataSize = (short)((int)this._EntryHeader[j + 2] + (int)this._EntryHeader[j + 3] * 256);
                        if (DataSize == 16)
                        {
                            this._EntryHeader[j++] = 153;
                            this._EntryHeader[j++] = 153;
                        }
                    }
                }
                if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                {
                    j = 8;
                    this._EntryHeader[j++] = 99;
                    this._EntryHeader[j++] = 0;
                    j = (int)(30 + filenameLength);
                    do
                    {
                        ushort HeaderId = (ushort)((int)this._EntryHeader[j] + (int)this._EntryHeader[j + 1] * 256);
                        short DataSize = (short)((int)this._EntryHeader[j + 2] + (int)this._EntryHeader[j + 3] * 256);
                        if (HeaderId != 39169)
                        {
                            j += (int)(DataSize + 4);
                        }
                        else
                        {
                            j += 9;
                            this._EntryHeader[j++] = (byte)(this._CompressionMethod & 255);
                            this._EntryHeader[j++] = (byte)((int)this._CompressionMethod & 65280);
                        }
                    }
                    while (j < (int)(extraFieldLength - 30 - filenameLength));
                }
                if ((this._BitField & 8) != 8 || (this._Source == ZipEntrySource.ZipOutputStream && s.CanSeek))
                {
                    ZipSegmentedStream zss = s as ZipSegmentedStream;
                    if (zss != null && this._diskNumber != zss.CurrentSegment)
                    {
                        using (Stream hseg = ZipSegmentedStream.ForUpdate(this._container.ZipFile.Name, this._diskNumber))
                        {
                            hseg.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
                            hseg.Write(this._EntryHeader, 0, this._EntryHeader.Length);
                        }
                    }
                    else
                    {
                        s.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
                        s.Write(this._EntryHeader, 0, this._EntryHeader.Length);
                        if (s2 != null)
                        {
                            s2.Adjust((long)this._EntryHeader.Length);
                        }
                        s.Seek(this._CompressedSize, SeekOrigin.Current);
                    }
                }
                if ((this._BitField & 8) == 8 && !this.IsDirectory)
                {
                    byte[] Descriptor = new byte[16 + (this._OutputUsesZip64.Value ? 8 : 0)];
                    j = 0;
                    Array.Copy(BitConverter.GetBytes(134695760), 0, Descriptor, j, 4);
                    j += 4;
                    Array.Copy(BitConverter.GetBytes(this._Crc32), 0, Descriptor, j, 4);
                    j += 4;
                    if (this._OutputUsesZip64.Value)
                    {
                        Array.Copy(BitConverter.GetBytes(this._CompressedSize), 0, Descriptor, j, 8);
                        j += 8;
                        Array.Copy(BitConverter.GetBytes(this._UncompressedSize), 0, Descriptor, j, 8);
                        j += 8;
                    }
                    else
                    {
                        Descriptor[j++] = (byte)(this._CompressedSize & 255L);
                        Descriptor[j++] = (byte)((this._CompressedSize & 65280L) >> 8);
                        Descriptor[j++] = (byte)((this._CompressedSize & 16711680L) >> 16);
                        Descriptor[j++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
                        Descriptor[j++] = (byte)(this._UncompressedSize & 255L);
                        Descriptor[j++] = (byte)((this._UncompressedSize & 65280L) >> 8);
                        Descriptor[j++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
                        Descriptor[j++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
                    }
                    s.Write(Descriptor, 0, Descriptor.Length);
                    this._LengthOfTrailer += Descriptor.Length;
                }
            }
        }

        // Token: 0x0600021D RID: 541 RVA: 0x0000E6E8 File Offset: 0x0000C8E8
        private void SetZip64Flags()
        {
            unchecked
            {
                this._entryRequiresZip64 = false;// new bool?(this._CompressedSize >= (long)((ulong)-1) || this._UncompressedSize >= (long)((ulong)-1) || this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
                if (this._container.Zip64 == Zip64Option.Default && this._entryRequiresZip64.Value)
                {
                    throw new ZipException("Compressed or Uncompressed size, or offset exceeds the maximum value. Consider setting the UseZip64WhenSaving property on the ZipFile instance.");
                }
                this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
            }
        }

        /// <summary>
        ///   Prepare the given stream for output - wrap it in a CountingStream, and
        ///   then in a CRC stream, and an encryptor and deflator as appropriate.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Previously this was used in ZipEntry.Write(), but in an effort to
        ///     introduce some efficiencies in that method I've refactored to put the
        ///     code inline.  This method still gets called by ZipOutputStream.
        ///   </para>
        /// </remarks>
        // Token: 0x0600021E RID: 542 RVA: 0x0000E77C File Offset: 0x0000C97C
        internal void PrepOutputStream(Stream s, long streamLength, out CountingStream outputCounter, out Stream encryptor, out Stream compressor, out CrcCalculatorStream output)
        {
            outputCounter = new CountingStream(s);
            if (streamLength != 0L)
            {
                encryptor = this.MaybeApplyEncryption(outputCounter);
                compressor = this.MaybeApplyCompression(encryptor, streamLength);
            }
            else
            {
                Stream stream;
                compressor = (stream = outputCounter);
                encryptor = stream;
            }
            output = new CrcCalculatorStream(compressor, true);
        }

        // Token: 0x0600021F RID: 543 RVA: 0x0000E7D0 File Offset: 0x0000C9D0
        private Stream MaybeApplyCompression(Stream s, long streamLength)
        {
            Stream result;
            if (this._CompressionMethod == 8 && this.CompressionLevel != CompressionLevel.None)
            {
                if (this._container.ParallelDeflateThreshold == 0L || (streamLength > this._container.ParallelDeflateThreshold && this._container.ParallelDeflateThreshold > 0L))
                {
                    if (this._container.ParallelDeflater == null)
                    {
                        this._container.ParallelDeflater = new ParallelDeflateOutputStream(s, this.CompressionLevel, this._container.Strategy, true);
                        if (this._container.CodecBufferSize > 0)
                        {
                            this._container.ParallelDeflater.BufferSize = this._container.CodecBufferSize;
                        }
                        if (this._container.ParallelDeflateMaxBufferPairs > 0)
                        {
                            this._container.ParallelDeflater.MaxBufferPairs = this._container.ParallelDeflateMaxBufferPairs;
                        }
                    }
                    ParallelDeflateOutputStream o = this._container.ParallelDeflater;
                    o.Reset(s);
                    result = o;
                }
                else
                {
                    DeflateStream o2 = new DeflateStream(s, CompressionMode.Compress, this.CompressionLevel, true);
                    if (this._container.CodecBufferSize > 0)
                    {
                        o2.BufferSize = this._container.CodecBufferSize;
                    }
                    o2.Strategy = this._container.Strategy;
                    result = o2;
                }
            }
            else if (this._CompressionMethod == 12)
            {
                if (this._container.ParallelDeflateThreshold == 0L || (streamLength > this._container.ParallelDeflateThreshold && this._container.ParallelDeflateThreshold > 0L))
                {
                    ParallelBZip2OutputStream o3 = new ParallelBZip2OutputStream(s, true);
                    result = o3;
                }
                else
                {
                    BZip2OutputStream o4 = new BZip2OutputStream(s, true);
                    result = o4;
                }
            }
            else
            {
                result = s;
            }
            return result;
        }

        // Token: 0x06000220 RID: 544 RVA: 0x0000E9C0 File Offset: 0x0000CBC0
        private Stream MaybeApplyEncryption(Stream s)
        {
            Stream result;
            if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
            {
                result = new ZipCipherStream(s, this._zipCrypto_forWrite, CryptoMode.Encrypt);
            }
            else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
            {
                result = new WinZipAesCipherStream(s, this._aesCrypto_forWrite, CryptoMode.Encrypt);
            }
            else
            {
                result = s;
            }
            return result;
        }

        // Token: 0x06000221 RID: 545 RVA: 0x0000EA24 File Offset: 0x0000CC24
        private void OnZipErrorWhileSaving(Exception e)
        {
            if (this._container.ZipFile != null)
            {
                this._ioOperationCanceled = this._container.ZipFile.OnZipErrorSaving(this, e);
            }
        }

        // Token: 0x06000222 RID: 546 RVA: 0x0000EA5C File Offset: 0x0000CC5C
        internal void Write(Stream s)
        {
            unchecked
            {
                CountingStream cs = s as CountingStream;
                ZipSegmentedStream zss = s as ZipSegmentedStream;
                bool done = false;
                do
                {
                    try
                    {
                        if (this._Source == ZipEntrySource.ZipFile && !this._restreamRequiredOnSave)
                        {
                            this.CopyThroughOneEntry(s);
                            break;
                        }
                        if (this.IsDirectory)
                        {
                            this.WriteHeader(s, 1);
                            this.StoreRelativeOffset();
                            this._entryRequiresZip64 = new bool?(this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
                            this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
                            if (zss != null)
                            {
                                this._diskNumber = zss.CurrentSegment;
                            }
                            break;
                        }
                        int nCycles = 0;
                        bool readAgain;
                        do
                        {
                            nCycles++;
                            this.WriteHeader(s, nCycles);
                            this.WriteSecurityMetadata(s);
                            this._WriteEntryData(s);
                            this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
                            readAgain = (nCycles <= 1 && s.CanSeek && this.WantReadAgain());
                            if (readAgain)
                            {
                                if (zss != null)
                                {
                                    zss.TruncateBackward(this._diskNumber, this._RelativeOffsetOfLocalHeader);
                                }
                                else
                                {
                                    s.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
                                }
                                s.SetLength(s.Position);
                                if (cs != null)
                                {
                                    cs.Adjust(this._TotalEntrySize);
                                }
                            }
                        }
                        while (readAgain);
                        this._skippedDuringSave = false;
                        done = true;
                    }
                    catch (Exception exc)
                    {
                        ZipErrorAction orig = this.ZipErrorAction;
                        int loop = 0;
                        while (this.ZipErrorAction != ZipErrorAction.Throw)
                        {
                            if (this.ZipErrorAction == ZipErrorAction.Skip || this.ZipErrorAction == ZipErrorAction.Retry)
                            {
                                long p = (cs != null) ? cs.ComputedPosition : s.Position;
                                long delta = p - this._future_ROLH;
                                if (delta > 0L)
                                {
                                    s.Seek(delta, SeekOrigin.Current);
                                    long p2 = s.Position;
                                    s.SetLength(s.Position);
                                    if (cs != null)
                                    {
                                        cs.Adjust(p - p2);
                                    }
                                }
                                if (this.ZipErrorAction == ZipErrorAction.Skip)
                                {
                                    this.WriteStatus("Skipping file {0} (exception: {1})", new object[]
                                    {
                                    this.LocalFileName,
                                    exc.ToString()
                                    });
                                    this._skippedDuringSave = true;
                                    done = true;
                                }
                                else
                                {
                                    this.ZipErrorAction = orig;
                                }
                            }
                            else
                            {
                                if (loop > 0)
                                {
                                    throw;
                                }
                                if (this.ZipErrorAction == ZipErrorAction.InvokeErrorEvent)
                                {
                                    this.OnZipErrorWhileSaving(exc);
                                    if (this._ioOperationCanceled)
                                    {
                                        done = true;
                                        goto IL_2E5;
                                    }
                                }
                                loop++;
                                continue;
                            }
                            IL_2E5:
                            goto IL_2E8;
                        }
                        throw;
                    }
                    IL_2E8:;
                }
                while (!done);
            }
        }

        // Token: 0x06000223 RID: 547 RVA: 0x0000ED80 File Offset: 0x0000CF80
        internal void StoreRelativeOffset()
        {
            this._RelativeOffsetOfLocalHeader = this._future_ROLH;
        }

        // Token: 0x06000224 RID: 548 RVA: 0x0000ED8F File Offset: 0x0000CF8F
        internal void NotifySaveComplete()
        {
            this._Encryption_FromZipFile = this._Encryption;
            this._CompressionMethod_FromZipFile = this._CompressionMethod;
            this._restreamRequiredOnSave = false;
            this._metadataChanged = false;
            this._Source = ZipEntrySource.ZipFile;
        }

        // Token: 0x06000225 RID: 549 RVA: 0x0000EDC0 File Offset: 0x0000CFC0
        internal void WriteSecurityMetadata(Stream outstream)
        {
            if (this.Encryption != EncryptionAlgorithm.None)
            {
                string pwd = this._Password;
                if (this._Source == ZipEntrySource.ZipFile && pwd == null)
                {
                    pwd = this._container.Password;
                }
                if (pwd == null)
                {
                    this._zipCrypto_forWrite = null;
                    this._aesCrypto_forWrite = null;
                }
                else if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
                {
                    this._zipCrypto_forWrite = ZipCrypto.ForWrite(pwd);
                    Random rnd = new Random();
                    byte[] encryptionHeader = new byte[12];
                    rnd.NextBytes(encryptionHeader);
                    if ((this._BitField & 8) == 8)
                    {
                        this._TimeBlob = SharedUtilities.DateTimeToPacked(this.LastModified);
                        encryptionHeader[11] = (byte)(this._TimeBlob >> 8 & 255);
                    }
                    else
                    {
                        this.FigureCrc32();
                        encryptionHeader[11] = (byte)(this._Crc32 >> 24 & 255);
                    }
                    byte[] cipherText = this._zipCrypto_forWrite.EncryptMessage(encryptionHeader, encryptionHeader.Length);
                    outstream.Write(cipherText, 0, cipherText.Length);
                    this._LengthOfHeader += cipherText.Length;
                }
                else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
                {
                    int keystrength = ZipEntry.GetKeyStrengthInBits(this.Encryption);
                    this._aesCrypto_forWrite = WinZipAesCrypto.Generate(pwd, keystrength);
                    outstream.Write(this._aesCrypto_forWrite.Salt, 0, this._aesCrypto_forWrite._Salt.Length);
                    outstream.Write(this._aesCrypto_forWrite.GeneratedPV, 0, this._aesCrypto_forWrite.GeneratedPV.Length);
                    this._LengthOfHeader += this._aesCrypto_forWrite._Salt.Length + this._aesCrypto_forWrite.GeneratedPV.Length;
                }
            }
        }

        // Token: 0x06000226 RID: 550 RVA: 0x0000EF9C File Offset: 0x0000D19C
        private void CopyThroughOneEntry(Stream outStream)
        {
            unchecked
            {
                if (this.LengthOfHeader == 0)
                {
                    throw new BadStateException("Bad header length.");
                }
                bool needRecompute = this._metadataChanged || this.ArchiveStream is ZipSegmentedStream || outStream is ZipSegmentedStream || (this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.Default) || (!this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.Always);
                if (needRecompute)
                {
                    this.CopyThroughWithRecompute(outStream);
                }
                else
                {
                    this.CopyThroughWithNoChange(outStream);
                }
                this._entryRequiresZip64 = new bool?(this._CompressedSize >= (long)((ulong)-1) || this._UncompressedSize >= (long)((ulong)-1) || this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
                this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
            }
        }

        // Token: 0x06000227 RID: 551 RVA: 0x0000F084 File Offset: 0x0000D284
        private void CopyThroughWithRecompute(Stream outstream)
        {
            unchecked
            {
                byte[] bytes = new byte[this.BufferSize];
                CountingStream input = new CountingStream(this.ArchiveStream);
                long origRelativeOffsetOfHeader = this._RelativeOffsetOfLocalHeader;
                int origLengthOfHeader = this.LengthOfHeader;
                this.WriteHeader(outstream, 0);
                this.StoreRelativeOffset();
                if (!this.FileName.EndsWith("/"))
                {
                    long pos = origRelativeOffsetOfHeader + (long)origLengthOfHeader;
                    int len = ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
                    pos -= (long)len;
                    this._LengthOfHeader += len;
                    input.Seek(pos, SeekOrigin.Begin);
                    long remaining = this._CompressedSize;
                    while (remaining > 0L)
                    {
                        len = ((remaining > (long)bytes.Length) ? bytes.Length : ((int)remaining));
                        int i = input.Read(bytes, 0, len);
                        outstream.Write(bytes, 0, i);
                        remaining -= (long)i;
                        this.OnWriteBlock(input.BytesRead, this._CompressedSize);
                        if (this._ioOperationCanceled)
                        {
                            break;
                        }
                    }
                    if ((this._BitField & 8) == 8)
                    {
                        int size = 16;
                        if (this._InputUsesZip64)
                        {
                            size += 8;
                        }
                        byte[] Descriptor = new byte[size];
                        input.Read(Descriptor, 0, size);
                        if (this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.Default)
                        {
                            outstream.Write(Descriptor, 0, 8);
                            if (this._CompressedSize > (long)((ulong)-1))
                            {
                                throw new InvalidOperationException("ZIP64 is required");
                            }
                            outstream.Write(Descriptor, 8, 4);
                            if (this._UncompressedSize > (long)((ulong)-1))
                            {
                                throw new InvalidOperationException("ZIP64 is required");
                            }
                            outstream.Write(Descriptor, 16, 4);
                            this._LengthOfTrailer -= 8;
                        }
                        else if (!this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.Always)
                        {
                            byte[] pad = new byte[4];
                            outstream.Write(Descriptor, 0, 8);
                            outstream.Write(Descriptor, 8, 4);
                            outstream.Write(pad, 0, 4);
                            outstream.Write(Descriptor, 12, 4);
                            outstream.Write(pad, 0, 4);
                            this._LengthOfTrailer += 8;
                        }
                        else
                        {
                            outstream.Write(Descriptor, 0, size);
                        }
                    }
                }
                this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
            }
        }

        // Token: 0x06000228 RID: 552 RVA: 0x0000F300 File Offset: 0x0000D500
        private void CopyThroughWithNoChange(Stream outstream)
        {
            byte[] bytes = new byte[this.BufferSize];
            CountingStream input = new CountingStream(this.ArchiveStream);
            input.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
            if (this._TotalEntrySize == 0L)
            {
                this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
            }
            CountingStream counter = outstream as CountingStream;
            this._RelativeOffsetOfLocalHeader = ((counter != null) ? counter.ComputedPosition : outstream.Position);
            long remaining = this._TotalEntrySize;
            while (remaining > 0L)
            {
                int len = (remaining > (long)bytes.Length) ? bytes.Length : ((int)remaining);
                int i = input.Read(bytes, 0, len);
                outstream.Write(bytes, 0, i);
                remaining -= (long)i;
                this.OnWriteBlock(input.BytesRead, this._TotalEntrySize);
                if (this._ioOperationCanceled)
                {
                    break;
                }
            }
        }

        // Token: 0x06000229 RID: 553 RVA: 0x0000F3F0 File Offset: 0x0000D5F0
        [Conditional("Trace")]
        private void TraceWriteLine(string format, params object[] varParams)
        {
            lock (this._outputLock)
            {
                int tid = Thread.CurrentThread.GetHashCode();
                Console.ForegroundColor = tid % 8 + ConsoleColor.DarkGray;
                Console.Write("{0:000} ZipEntry.Write ", tid);
                Console.WriteLine(format, varParams);
                Console.ResetColor();
            }
        }

        // Token: 0x040000E6 RID: 230
        private short _VersionMadeBy;

        // Token: 0x040000E7 RID: 231
        private short _InternalFileAttrs;

        // Token: 0x040000E8 RID: 232
        private int _ExternalFileAttrs;

        // Token: 0x040000E9 RID: 233
        private short _filenameLength;

        // Token: 0x040000EA RID: 234
        private short _extraFieldLength;

        // Token: 0x040000EB RID: 235
        private short _commentLength;

        // Token: 0x040000EC RID: 236
        private ZipCrypto _zipCrypto_forExtract;

        // Token: 0x040000ED RID: 237
        private ZipCrypto _zipCrypto_forWrite;

        // Token: 0x040000EE RID: 238
        private WinZipAesCrypto _aesCrypto_forExtract;

        // Token: 0x040000EF RID: 239
        private WinZipAesCrypto _aesCrypto_forWrite;

        // Token: 0x040000F0 RID: 240
        private short _WinZipAesMethod;

        // Token: 0x040000F1 RID: 241
        internal DateTime _LastModified;

        // Token: 0x040000F2 RID: 242
        private DateTime _Mtime;

        // Token: 0x040000F3 RID: 243
        private DateTime _Atime;

        // Token: 0x040000F4 RID: 244
        private DateTime _Ctime;

        // Token: 0x040000F5 RID: 245
        private bool _ntfsTimesAreSet;

        // Token: 0x040000F6 RID: 246
        private bool _emitNtfsTimes = true;

        // Token: 0x040000F7 RID: 247
        private bool _emitUnixTimes;

        // Token: 0x040000F8 RID: 248
        private bool _TrimVolumeFromFullyQualifiedPaths = true;

        // Token: 0x040000F9 RID: 249
        internal string _LocalFileName;

        // Token: 0x040000FA RID: 250
        private string _FileNameInArchive;

        // Token: 0x040000FB RID: 251
        internal short _VersionNeeded;

        // Token: 0x040000FC RID: 252
        internal short _BitField;

        // Token: 0x040000FD RID: 253
        internal short _CompressionMethod;

        // Token: 0x040000FE RID: 254
        private short _CompressionMethod_FromZipFile;

        // Token: 0x040000FF RID: 255
        private CompressionLevel _CompressionLevel;

        // Token: 0x04000100 RID: 256
        internal string _Comment;

        // Token: 0x04000101 RID: 257
        private bool _IsDirectory;

        // Token: 0x04000102 RID: 258
        private byte[] _CommentBytes;

        // Token: 0x04000103 RID: 259
        internal long _CompressedSize;

        // Token: 0x04000104 RID: 260
        internal long _CompressedFileDataSize;

        // Token: 0x04000105 RID: 261
        internal long _UncompressedSize;

        // Token: 0x04000106 RID: 262
        internal int _TimeBlob;

        // Token: 0x04000107 RID: 263
        private bool _crcCalculated;

        // Token: 0x04000108 RID: 264
        internal int _Crc32;

        // Token: 0x04000109 RID: 265
        internal byte[] _Extra;

        // Token: 0x0400010A RID: 266
        private bool _metadataChanged;

        // Token: 0x0400010B RID: 267
        private bool _restreamRequiredOnSave;

        // Token: 0x0400010C RID: 268
        private bool _sourceIsEncrypted;

        // Token: 0x0400010D RID: 269
        private bool _skippedDuringSave;

        // Token: 0x0400010E RID: 270
        private uint _diskNumber;

        // Token: 0x0400010F RID: 271
        private static Encoding ibm437 = Encoding.GetEncoding("IBM437");

        // Token: 0x04000110 RID: 272
        private Encoding _actualEncoding;

        // Token: 0x04000111 RID: 273
        internal ZipContainer _container;

        // Token: 0x04000112 RID: 274
        private long __FileDataPosition = -1L;

        // Token: 0x04000113 RID: 275
        private byte[] _EntryHeader;

        // Token: 0x04000114 RID: 276
        internal long _RelativeOffsetOfLocalHeader;

        // Token: 0x04000115 RID: 277
        private long _future_ROLH;

        // Token: 0x04000116 RID: 278
        private long _TotalEntrySize;

        // Token: 0x04000117 RID: 279
        private int _LengthOfHeader;

        // Token: 0x04000118 RID: 280
        private int _LengthOfTrailer;

        // Token: 0x04000119 RID: 281
        internal bool _InputUsesZip64;

        // Token: 0x0400011A RID: 282
        private uint _UnsupportedAlgorithmId;

        // Token: 0x0400011B RID: 283
        internal string _Password;

        // Token: 0x0400011C RID: 284
        internal ZipEntrySource _Source;

        // Token: 0x0400011D RID: 285
        internal EncryptionAlgorithm _Encryption;

        // Token: 0x0400011E RID: 286
        internal EncryptionAlgorithm _Encryption_FromZipFile;

        // Token: 0x0400011F RID: 287
        internal byte[] _WeakEncryptionHeader;

        // Token: 0x04000120 RID: 288
        internal Stream _archiveStream;

        // Token: 0x04000121 RID: 289
        private Stream _sourceStream;

        // Token: 0x04000122 RID: 290
        private long? _sourceStreamOriginalPosition;

        // Token: 0x04000123 RID: 291
        private bool _sourceWasJitProvided;

        // Token: 0x04000124 RID: 292
        private bool _ioOperationCanceled;

        // Token: 0x04000125 RID: 293
        private bool _presumeZip64;

        // Token: 0x04000126 RID: 294
        private bool? _entryRequiresZip64;

        // Token: 0x04000127 RID: 295
        private bool? _OutputUsesZip64;

        // Token: 0x04000128 RID: 296
        private bool _IsText;

        // Token: 0x04000129 RID: 297
        private ZipEntryTimestamp _timestamp;

        // Token: 0x0400012A RID: 298
        private static DateTime _unixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        // Token: 0x0400012B RID: 299
        private static DateTime _win32Epoch = DateTime.FromFileTimeUtc(0L);

        // Token: 0x0400012C RID: 300
        private static DateTime _zeroHour = new DateTime(1, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        // Token: 0x0400012D RID: 301
        private WriteDelegate _WriteDelegate;

        // Token: 0x0400012E RID: 302
        private OpenDelegate _OpenDelegate;

        // Token: 0x0400012F RID: 303
        private CloseDelegate _CloseDelegate;

        // Token: 0x04000130 RID: 304
        private Stream _inputDecryptorStream;

        // Token: 0x04000131 RID: 305
        private int _readExtraDepth;

        // Token: 0x04000132 RID: 306
        private object _outputLock = new object();

        // Token: 0x02000035 RID: 53
        private class CopyHelper
        {
            // Token: 0x0600022B RID: 555 RVA: 0x0000F4B0 File Offset: 0x0000D6B0
            internal static string AppendCopyToFileName(string f)
            {
                ZipEntry.CopyHelper.callCount++;
                if (ZipEntry.CopyHelper.callCount > 25)
                {
                    throw new OverflowException("overflow while creating filename");
                }
                int i = 1;
                int r = f.LastIndexOf(".");
                if (r == -1)
                {
                    Match j = ZipEntry.CopyHelper.re.Match(f);
                    if (j.Success)
                    {
                        i = int.Parse(j.Groups[1].Value) + 1;
                        string copy = string.Format(" (copy {0})", i);
                        f = f.Substring(0, j.Index) + copy;
                    }
                    else
                    {
                        string copy = string.Format(" (copy {0})", i);
                        f += copy;
                    }
                }
                else
                {
                    Match j = ZipEntry.CopyHelper.re.Match(f.Substring(0, r));
                    if (j.Success)
                    {
                        i = int.Parse(j.Groups[1].Value) + 1;
                        string copy = string.Format(" (copy {0})", i);
                        f = f.Substring(0, j.Index) + copy + f.Substring(r);
                    }
                    else
                    {
                        string copy = string.Format(" (copy {0})", i);
                        f = f.Substring(0, r) + copy + f.Substring(r);
                    }
                }
                return f;
            }

            // Token: 0x04000139 RID: 313
            private static Regex re = new Regex(" \\(copy (\\d+)\\)$");

            // Token: 0x0400013A RID: 314
            private static int callCount = 0;
        }

        // Token: 0x02000036 RID: 54
        // (Invoke) Token: 0x0600022F RID: 559
        private delegate T Func<T>();
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// An enum that specifies the source of the ZipEntry. 
    /// </summary>
    // Token: 0x02000002 RID: 2
    public enum ZipEntrySource
    {
        /// <summary>
        /// Default value.  Invalid on a bonafide ZipEntry.
        /// </summary>
        // Token: 0x04000002 RID: 2
        None,
        /// <summary>
        /// The entry was instantiated by calling AddFile() or another method that 
        /// added an entry from the filesystem.
        /// </summary>
        // Token: 0x04000003 RID: 3
        FileSystem,
        /// <summary>
        /// The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" /> or
        /// <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" /> .
        /// </summary>
        // Token: 0x04000004 RID: 4
        Stream,
        /// <summary>
        /// The ZipEntry was instantiated by reading a zipfile.
        /// </summary>
        // Token: 0x04000005 RID: 5
        ZipFile,
        /// <summary>
        /// The content for the ZipEntry will be or was provided by the WriteDelegate.
        /// </summary>
        // Token: 0x04000006 RID: 6
        WriteDelegate,
        /// <summary>
        /// The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
        /// The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.
        /// </summary>
        // Token: 0x04000007 RID: 7
        JitStream,
        /// <summary>
        /// The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
        /// </summary>
        // Token: 0x04000008 RID: 8
        ZipOutputStream
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   An enum that specifies the type of timestamp available on the ZipEntry.
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    ///   The last modified time of a file can be stored in multiple ways in
    ///   a zip file, and they are not mutually exclusive:
    /// </para>
    ///
    /// <list type="bullet">
    ///   <item>
    ///     In the so-called "DOS" format, which has a 2-second precision. Values
    ///     are rounded to the nearest even second. For example, if the time on the
    ///     file is 12:34:43, then it will be stored as 12:34:44. This first value
    ///     is accessible via the <c>LastModified</c> property. This value is always
    ///     present in the metadata for each zip entry.  In some cases the value is
    ///     invalid, or zero.
    ///   </item>
    ///
    ///   <item>
    ///     In the so-called "Windows" or "NTFS" format, as an 8-byte integer
    ///     quantity expressed as the number of 1/10 milliseconds (in other words
    ///     the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
    ///     format is how Windows represents file times.  This time is accessible
    ///     via the <c>ModifiedTime</c> property.
    ///   </item>
    ///
    ///   <item>
    ///     In the "Unix" format, a 4-byte quantity specifying the number of seconds since
    ///     January 1, 1970 UTC.
    ///   </item>
    ///
    ///   <item>
    ///     In an older format, now deprecated but still used by some current
    ///     tools. This format is also a 4-byte quantity specifying the number of
    ///     seconds since January 1, 1970 UTC.
    ///   </item>
    ///
    /// </list>
    ///
    /// <para>
    ///   This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
    /// </para>
    ///
    /// </remarks>
    // Token: 0x02000037 RID: 55
    [Flags]
    public enum ZipEntryTimestamp
    {
        /// <summary>
        /// Default value.
        /// </summary>
        // Token: 0x0400013C RID: 316
        None = 0,
        /// <summary>
        /// A DOS timestamp with 2-second precision.
        /// </summary>
        // Token: 0x0400013D RID: 317
        DOS = 1,
        /// <summary>
        /// A Windows timestamp with 100-ns precision.
        /// </summary>
        // Token: 0x0400013E RID: 318
        Windows = 2,
        /// <summary>
        /// A Unix timestamp with 1-second precision.
        /// </summary>
        // Token: 0x0400013F RID: 319
        Unix = 4,
        /// <summary>
        /// A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
        /// format is outdated and is supported for reading archives only.
        /// </summary>
        // Token: 0x04000140 RID: 320
        InfoZip1 = 8
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// An enum providing the options when an error occurs during opening or reading
    /// of a file or directory that is being saved to a zip file. 
    /// </summary>
    ///
    /// <remarks>
    ///  <para>
    ///    This enum describes the actions that the library can take when an error occurs
    ///    opening or reading a file, as it is being saved into a Zip archive. 
    ///  </para>
    ///
    ///  <para>
    ///     In some cases an error will occur when DotNetZip tries to open a file to be
    ///     added to the zip archive.  In other cases, an error might occur after the
    ///     file has been successfully opened, while DotNetZip is reading the file.
    ///  </para>
    ///
    ///  <para>
    ///    The first problem might occur when calling AddDirectory() on a directory
    ///    that contains a Clipper .dbf file; the file is locked by Clipper and
    ///    cannot be opened by another process. An example of the second problem is
    ///    the ERROR_LOCK_VIOLATION that results when a file is opened by another
    ///    process, but not locked, and a range lock has been taken on the file.
    ///    Microsoft Outlook takes range locks on .PST files.
    ///  </para>
    /// </remarks>
    // Token: 0x0200000A RID: 10
    public enum ZipErrorAction
    {
        /// <summary>
        /// Throw an exception when an error occurs while zipping.  This is the default
        /// behavior.  (For COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x0400004C RID: 76
        Throw,
        /// <summary>
        /// When an error occurs during zipping, for example a file cannot be opened,
        /// skip the file causing the error, and continue zipping.  (For COM clients,
        /// this is a 1.)
        /// </summary>
        // Token: 0x0400004D RID: 77
        Skip,
        /// <summary>
        /// When an error occurs during zipping, for example a file cannot be opened,
        /// retry the operation that caused the error. Be careful with this option. If
        /// the error is not temporary, the library will retry forever.  (For COM
        /// clients, this is a 2.)
        /// </summary>
        // Token: 0x0400004E RID: 78
        Retry,
        /// <summary>
        /// When an error occurs, invoke the zipError event.  The event type used is
        /// <see cref="F:Ionic.Zip.ZipProgressEventType.Error_Saving" />.  A typical use of this option:
        /// a GUI application may wish to pop up a dialog to allow the user to view the
        /// error that occurred, and choose an appropriate action.  After your
        /// processing in the error event, if you want to skip the file, set <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" /> on the
        /// <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
        /// exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
        /// to <c>Throw</c>.  If you want to cancel the zip, set
        /// <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
        /// Skip in that a cancel will not save any further entries, if there are any.
        /// (For COM clients, the value of this enum is a 3.)
        /// </summary>
        // Token: 0x0400004F RID: 79
        InvokeErrorEvent
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the an error that occurred while zipping.
    /// </summary>
    // Token: 0x02000033 RID: 51
    public class ZipErrorEventArgs : ZipProgressEventArgs
    {
        // Token: 0x06000186 RID: 390 RVA: 0x0000823C File Offset: 0x0000643C
        private ZipErrorEventArgs()
        {
        }

        // Token: 0x06000187 RID: 391 RVA: 0x00008248 File Offset: 0x00006448
        internal static ZipErrorEventArgs Saving(string archiveName, ZipEntry entry, Exception exception)
        {
            return new ZipErrorEventArgs
            {
                EventType = ZipProgressEventType.Error_Saving,
                ArchiveName = archiveName,
                CurrentEntry = entry,
                _exc = exception
            };
        }

        /// <summary>
        /// Returns the exception that occurred, if any.
        /// </summary>
        // Token: 0x1700006E RID: 110
        // (get) Token: 0x06000188 RID: 392 RVA: 0x00008284 File Offset: 0x00006484
        public Exception Exception
        {
            get
            {
                return this._exc;
            }
        }

        /// <summary>
        /// Returns the name of the file that caused the exception, if any.
        /// </summary>
        // Token: 0x1700006F RID: 111
        // (get) Token: 0x06000189 RID: 393 RVA: 0x0000829C File Offset: 0x0000649C
        public string FileName
        {
            get
            {
                return base.CurrentEntry.LocalFileName;
            }
        }

        // Token: 0x040000E5 RID: 229
        private Exception _exc;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Base class for all exceptions defined by and throw by the Zip library.
    /// </summary>
    // Token: 0x0200001E RID: 30
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00006")]
    [Serializable]
    public class ZipException : Exception
    {
        /// <summary>
        /// Default ctor.
        /// </summary>
        // Token: 0x060000F8 RID: 248 RVA: 0x00006A64 File Offset: 0x00004C64
        public ZipException()
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        // Token: 0x060000F9 RID: 249 RVA: 0x00006A6F File Offset: 0x00004C6F
        public ZipException(string message) : base(message)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="message">The message in the exception.</param>
        /// <param name="innerException">The innerException for this exception.</param>
        // Token: 0x060000FA RID: 250 RVA: 0x00006A7B File Offset: 0x00004C7B
        public ZipException(string message, Exception innerException) : base(message, innerException)
        {
        }

        /// <summary>
        /// Come on, you know how exceptions work. Why are you looking at this documentation?
        /// </summary>
        /// <param name="info">The serialization info for the exception.</param>
        /// <param name="context">The streaming context from which to deserialize.</param>
        // Token: 0x060000FB RID: 251 RVA: 0x00006A88 File Offset: 0x00004C88
        protected ZipException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   The ZipFile type represents a zip archive file.
    /// </summary>
    ///
    /// <remarks>
    /// <para>
    ///   This is the main type in the DotNetZip class library. This class reads and
    ///   writes zip files, as defined in the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
    ///   for zip files described by PKWare</see>.  The compression for this
    ///   implementation is provided by a managed-code version of Zlib, included with
    ///   DotNetZip in the classes in the Ionic.Zlib namespace.
    /// </para>
    ///
    /// <para>
    ///   This class provides a general purpose zip file capability.  Use it to read,
    ///   create, or update zip files.  When you want to create zip files using a
    ///   <c>Stream</c> type to write the zip file, you may want to consider the <see cref="T:Ionic.Zip.ZipOutputStream" /> class.
    /// </para>
    ///
    /// <para>
    ///   Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
    ///   be used to create zip files. Both of them support many of the common zip
    ///   features, including Unicode, different compression methods and levels,
    ///   and ZIP64. They provide very similar performance when creating zip
    ///   files.
    /// </para>
    ///
    /// <para>
    ///   The <c>ZipFile</c> class is generally easier to use than
    ///   <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
    ///   example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
    ///   <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
    ///   responsible for opening the file, reading the bytes from the file, writing
    ///   those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
    ///   <c>ZipEntry</c>, and setting the created, last modified, and last accessed
    ///   timestamps on the zip entry. All of these things are done automatically by a
    ///   call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
    ///   For this reason, the <c>ZipOutputStream</c> is generally recommended for use
    ///   only when your application emits arbitrary data, not necessarily data from a
    ///   filesystem file, directly into a zip file, and does so using a <c>Stream</c>
    ///   metaphor.
    /// </para>
    ///
    /// <para>
    ///   Aside from the differences in programming model, there are other
    ///   differences in capability between the two classes.
    /// </para>
    ///
    /// <list type="bullet">
    ///   <item>
    ///     <c>ZipFile</c> can be used to read and extract zip files, in addition to
    ///     creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
    ///     to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream" /> class.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipOutputStream</c> does not support the creation of segmented or spanned
    ///     zip files.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipOutputStream</c> cannot produce a self-extracting archive.
    ///   </item>
    /// </list>
    ///
    /// <para>
    ///   Be aware that the <c>ZipFile</c> class implements the <see cref="T:System.IDisposable" /> interface.  In order for <c>ZipFile</c> to
    ///   produce a valid zip file, you use use it within a using clause (<c>Using</c>
    ///   in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
    ///   for how to employ a using clause.
    /// </para>
    ///
    /// </remarks>
    // Token: 0x02000039 RID: 57
    [ComVisible(true)]
    [ClassInterface(ClassInterfaceType.AutoDispatch)]
    [Guid("ebc25cf6-9120-4283-b972-0e5520d00005")]
    public class ZipFile : IEnumerable<ZipEntry>, IEnumerable, IDisposable
    {
        /// <summary>
        ///   Adds an item, either a file or a directory, to a zip file archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method is handy if you are adding things to zip archive and don't
        ///   want to bother distinguishing between directories or files.  Any files are
        ///   added as single entries.  A directory added through this method is added
        ///   recursively: all files and subdirectories contained within the directory
        ///   are added to the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   The name of the item may be a relative path or a fully-qualified
        ///   path. Remember, the items contained in <c>ZipFile</c> instance get written
        ///   to the disk only when you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or a similar
        ///   save method.
        /// </para>
        ///
        /// <para>
        ///   The directory name used for the file within the archive is the same
        ///   as the directory name (potentially a relative path) specified in the
        ///   <paramref name="fileOrDirectoryName" />.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
        ///
        /// <overloads>This method has two overloads.</overloads>
        /// <param name="fileOrDirectoryName">
        /// the name of the file or directory to add.</param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000232 RID: 562 RVA: 0x0000F644 File Offset: 0x0000D844
        public ZipEntry AddItem(string fileOrDirectoryName)
        {
            return this.AddItem(fileOrDirectoryName, null);
        }

        /// <summary>
        ///   Adds an item, either a file or a directory, to a zip file archive,
        ///   explicitly specifying the directory path to be used in the archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   If adding a directory, the add is recursive on all files and
        ///   subdirectories contained within it.
        /// </para>
        /// <para>
        ///   The name of the item may be a relative path or a fully-qualified path.
        ///   The item added by this call to the <c>ZipFile</c> is not read from the
        ///   disk nor written to the zip file archive until the application calls
        ///   Save() on the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   This version of the method allows the caller to explicitly specify the
        ///   directory path to be used in the archive, which would override the
        ///   "natural" path of the filesystem file.
        /// </para>
        ///
        /// <para>
        ///   Encryption will be used on the file data if the <c>Password</c> has
        ///   been set on the <c>ZipFile</c> object, prior to calling this method.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:System.IO.FileNotFoundException">
        ///   Thrown if the file or directory passed in does not exist.
        /// </exception>
        ///
        /// <param name="fileOrDirectoryName">the name of the file or directory to add.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   The name of the directory path to use within the zip archive.  This path
        ///   need not refer to an extant directory in the current filesystem.  If the
        ///   files within the zip are later extracted, this is the path used for the
        ///   extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
        ///   path on the fileOrDirectoryName.  Passing the empty string ("") will
        ///   insert the item at the root path within the archive.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
        ///
        /// <example>
        ///   This example shows how to zip up a set of files into a flat hierarchy,
        ///   regardless of where in the filesystem the files originated. The resulting
        ///   zip archive will contain a toplevel directory named "flat", which itself
        ///   will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
        ///   subdirectory under "flat" called SupportFiles will contain all the files
        ///   in the "c:\SupportFiles" directory on disk.
        ///
        /// <code>
        /// String[] itemnames= {
        ///   "c:\\fixedContent\\Readme.txt",
        ///   "MyProposal.docx",
        ///   "c:\\SupportFiles",  // a directory
        ///   "images\\Image1.jpg"
        /// };
        ///
        /// try
        /// {
        ///   using (ZipFile zip = new ZipFile())
        ///   {
        ///     for (int i = 1; i &lt; itemnames.Length; i++)
        ///     {
        ///       // will add Files or Dirs, recurses and flattens subdirectories
        ///       zip.AddItem(itemnames[i],"flat");
        ///     }
        ///     zip.Save(ZipToCreate);
        ///   }
        /// }
        /// catch (System.Exception ex1)
        /// {
        ///   System.Console.Error.WriteLine("exception: {0}", ex1);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        ///   Dim itemnames As String() = _
        ///     New String() { "c:\fixedContent\Readme.txt", _
        ///                    "MyProposal.docx", _
        ///                    "SupportFiles", _
        ///                    "images\Image1.jpg" }
        ///   Try
        ///       Using zip As New ZipFile
        ///           Dim i As Integer
        ///           For i = 1 To itemnames.Length - 1
        ///               ' will add Files or Dirs, recursing and flattening subdirectories.
        ///               zip.AddItem(itemnames(i), "flat")
        ///           Next i
        ///           zip.Save(ZipToCreate)
        ///       End Using
        ///   Catch ex1 As Exception
        ///       Console.Error.WriteLine("exception: {0}", ex1.ToString())
        ///   End Try
        /// </code>
        /// </example>
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000233 RID: 563 RVA: 0x0000F660 File Offset: 0x0000D860
        public ZipEntry AddItem(string fileOrDirectoryName, string directoryPathInArchive)
        {
            ZipEntry result;
            if (File.Exists(fileOrDirectoryName))
            {
                result = this.AddFile(fileOrDirectoryName, directoryPathInArchive);
            }
            else
            {
                if (!Directory.Exists(fileOrDirectoryName))
                {
                    throw new FileNotFoundException(string.Format("That file or directory ({0}) does not exist!", fileOrDirectoryName));
                }
                result = this.AddDirectory(fileOrDirectoryName, directoryPathInArchive);
            }
            return result;
        }

        /// <summary>
        ///   Adds a File to a Zip file archive.
        /// </summary>
        /// <remarks>
        ///
        /// <para>
        ///   This call collects metadata for the named file in the filesystem,
        ///   including the file attributes and the timestamp, and inserts that metadata
        ///   into the resulting ZipEntry.  Only when the application calls Save() on
        ///   the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
        ///   then write the content to the zip file archive.
        /// </para>
        ///
        /// <para>
        ///   This method will throw an exception if an entry with the same name already
        ///   exists in the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   In this example, three files are added to a Zip archive. The ReadMe.txt
        ///   file will be placed in the root of the archive. The .png file will be
        ///   placed in a folder within the zip called photos\personal.  The pdf file
        ///   will be included into a folder within the zip called Desktop.
        /// </para>
        /// <code>
        ///    try
        ///    {
        ///      using (ZipFile zip = new ZipFile())
        ///      {
        ///        zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
        ///        zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
        ///        zip.AddFile("ReadMe.txt");
        ///
        ///        zip.Save("Package.zip");
        ///      }
        ///    }
        ///    catch (System.Exception ex1)
        ///    {
        ///      System.Console.Error.WriteLine("exception: " + ex1);
        ///    }
        /// </code>
        ///
        /// <code lang="VB">
        ///  Try
        ///       Using zip As ZipFile = New ZipFile
        ///           zip.AddFile("c:\photos\personal\7440-N49th.png")
        ///           zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
        ///           zip.AddFile("ReadMe.txt")
        ///           zip.Save("Package.zip")
        ///       End Using
        ///   Catch ex1 As Exception
        ///       Console.Error.WriteLine("exception: {0}", ex1.ToString)
        ///   End Try
        /// </code>
        /// </example>
        ///
        /// <overloads>This method has two overloads.</overloads>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
        ///
        /// <param name="fileName">
        ///   The name of the file to add. It should refer to a file in the filesystem.
        ///   The name of the file may be a relative path or a fully-qualified path.
        /// </param>
        /// <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        // Token: 0x06000234 RID: 564 RVA: 0x0000F6B0 File Offset: 0x0000D8B0
        public ZipEntry AddFile(string fileName)
        {
            return this.AddFile(fileName, null);
        }

        /// <summary>
        ///   Adds a File to a Zip file archive, potentially overriding the path to be
        ///   used within the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The file added by this call to the <c>ZipFile</c> is not written to the
        ///   zip file archive until the application calls Save() on the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   This method will throw an exception if an entry with the same name already
        ///   exists in the <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   This version of the method allows the caller to explicitly specify the
        ///   directory path to be used in the archive.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   In this example, three files are added to a Zip archive. The ReadMe.txt
        ///   file will be placed in the root of the archive. The .png file will be
        ///   placed in a folder within the zip called images.  The pdf file will be
        ///   included into a folder within the zip called files\docs, and will be
        ///   encrypted with the given password.
        /// </para>
        /// <code>
        /// try
        /// {
        ///   using (ZipFile zip = new ZipFile())
        ///   {
        ///     // the following entry will be inserted at the root in the archive.
        ///     zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
        ///     // this image file will be inserted into the "images" directory in the archive.
        ///     zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
        ///     // the following will result in a password-protected file called
        ///     // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
        ///     zip.Password = "EncryptMe!";
        ///     zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
        ///     zip.Save("Archive.zip");
        ///   }
        /// }
        /// catch (System.Exception ex1)
        /// {
        ///   System.Console.Error.WriteLine("exception: {0}", ex1);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        ///   Try
        ///       Using zip As ZipFile = New ZipFile
        ///           ' the following entry will be inserted at the root in the archive.
        ///           zip.AddFile("c:\datafiles\ReadMe.txt", "")
        ///           ' this image file will be inserted into the "images" directory in the archive.
        ///           zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
        ///           ' the following will result in a password-protected file called
        ///           ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
        ///           zip.Password = "EncryptMe!"
        ///           zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
        ///           zip.Save("Archive.zip")
        ///       End Using
        ///   Catch ex1 As Exception
        ///       Console.Error.WriteLine("exception: {0}", ex1)
        ///   End Try
        /// </code>
        /// </example>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
        ///
        /// <param name="fileName">
        ///   The name of the file to add.  The name of the file may be a relative path
        ///   or a fully-qualified path.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the fileName.
        ///   This path may, or may not, correspond to a real directory in the current
        ///   filesystem.  If the files within the zip are later extracted, this is the
        ///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
        ///   VB) will use the path on the fileName, if any.  Passing the empty string
        ///   ("") will insert the item at the root path within the archive.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        // Token: 0x06000235 RID: 565 RVA: 0x0000F6CC File Offset: 0x0000D8CC
        public ZipEntry AddFile(string fileName, string directoryPathInArchive)
        {
            string nameInArchive = ZipEntry.NameInArchive(fileName, directoryPathInArchive);
            ZipEntry ze = ZipEntry.CreateFromFile(fileName, nameInArchive);
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("adding {0}...", fileName);
            }
            return this._InternalAddEntry(ze);
        }

        /// <summary>
        ///   This method removes a collection of entries from the <c>ZipFile</c>.
        /// </summary>
        ///
        /// <param name="entriesToRemove">
        ///   A collection of ZipEntry instances from this zip file to be removed. For
        ///   example, you can pass in an array of ZipEntry instances; or you can call
        ///   SelectEntries(), and then add or remove entries from that
        ///   ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
        ///   that ICollection to this method.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        // Token: 0x06000236 RID: 566 RVA: 0x0000F714 File Offset: 0x0000D914
        public void RemoveEntries(ICollection<ZipEntry> entriesToRemove)
        {
            if (entriesToRemove == null)
            {
                throw new ArgumentNullException("entriesToRemove");
            }
            foreach (ZipEntry e in entriesToRemove)
            {
                this.RemoveEntry(e);
            }
        }

        /// <summary>
        ///   This method removes a collection of entries from the <c>ZipFile</c>, by name.
        /// </summary>
        ///
        /// <param name="entriesToRemove">
        ///   A collection of strings that refer to names of entries to be removed
        ///   from the <c>ZipFile</c>.  For example, you can pass in an array or a
        ///   List of Strings that provide the names of entries to be removed.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        // Token: 0x06000237 RID: 567 RVA: 0x0000F780 File Offset: 0x0000D980
        public void RemoveEntries(ICollection<string> entriesToRemove)
        {
            if (entriesToRemove == null)
            {
                throw new ArgumentNullException("entriesToRemove");
            }
            foreach (string e in entriesToRemove)
            {
                this.RemoveEntry(e);
            }
        }

        /// <summary>
        ///   This method adds a set of files to the <c>ZipFile</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Use this method to add a set of files to the zip archive, in one call.
        ///   For example, a list of files received from
        ///   <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
        ///   call.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        /// </remarks>
        ///
        /// <param name="fileNames">
        ///   The collection of names of the files to add. Each string should refer to a
        ///   file in the filesystem. The name of the file may be a relative path or a
        ///   fully-qualified path.
        /// </param>
        ///
        /// <example>
        ///   This example shows how to create a zip file, and add a few files into it.
        /// <code>
        /// String ZipFileToCreate = "archive1.zip";
        /// String DirectoryToZip = "c:\\reports";
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///   // Store all files found in the top level directory, into the zip archive.
        ///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
        ///   zip.AddFiles(filenames);
        ///   zip.Save(ZipFileToCreate);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim ZipFileToCreate As String = "archive1.zip"
        /// Dim DirectoryToZip As String = "c:\reports"
        /// Using zip As ZipFile = New ZipFile
        ///     ' Store all files found in the top level directory, into the zip archive.
        ///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
        ///     zip.AddFiles(filenames)
        ///     zip.Save(ZipFileToCreate)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        // Token: 0x06000238 RID: 568 RVA: 0x0000F7EC File Offset: 0x0000D9EC
        public void AddFiles(IEnumerable<string> fileNames)
        {
            this.AddFiles(fileNames, null);
        }

        /// <summary>
        ///   Adds or updates a set of files in the <c>ZipFile</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Any files that already exist in the archive are updated. Any files that
        ///   don't yet exist in the archive are added.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        /// </remarks>
        ///
        /// <param name="fileNames">
        ///   The collection of names of the files to update. Each string should refer to a file in
        ///   the filesystem. The name of the file may be a relative path or a fully-qualified path.
        /// </param>
        // Token: 0x06000239 RID: 569 RVA: 0x0000F7F8 File Offset: 0x0000D9F8
        public void UpdateFiles(IEnumerable<string> fileNames)
        {
            this.UpdateFiles(fileNames, null);
        }

        /// <summary>
        ///   Adds a set of files to the <c>ZipFile</c>, using the
        ///   specified directory path in the archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Any directory structure that may be present in the
        ///   filenames contained in the list is "flattened" in the
        ///   archive.  Each file in the list is added to the archive in
        ///   the specified top-level directory.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their respective values at the
        ///   time of this call will be applied to each ZipEntry added.
        /// </para>
        /// </remarks>
        ///
        /// <param name="fileNames">
        ///   The names of the files to add. Each string should refer to
        ///   a file in the filesystem.  The name of the file may be a
        ///   relative path or a fully-qualified path.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the file name.
        ///   Th is path may, or may not, correspond to a real directory in the current
        ///   filesystem.  If the files within the zip are later extracted, this is the
        ///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
        ///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
        ///   the empty string ("") will insert the item at the root path within the
        ///   archive.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        // Token: 0x0600023A RID: 570 RVA: 0x0000F804 File Offset: 0x0000DA04
        public void AddFiles(IEnumerable<string> fileNames, string directoryPathInArchive)
        {
            this.AddFiles(fileNames, false, directoryPathInArchive);
        }

        /// <summary>
        ///   Adds a set of files to the <c>ZipFile</c>, using the specified directory
        ///   path in the archive, and preserving the full directory structure in the
        ///   filenames.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   If preserveDirHierarchy is true, any directory structure present in the
        ///   filenames contained in the list is preserved in the archive.  On the other
        ///   hand, if preserveDirHierarchy is false, any directory structure that may
        ///   be present in the filenames contained in the list is "flattened" in the
        ///   archive; Each file in the list is added to the archive in the specified
        ///   top-level directory.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="fileNames">
        ///   The names of the files to add. Each string should refer to a file in the
        ///   filesystem.  The name of the file may be a relative path or a
        ///   fully-qualified path.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the file name.
        ///   This path may, or may not, correspond to a real directory in the current
        ///   filesystem.  If the files within the zip are later extracted, this is the
        ///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
        ///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
        ///   the empty string ("") will insert the item at the root path within the
        ///   archive.
        /// </param>
        ///
        /// <param name="preserveDirHierarchy">
        ///   whether the entries in the zip archive will reflect the directory
        ///   hierarchy that is present in the various filenames.  For example, if <paramref name="fileNames" />
        ///   includes two paths, \Animalia\Chordata\Mammalia\Info.txt and
        ///   \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method with
        ///   <paramref name="preserveDirHierarchy" /> = <c>false</c> will result in an
        ///   exception because of a duplicate entry name, while calling this method
        ///   with <paramref name="preserveDirHierarchy" /> = <c>true</c> will result in the
        ///   full direcory paths being included in the entries added to the ZipFile.
        /// </param>
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        // Token: 0x0600023B RID: 571 RVA: 0x0000F814 File Offset: 0x0000DA14
        public void AddFiles(IEnumerable<string> fileNames, bool preserveDirHierarchy, string directoryPathInArchive)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }
            this._addOperationCanceled = false;
            this.OnAddStarted();
            if (preserveDirHierarchy)
            {
                foreach (string f in fileNames)
                {
                    if (this._addOperationCanceled)
                    {
                        break;
                    }
                    if (directoryPathInArchive != null)
                    {
                        string s = Path.GetFullPath(Path.Combine(directoryPathInArchive, Path.GetDirectoryName(f)));
                        this.AddFile(f, s);
                    }
                    else
                    {
                        this.AddFile(f, null);
                    }
                }
            }
            else
            {
                foreach (string f in fileNames)
                {
                    if (this._addOperationCanceled)
                    {
                        break;
                    }
                    this.AddFile(f, directoryPathInArchive);
                }
            }
            if (!this._addOperationCanceled)
            {
                this.OnAddCompleted();
            }
        }

        /// <summary>
        ///   Adds or updates a set of files to the <c>ZipFile</c>, using the specified
        ///   directory path in the archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Any files that already exist in the archive are updated. Any files that
        ///   don't yet exist in the archive are added.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        /// </remarks>
        ///
        /// <param name="fileNames">
        ///   The names of the files to add or update. Each string should refer to a
        ///   file in the filesystem.  The name of the file may be a relative path or a
        ///   fully-qualified path.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the file name.
        ///   This path may, or may not, correspond to a real directory in the current
        ///   filesystem.  If the files within the zip are later extracted, this is the
        ///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
        ///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
        ///   the empty string ("") will insert the item at the root path within the
        ///   archive.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        // Token: 0x0600023C RID: 572 RVA: 0x0000F938 File Offset: 0x0000DB38
        public void UpdateFiles(IEnumerable<string> fileNames, string directoryPathInArchive)
        {
            if (fileNames == null)
            {
                throw new ArgumentNullException("fileNames");
            }
            this.OnAddStarted();
            foreach (string f in fileNames)
            {
                this.UpdateFile(f, directoryPathInArchive);
            }
            this.OnAddCompleted();
        }

        /// <summary>
        ///   Adds or Updates a File in a Zip file archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method adds a file to a zip archive, or, if the file already exists
        ///   in the zip archive, this method Updates the content of that given filename
        ///   in the zip archive.  The <c>UpdateFile</c> method might more accurately be
        ///   called "AddOrUpdateFile".
        /// </para>
        ///
        /// <para>
        ///   Upon success, there is no way for the application to learn whether the file
        ///   was added versus updated.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example shows how to Update an existing entry in a zipfile. The first
        ///   call to UpdateFile adds the file to the newly-created zip archive.  The
        ///   second call to UpdateFile updates the content for that file in the zip
        ///   archive.
        ///
        /// <code>
        /// using (ZipFile zip1 = new ZipFile())
        /// {
        ///   // UpdateFile might more accurately be called "AddOrUpdateFile"
        ///   zip1.UpdateFile("MyDocuments\\Readme.txt");
        ///   zip1.UpdateFile("CustomerList.csv");
        ///   zip1.Comment = "This zip archive has been created.";
        ///   zip1.Save("Content.zip");
        /// }
        ///
        /// using (ZipFile zip2 = ZipFile.Read("Content.zip"))
        /// {
        ///   zip2.UpdateFile("Updates\\Readme.txt");
        ///   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
        ///   zip2.Save();
        /// }
        ///
        /// </code>
        /// <code lang="VB">
        ///   Using zip1 As New ZipFile
        ///       ' UpdateFile might more accurately be called "AddOrUpdateFile"
        ///       zip1.UpdateFile("MyDocuments\Readme.txt")
        ///       zip1.UpdateFile("CustomerList.csv")
        ///       zip1.Comment = "This zip archive has been created."
        ///       zip1.Save("Content.zip")
        ///   End Using
        ///
        ///   Using zip2 As ZipFile = ZipFile.Read("Content.zip")
        ///       zip2.UpdateFile("Updates\Readme.txt")
        ///       zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
        ///       zip2.Save
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
        ///
        /// <param name="fileName">
        ///   The name of the file to add or update. It should refer to a file in the
        ///   filesystem.  The name of the file may be a relative path or a
        ///   fully-qualified path.
        /// </param>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> corresponding to the File that was added or updated.
        /// </returns>
        // Token: 0x0600023D RID: 573 RVA: 0x0000F9B4 File Offset: 0x0000DBB4
        public ZipEntry UpdateFile(string fileName)
        {
            return this.UpdateFile(fileName, null);
        }

        /// <summary>
        ///   Adds or Updates a File in a Zip file archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method adds a file to a zip archive, or, if the file already exists
        ///   in the zip archive, this method Updates the content of that given filename
        ///   in the zip archive.
        /// </para>
        ///
        /// <para>
        ///   This version of the method allows the caller to explicitly specify the
        ///   directory path to be used in the archive.  The entry to be added or
        ///   updated is found by using the specified directory path, combined with the
        ///   basename of the specified filename.
        /// </para>
        ///
        /// <para>
        ///   Upon success, there is no way for the application to learn if the file was
        ///   added versus updated.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
        ///
        /// <param name="fileName">
        ///   The name of the file to add or update. It should refer to a file in the
        ///   filesystem.  The name of the file may be a relative path or a
        ///   fully-qualified path.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the
        ///   <c>fileName</c>.  This path may, or may not, correspond to a real
        ///   directory in the current filesystem.  If the files within the zip are
        ///   later extracted, this is the path used for the extracted file.  Passing
        ///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
        ///   <c>fileName</c>, if any.  Passing the empty string ("") will insert the
        ///   item at the root path within the archive.
        /// </param>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> corresponding to the File that was added or updated.
        /// </returns>
        // Token: 0x0600023E RID: 574 RVA: 0x0000F9D0 File Offset: 0x0000DBD0
        public ZipEntry UpdateFile(string fileName, string directoryPathInArchive)
        {
            string key = ZipEntry.NameInArchive(fileName, directoryPathInArchive);
            if (this[key] != null)
            {
                this.RemoveEntry(key);
            }
            return this.AddFile(fileName, directoryPathInArchive);
        }

        /// <summary>
        ///   Add or update a directory in a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///   If the specified directory does not exist in the archive, then this method
        ///   is equivalent to calling <c>AddDirectory()</c>.  If the specified
        ///   directory already exists in the archive, then this method updates any
        ///   existing entries, and adds any new entries. Any entries that are in the
        ///   zip archive but not in the specified directory, are left alone.  In other
        ///   words, the contents of the zip file will be a union of the previous
        ///   contents and the new files.
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
        ///
        /// <param name="directoryName">
        ///   The path to the directory to be added to the zip archive, or updated in
        ///   the zip archive.
        /// </param>
        ///
        /// <returns>
        /// The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
        /// </returns>
        // Token: 0x0600023F RID: 575 RVA: 0x0000FA08 File Offset: 0x0000DC08
        public ZipEntry UpdateDirectory(string directoryName)
        {
            return this.UpdateDirectory(directoryName, null);
        }

        /// <summary>
        ///   Add or update a directory in the zip archive at the specified root
        ///   directory in the archive.
        /// </summary>
        ///
        /// <remarks>
        ///   If the specified directory does not exist in the archive, then this method
        ///   is equivalent to calling <c>AddDirectory()</c>.  If the specified
        ///   directory already exists in the archive, then this method updates any
        ///   existing entries, and adds any new entries. Any entries that are in the
        ///   zip archive but not in the specified directory, are left alone.  In other
        ///   words, the contents of the zip file will be a union of the previous
        ///   contents and the new files.
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
        ///
        /// <param name="directoryName">
        ///   The path to the directory to be added to the zip archive, or updated
        ///   in the zip archive.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the
        ///   <c>directoryName</c>.  This path may, or may not, correspond to a real
        ///   directory in the current filesystem.  If the files within the zip are
        ///   later extracted, this is the path used for the extracted file.  Passing
        ///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
        ///   <c>directoryName</c>, if any.  Passing the empty string ("") will insert
        ///   the item at the root path within the archive.
        /// </param>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
        /// </returns>
        // Token: 0x06000240 RID: 576 RVA: 0x0000FA24 File Offset: 0x0000DC24
        public ZipEntry UpdateDirectory(string directoryName, string directoryPathInArchive)
        {
            return this.AddOrUpdateDirectoryImpl(directoryName, directoryPathInArchive, AddOrUpdateAction.AddOrUpdate);
        }

        /// <summary>
        ///   Add or update a file or directory in the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This is useful when the application is not sure or does not care if the
        ///   item to be added is a file or directory, and does not know or does not
        ///   care if the item already exists in the <c>ZipFile</c>. Calling this method
        ///   is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
        ///   already exists, followed calling by <c>AddItem()</c>.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
        ///
        /// <param name="itemName">
        ///  the path to the file or directory to be added or updated.
        /// </param>
        // Token: 0x06000241 RID: 577 RVA: 0x0000FA3F File Offset: 0x0000DC3F
        public void UpdateItem(string itemName)
        {
            this.UpdateItem(itemName, null);
        }

        /// <summary>
        ///   Add or update a file or directory.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method is useful when the application is not sure or does not care if
        ///   the item to be added is a file or directory, and does not know or does not
        ///   care if the item already exists in the <c>ZipFile</c>. Calling this method
        ///   is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
        ///   exists, and then calling <c>AddItem()</c>.
        /// </para>
        ///
        /// <para>
        ///   This version of the method allows the caller to explicitly specify the
        ///   directory path to be used for the item being added to the archive.  The
        ///   entry or entries that are added or updated will use the specified
        ///   <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
        ///   result in a file stored in that directory path.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
        ///
        /// <param name="itemName">
        ///   The path for the File or Directory to be added or updated.
        /// </param>
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the
        ///   <c>itemName</c>.  This path may, or may not, correspond to a real
        ///   directory in the current filesystem.  If the files within the zip are
        ///   later extracted, this is the path used for the extracted file.  Passing
        ///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
        ///   <c>itemName</c>, if any.  Passing the empty string ("") will insert the
        ///   item at the root path within the archive.
        /// </param>
        // Token: 0x06000242 RID: 578 RVA: 0x0000FA4C File Offset: 0x0000DC4C
        public void UpdateItem(string itemName, string directoryPathInArchive)
        {
            if (File.Exists(itemName))
            {
                this.UpdateFile(itemName, directoryPathInArchive);
            }
            else
            {
                if (!Directory.Exists(itemName))
                {
                    throw new FileNotFoundException(string.Format("That file or directory ({0}) does not exist!", itemName));
                }
                this.UpdateDirectory(itemName, directoryPathInArchive);
            }
        }

        /// <summary>
        ///   Adds a named entry into the zip archive, taking content for the entry
        ///   from a string.
        /// </summary>
        ///
        /// <remarks>
        ///   Calling this method creates an entry using the given fileName and
        ///   directory path within the archive.  There is no need for a file by the
        ///   given name to exist in the filesystem; the name is used within the zip
        ///   archive only. The content for the entry is encoded using the default text
        ///   encoding for the machine, or on Silverlight, using UTF-8.
        /// </remarks>
        ///
        /// <param name="content">
        ///   The content of the file, should it be extracted from the zip.
        /// </param>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use for the entry within the archive.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        ///
        /// <example>
        ///
        /// This example shows how to add an entry to the zipfile, using a string as
        /// content for that entry.
        ///
        /// <code lang="C#">
        /// string Content = "This string will be the content of the Readme.txt file in the zip archive.";
        /// using (ZipFile zip1 = new ZipFile())
        /// {
        ///   zip1.AddFile("MyDocuments\\Resume.doc", "files");
        ///   zip1.AddEntry("Readme.txt", Content);
        ///   zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
        ///   zip1.Save("Content.zip");
        /// }
        ///
        /// </code>
        /// <code lang="VB">
        /// Public Sub Run()
        ///   Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
        ///   Using zip1 As ZipFile = New ZipFile
        ///     zip1.AddEntry("Readme.txt", Content)
        ///     zip1.AddFile("MyDocuments\Resume.doc", "files")
        ///     zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
        ///     zip1.Save("Content.zip")
        ///   End Using
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x06000243 RID: 579 RVA: 0x0000FA9C File Offset: 0x0000DC9C
        public ZipEntry AddEntry(string entryName, string content)
        {
            return this.AddEntry(entryName, content, Encoding.Default);
        }

        /// <summary>
        ///   Adds a named entry into the zip archive, taking content for the entry
        ///   from a string, and using the specified text encoding.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Calling this method creates an entry using the given fileName and
        ///   directory path within the archive.  There is no need for a file by the
        ///   given name to exist in the filesystem; the name is used within the zip
        ///   archive only.
        /// </para>
        ///
        /// <para>
        ///   The content for the entry, a string value, is encoded using the given
        ///   text encoding. A BOM (byte-order-mark) is emitted into the file, if the
        ///   Encoding parameter is set for that.
        /// </para>
        ///
        /// <para>
        ///   Most Encoding classes support a constructor that accepts a boolean,
        ///   indicating whether to emit a BOM or not. For example see <see cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="content">
        ///   The content of the file, should it be extracted from the zip.
        /// </param>
        ///
        /// <param name="encoding">
        ///   The text encoding to use when encoding the string. Be aware: This is
        ///   distinct from the text encoding used to encode the fileName, as specified
        ///   in <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000244 RID: 580 RVA: 0x0000FABC File Offset: 0x0000DCBC
        public ZipEntry AddEntry(string entryName, string content, Encoding encoding)
        {
            MemoryStream ms = new MemoryStream();
            StreamWriter sw = new StreamWriter(ms, encoding);
            sw.Write(content);
            sw.Flush();
            ms.Seek(0L, SeekOrigin.Begin);
            return this.AddEntry(entryName, ms);
        }

        /// <summary>
        ///   Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
        ///   as input.  The entry will have the given filename.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   The application should provide an open, readable stream; in this case it
        ///   will be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of
        ///   its overloads.
        /// </para>
        ///
        /// <para>
        ///   The passed stream will be read from its current position. If
        ///   necessary, callers should set the position in the stream before
        ///   calling AddEntry(). This might be appropriate when using this method
        ///   with a MemoryStream, for example.
        /// </para>
        ///
        /// <para>
        ///   In cases where a large number of streams will be added to the
        ///   <c>ZipFile</c>, the application may wish to avoid maintaining all of the
        ///   streams open simultaneously.  To handle this situation, the application
        ///   should use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
        ///   overload.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
        /// </para>
        ///
        /// <code lang="C#">
        /// String zipToCreate = "Content.zip";
        /// String fileNameInArchive = "Content-From-Stream.bin";
        /// using (System.IO.Stream streamToRead = MyStreamOpener())
        /// {
        ///   using (ZipFile zip = new ZipFile())
        ///   {
        ///     ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
        ///     zip.AddFile("Readme.txt");
        ///     zip.Save(zipToCreate);  // the stream is read implicitly here
        ///   }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim zipToCreate As String = "Content.zip"
        /// Dim fileNameInArchive As String = "Content-From-Stream.bin"
        /// Using streamToRead as System.IO.Stream = MyStreamOpener()
        ///   Using zip As ZipFile = New ZipFile()
        ///     Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
        ///     zip.AddFile("Readme.txt")
        ///     zip.Save(zipToCreate)  '' the stream is read implicitly, here
        ///   End Using
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)" />
        ///
        /// <param name="entryName">
        ///   The name, including any path, which is shown in the zip file for the added
        ///   entry.
        /// </param>
        /// <param name="stream">
        ///   The input stream from which to grab content for the file
        /// </param>
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000245 RID: 581 RVA: 0x0000FB00 File Offset: 0x0000DD00
        public ZipEntry AddEntry(string entryName, Stream stream)
        {
            ZipEntry ze = ZipEntry.CreateForStream(entryName, stream);
            ze.SetEntryTimes(DateTime.Now, DateTime.Now, DateTime.Now);
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("adding {0}...", entryName);
            }
            return this._InternalAddEntry(ze);
        }

        /// <summary>
        ///   Add a ZipEntry for which content is written directly by the application.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   When the application needs to write the zip entry data, use this
        ///   method to add the ZipEntry. For example, in the case that the
        ///   application wishes to write the XML representation of a DataSet into
        ///   a ZipEntry, the application can use this method to do so.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// <para>
        ///   About progress events: When using the WriteDelegate, DotNetZip does
        ///   not issue any SaveProgress events with <c>EventType</c> = <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
        ///   Saving_EntryBytesRead</see>. (This is because it is the
        ///   application's code that runs in WriteDelegate - there's no way for
        ///   DotNetZip to know when to issue a EntryBytesRead event.)
        ///   Applications that want to update a progress bar or similar status
        ///   indicator should do so from within the WriteDelegate
        ///   itself. DotNetZip will issue the other SaveProgress events,
        ///   including <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
        ///   Saving_Started</see>,
        ///   <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
        ///   Saving_BeforeWriteEntry</see>, and <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
        ///   Saving_AfterWriteEntry</see>.
        /// </para>
        ///
        /// <para>
        ///   Note: When you use PKZip encryption, it's normally necessary to
        ///   compute the CRC of the content to be encrypted, before compressing or
        ///   encrypting it. Therefore, when using PKZip encryption with a
        ///   WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
        ///   the CRC, and the second time to potentially compress and
        ///   encrypt. Surprising, but true. This is because PKWARE specified that
        ///   the encryption initialization data depends on the CRC.
        ///   If this happens, for each call of the delegate, your
        ///   application must stream the same entry data in its entirety. If your
        ///   application writes different data during the second call, it will
        ///   result in a corrupt zip file.
        /// </para>
        ///
        /// <para>
        ///   The double-read behavior happens with all types of entries, not only
        ///   those that use WriteDelegate. It happens if you add an entry from a
        ///   filesystem file, or using a string, or a stream, or an opener/closer
        ///   pair. But in those cases, DotNetZip takes care of reading twice; in
        ///   the case of the WriteDelegate, the application code gets invoked
        ///   twice. Be aware.
        /// </para>
        ///
        /// <para>
        ///   As you can imagine, this can cause performance problems for large
        ///   streams, and it can lead to correctness problems when you use a
        ///   <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
        ///   ways to avoid it.  First, and most preferred: don't use PKZIP
        ///   encryption.  If you use the WinZip AES encryption, this problem
        ///   doesn't occur, because the encryption protocol doesn't require the CRC
        ///   up front. Second: if you do choose to use PKZIP encryption, write out
        ///   to a non-seekable stream (like standard output, or the
        ///   Response.OutputStream in an ASP.NET application).  In this case,
        ///   DotNetZip will use an alternative encryption protocol that does not
        ///   rely on the CRC of the content.  This also implies setting bit 3 in
        ///   the zip entry, which still presents problems for some zip tools.
        /// </para>
        ///
        /// <para>
        ///   In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
        ///   encryption is in use.  This seems like a win overall, but there will
        ///   be some work involved.  If you feel strongly about it, visit the
        ///   DotNetZip forums and vote up <see href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
        ///   tracking this issue</see>.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="entryName">the name of the entry to add</param>
        /// <param name="writer">the delegate which will write the entry content</param>
        /// <returns>the ZipEntry added</returns>
        ///
        /// <example>
        ///
        ///   This example shows an application filling a DataSet, then saving the
        ///   contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
        ///   anonymous delegate in C#. The DataSet XML is never saved to a disk file.
        ///
        /// <code lang="C#">
        /// var c1= new System.Data.SqlClient.SqlConnection(connstring1);
        /// var da = new System.Data.SqlClient.SqlDataAdapter()
        ///     {
        ///         SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
        ///     };
        ///
        /// DataSet ds1 = new DataSet();
        /// da.Fill(ds1, "Invoices");
        ///
        /// using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
        /// {
        ///     zip.AddEntry(zipEntryName, (name,stream) =&gt; ds1.WriteXml(stream) );
        ///     zip.Save(zipFileName);
        /// }
        /// </code>
        /// </example>
        ///
        /// <example>
        ///
        /// This example uses an anonymous method in C# as the WriteDelegate to provide
        /// the data for the ZipEntry. The example is a bit contrived - the
        /// <c>AddFile()</c> method is a simpler way to insert the contents of a file
        /// into an entry in a zip file. On the other hand, if there is some sort of
        /// processing or transformation of the file contents required before writing,
        /// the application could use the <c>WriteDelegate</c> to do it, in this way.
        ///
        /// <code lang="C#">
        /// using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
        /// {
        ///     using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
        ///     {
        ///         zip.AddEntry(zipEntryName, (name,output) =&gt;
        ///             {
        ///                 byte[] buffer = new byte[BufferSize];
        ///                 int n;
        ///                 while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
        ///                 {
        ///                     // could transform the data here...
        ///                     output.Write(buffer, 0, n);
        ///                     // could update a progress bar here
        ///                 }
        ///             });
        ///
        ///         zip.Save(zipFileName);
        ///     }
        /// }
        /// </code>
        /// </example>
        ///
        /// <example>
        ///
        /// This example uses a named delegate in VB to write data for the given
        /// ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
        /// contrived - a simpler way to add the contents of a file to a ZipEntry is to
        /// simply use the appropriate <c>AddFile()</c> method.  The key scenario for
        /// which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
        /// format, to the zip file. The DataSet can write XML to a stream, and the
        /// WriteDelegate is the perfect place to write into the zip file.  There may be
        /// other data structures that can write to a stream, but cannot be read as a
        /// stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
        /// well.
        ///
        /// <code lang="VB">
        /// Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
        ///     Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
        ///         Dim n As Integer = -1
        ///         Dim buffer As Byte() = New Byte(BufferSize){}
        ///         Do While n &lt;&gt; 0
        ///             n = input.Read(buffer, 0, buffer.Length)
        ///             output.Write(buffer, 0, n)
        ///         Loop
        ///     End Using
        /// End Sub
        ///
        /// Public Sub Run()
        ///     Using zip = New ZipFile
        ///         zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
        ///         zip.Save(zipFileName)
        ///     End Using
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x06000246 RID: 582 RVA: 0x0000FB58 File Offset: 0x0000DD58
        public ZipEntry AddEntry(string entryName, WriteDelegate writer)
        {
            ZipEntry ze = ZipEntry.CreateForWriter(entryName, writer);
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("adding {0}...", entryName);
            }
            return this._InternalAddEntry(ze);
        }

        /// <summary>
        ///   Add an entry, for which the application will provide a stream,
        ///   just-in-time.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   In cases where the application wishes to open the stream that holds
        ///   the content for the ZipEntry, on a just-in-time basis, the application
        ///   can use this method and provide delegates to open and close the
        ///   stream.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example uses anonymous methods in C# to open and close the
        ///   source stream for the content for a zip entry.  In a real
        ///   application, the logic for the OpenDelegate would probably be more
        ///   involved.
        ///
        /// <code lang="C#">
        /// using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
        /// {
        ///     zip.AddEntry(zipEntryName,
        ///                  (name) =&gt;  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
        ///                  (name, stream) =&gt;  stream.Close()
        ///                  );
        ///
        ///     zip.Save(zipFileName);
        /// }
        /// </code>
        ///
        /// </example>
        ///
        /// <example>
        ///
        ///   This example uses delegates in VB.NET to open and close the
        ///   the source stream for the content for a zip entry.  VB 9.0 lacks
        ///   support for "Sub" lambda expressions, and so the CloseDelegate must
        ///   be an actual, named Sub.
        ///
        /// <code lang="VB">
        ///
        /// Function MyStreamOpener(ByVal entryName As String) As Stream
        ///     '' This simply opens a file.  You probably want to do somethinig
        ///     '' more involved here: open a stream to read from a database,
        ///     '' open a stream on an HTTP connection, and so on.
        ///     Return File.OpenRead(entryName)
        /// End Function
        ///
        /// Sub MyStreamCloser(entryName As String, stream As Stream)
        ///     stream.Close()
        /// End Sub
        ///
        /// Public Sub Run()
        ///     Dim dirToZip As String = "fodder"
        ///     Dim zipFileToCreate As String = "Archive.zip"
        ///     Dim opener As OpenDelegate = AddressOf MyStreamOpener
        ///     Dim closer As CloseDelegate = AddressOf MyStreamCloser
        ///     Dim numFilestoAdd As Int32 = 4
        ///     Using zip As ZipFile = New ZipFile
        ///         Dim i As Integer
        ///         For i = 0 To numFilesToAdd - 1
        ///             zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
        ///         Next i
        ///         zip.Save(zipFileToCreate)
        ///     End Using
        /// End Sub
        ///
        /// </code>
        /// </example>
        ///
        /// <param name="entryName">the name of the entry to add</param>
        /// <param name="opener">
        ///  the delegate that will be invoked to open the stream
        /// </param>
        /// <param name="closer">
        ///  the delegate that will be invoked to close the stream
        /// </param>
        /// <returns>the ZipEntry added</returns>
        // Token: 0x06000247 RID: 583 RVA: 0x0000FB98 File Offset: 0x0000DD98
        public ZipEntry AddEntry(string entryName, OpenDelegate opener, CloseDelegate closer)
        {
            ZipEntry ze = ZipEntry.CreateForJitStreamProvider(entryName, opener, closer);
            ze.SetEntryTimes(DateTime.Now, DateTime.Now, DateTime.Now);
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("adding {0}...", entryName);
            }
            return this._InternalAddEntry(ze);
        }

        // Token: 0x06000248 RID: 584 RVA: 0x0000FBF0 File Offset: 0x0000DDF0
        private ZipEntry _InternalAddEntry(ZipEntry ze)
        {
            ze._container = new ZipContainer(this);
            ze.CompressionMethod = this.CompressionMethod;
            ze.CompressionLevel = this.CompressionLevel;
            ze.ExtractExistingFile = this.ExtractExistingFile;
            ze.ZipErrorAction = this.ZipErrorAction;
            ze.SetCompression = this.SetCompression;
            ze.AlternateEncoding = this.AlternateEncoding;
            ze.AlternateEncodingUsage = this.AlternateEncodingUsage;
            ze.Password = this._Password;
            ze.Encryption = this.Encryption;
            ze.EmitTimesInWindowsFormatWhenSaving = this._emitNtfsTimes;
            ze.EmitTimesInUnixFormatWhenSaving = this._emitUnixTimes;
            this.InternalAddEntry(ze.FileName, ze);
            this.AfterAddEntry(ze);
            return ze;
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given
        ///   string as content for the <c>ZipEntry</c>.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Calling this method is equivalent to removing the <c>ZipEntry</c> for
        ///   the given file name and directory path, if it exists, and then calling
        ///   <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" />.  See the documentation for
        ///   that method for further explanation. The string content is encoded
        ///   using the default encoding for the machine, or on Silverlight, using
        ///   UTF-8. This encoding is distinct from the encoding used for the
        ///   filename itself.  See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="content">
        ///   The content of the file, should it be extracted from the zip.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000249 RID: 585 RVA: 0x0000FCB4 File Offset: 0x0000DEB4
        public ZipEntry UpdateEntry(string entryName, string content)
        {
            return this.UpdateEntry(entryName, content, Encoding.Default);
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given string as
        ///   content for the <c>ZipEntry</c>.
        /// </summary>
        ///
        /// <remarks>
        ///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
        ///   given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)" />.  See the
        ///   documentation for that method for further explanation.
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="content">
        ///   The content of the file, should it be extracted from the zip.
        /// </param>
        ///
        /// <param name="encoding">
        ///   The text encoding to use when encoding the string. Be aware: This is
        ///   distinct from the text encoding used to encode the filename. See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x0600024A RID: 586 RVA: 0x0000FCD4 File Offset: 0x0000DED4
        public ZipEntry UpdateEntry(string entryName, string content, Encoding encoding)
        {
            this.RemoveEntryForUpdate(entryName);
            return this.AddEntry(entryName, content, encoding);
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given delegate
        ///   as the source for content for the <c>ZipEntry</c>.
        /// </summary>
        ///
        /// <remarks>
        ///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
        ///   given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />.  See the
        ///   documentation for that method for further explanation.
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="writer">the delegate which will write the entry content.</param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x0600024B RID: 587 RVA: 0x0000FCF8 File Offset: 0x0000DEF8
        public ZipEntry UpdateEntry(string entryName, WriteDelegate writer)
        {
            this.RemoveEntryForUpdate(entryName);
            return this.AddEntry(entryName, writer);
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given delegates
        ///   to open and close the stream that provides the content for the <c>ZipEntry</c>.
        /// </summary>
        ///
        /// <remarks>
        ///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
        ///   given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.  See the
        ///   documentation for that method for further explanation.
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="opener">
        ///  the delegate that will be invoked to open the stream
        /// </param>
        /// <param name="closer">
        ///  the delegate that will be invoked to close the stream
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added or updated.</returns>
        // Token: 0x0600024C RID: 588 RVA: 0x0000FD1C File Offset: 0x0000DF1C
        public ZipEntry UpdateEntry(string entryName, OpenDelegate opener, CloseDelegate closer)
        {
            this.RemoveEntryForUpdate(entryName);
            return this.AddEntry(entryName, opener, closer);
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given stream as
        ///   input, and the given filename and given directory Path.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
        ///   entry by the same name already exists, and then calling <c>AddEntry()</c>
        ///   with the given <c>fileName</c> and stream.
        /// </para>
        ///
        /// <para>
        ///   The stream must be open and readable during the call to
        ///   <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
        ///   using the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property. Check the
        ///   documentation of that property for more information.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to the
        ///   <c>ZipEntry</c> added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />
        /// <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="stream">The input stream from which to read file data.</param>
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x0600024D RID: 589 RVA: 0x0000FD40 File Offset: 0x0000DF40
        public ZipEntry UpdateEntry(string entryName, Stream stream)
        {
            this.RemoveEntryForUpdate(entryName);
            return this.AddEntry(entryName, stream);
        }

        // Token: 0x0600024E RID: 590 RVA: 0x0000FD64 File Offset: 0x0000DF64
        private void RemoveEntryForUpdate(string entryName)
        {
            if (string.IsNullOrEmpty(entryName))
            {
                throw new ArgumentNullException("entryName");
            }
            string directoryPathInArchive = null;
            if (entryName.IndexOf('\\') != -1)
            {
                directoryPathInArchive = Path.GetDirectoryName(entryName);
                entryName = Path.GetFileName(entryName);
            }
            string key = ZipEntry.NameInArchive(entryName, directoryPathInArchive);
            if (this[key] != null)
            {
                this.RemoveEntry(key);
            }
        }

        /// <summary>
        ///   Add an entry into the zip archive using the given filename and
        ///   directory path within the archive, and the given content for the
        ///   file. No file is created in the filesystem.
        /// </summary>
        ///
        /// <param name="byteContent">The data to use for the entry.</param>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x0600024F RID: 591 RVA: 0x0000FDCC File Offset: 0x0000DFCC
        public ZipEntry AddEntry(string entryName, byte[] byteContent)
        {
            if (byteContent == null)
            {
                throw new ArgumentException("bad argument", "byteContent");
            }
            MemoryStream ms = new MemoryStream(byteContent);
            return this.AddEntry(entryName, ms);
        }

        /// <summary>
        ///   Updates the given entry in the <c>ZipFile</c>, using the given byte
        ///   array as content for the entry.
        /// </summary>
        ///
        /// <remarks>
        ///   Calling this method is equivalent to removing the <c>ZipEntry</c>
        ///   for the given filename and directory path, if it exists, and then
        ///   calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])" />.  See the
        ///   documentation for that method for further explanation.
        /// </remarks>
        ///
        /// <param name="entryName">
        ///   The name, including any path, to use within the archive for the entry.
        /// </param>
        ///
        /// <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000250 RID: 592 RVA: 0x0000FE08 File Offset: 0x0000E008
        public ZipEntry UpdateEntry(string entryName, byte[] byteContent)
        {
            this.RemoveEntryForUpdate(entryName);
            return this.AddEntry(entryName, byteContent);
        }

        /// <summary>
        ///   Adds the contents of a filesystem directory to a Zip file archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   The name of the directory may be a relative path or a fully-qualified
        ///   path. Any files within the named directory are added to the archive.  Any
        ///   subdirectories within the named directory are also added to the archive,
        ///   recursively.
        /// </para>
        ///
        /// <para>
        ///   Top-level entries in the named directory will appear as top-level entries
        ///   in the zip archive.  Entries in subdirectories in the named directory will
        ///   result in entries in subdirectories in the zip archive.
        /// </para>
        ///
        /// <para>
        ///   If you want the entries to appear in a containing directory in the zip
        ///   archive itself, then you should call the AddDirectory() overload that
        ///   allows you to explicitly specify a directory path for use in the archive.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
        ///
        /// <overloads>This method has 2 overloads.</overloads>
        ///
        /// <param name="directoryName">The name of the directory to add.</param>
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000251 RID: 593 RVA: 0x0000FE2C File Offset: 0x0000E02C
        public ZipEntry AddDirectory(string directoryName)
        {
            return this.AddDirectory(directoryName, null);
        }

        /// <summary>
        ///   Adds the contents of a filesystem directory to a Zip file archive,
        ///   overriding the path to be used for entries in the archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The name of the directory may be a relative path or a fully-qualified
        ///   path. The add operation is recursive, so that any files or subdirectories
        ///   within the name directory are also added to the archive.
        /// </para>
        ///
        /// <para>
        ///   Top-level entries in the named directory will appear as top-level entries
        ///   in the zip archive.  Entries in subdirectories in the named directory will
        ///   result in entries in subdirectories in the zip archive.
        /// </para>
        ///
        /// <para>
        ///   For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
        ///   <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
        ///   respective values at the time of this call will be applied to each
        ///   ZipEntry added.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   In this code, calling the ZipUp() method with a value of "c:\reports" for
        ///   the directory parameter will result in a zip file structure in which all
        ///   entries are contained in a toplevel "reports" directory.
        /// </para>
        ///
        /// <code lang="C#">
        /// public void ZipUp(string targetZip, string directory)
        /// {
        ///   using (var zip = new ZipFile())
        ///   {
        ///     zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
        ///     zip.Save(targetZip);
        ///   }
        /// }
        /// </code>
        /// </example>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
        ///
        /// <param name="directoryName">The name of the directory to add.</param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to override any path in the
        ///   DirectoryName.  This path may, or may not, correspond to a real directory
        ///   in the current filesystem.  If the zip is later extracted, this is the
        ///   path used for the extracted file or directory.  Passing <c>null</c>
        ///   (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
        ///   the root path within the archive.
        /// </param>
        ///
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000252 RID: 594 RVA: 0x0000FE48 File Offset: 0x0000E048
        public ZipEntry AddDirectory(string directoryName, string directoryPathInArchive)
        {
            return this.AddOrUpdateDirectoryImpl(directoryName, directoryPathInArchive, AddOrUpdateAction.AddOnly);
        }

        /// <summary>
        ///   Creates a directory in the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   Use this when you want to create a directory in the archive but there is
        ///   no corresponding filesystem representation for that directory.
        /// </para>
        ///
        /// <para>
        ///   You will probably not need to do this in your code. One of the only times
        ///   you will want to do this is if you want an empty directory in the zip
        ///   archive.  The reason: if you add a file to a zip archive that is stored
        ///   within a multi-level directory, all of the directory tree is implicitly
        ///   created in the zip archive.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="directoryNameInArchive">
        ///   The name of the directory to create in the archive.
        /// </param>
        /// <returns>The <c>ZipEntry</c> added.</returns>
        // Token: 0x06000253 RID: 595 RVA: 0x0000FE64 File Offset: 0x0000E064
        public ZipEntry AddDirectoryByName(string directoryNameInArchive)
        {
            ZipEntry dir = ZipEntry.CreateFromNothing(directoryNameInArchive);
            dir._container = new ZipContainer(this);
            dir.MarkAsDirectory();
            dir.AlternateEncoding = this.AlternateEncoding;
            dir.AlternateEncodingUsage = this.AlternateEncodingUsage;
            dir.SetEntryTimes(DateTime.Now, DateTime.Now, DateTime.Now);
            dir.EmitTimesInWindowsFormatWhenSaving = this._emitNtfsTimes;
            dir.EmitTimesInUnixFormatWhenSaving = this._emitUnixTimes;
            dir._Source = ZipEntrySource.Stream;
            this.InternalAddEntry(dir.FileName, dir);
            this.AfterAddEntry(dir);
            return dir;
        }

        // Token: 0x06000254 RID: 596 RVA: 0x0000FEF8 File Offset: 0x0000E0F8
        private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action)
        {
            if (rootDirectoryPathInArchive == null)
            {
                rootDirectoryPathInArchive = "";
            }
            return this.AddOrUpdateDirectoryImpl(directoryName, rootDirectoryPathInArchive, action, true, 0);
        }

        // Token: 0x06000255 RID: 597 RVA: 0x0000FF29 File Offset: 0x0000E129
        internal void InternalAddEntry(string name, ZipEntry entry)
        {
            this._entries.Add(name, entry);
            this._zipEntriesAsList = null;
            this._contentsChanged = true;
        }

        // Token: 0x06000256 RID: 598 RVA: 0x0000FF48 File Offset: 0x0000E148
        private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action, bool recurse, int level)
        {
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("{0} {1}...", (action == AddOrUpdateAction.AddOnly) ? "adding" : "Adding or updating", directoryName);
            }
            if (level == 0)
            {
                this._addOperationCanceled = false;
                this.OnAddStarted();
            }
            ZipEntry result;
            if (this._addOperationCanceled)
            {
                result = null;
            }
            else
            {
                string dirForEntries = rootDirectoryPathInArchive;
                ZipEntry baseDir = null;
                if (level > 0)
                {
                    int f = directoryName.Length;
                    for (int i = level; i > 0; i--)
                    {
                        f = directoryName.LastIndexOfAny("/\\".ToCharArray(), f - 1, f - 1);
                    }
                    dirForEntries = directoryName.Substring(f + 1);
                    dirForEntries = Path.Combine(rootDirectoryPathInArchive, dirForEntries);
                }
                if (level > 0 || rootDirectoryPathInArchive != "")
                {
                    baseDir = ZipEntry.CreateFromFile(directoryName, dirForEntries);
                    baseDir._container = new ZipContainer(this);
                    baseDir.AlternateEncoding = this.AlternateEncoding;
                    baseDir.AlternateEncodingUsage = this.AlternateEncodingUsage;
                    baseDir.MarkAsDirectory();
                    baseDir.EmitTimesInWindowsFormatWhenSaving = this._emitNtfsTimes;
                    baseDir.EmitTimesInUnixFormatWhenSaving = this._emitUnixTimes;
                    if (!this._entries.ContainsKey(baseDir.FileName))
                    {
                        this.InternalAddEntry(baseDir.FileName, baseDir);
                        this.AfterAddEntry(baseDir);
                    }
                    dirForEntries = baseDir.FileName;
                }
                if (!this._addOperationCanceled)
                {
                    string[] filenames = Directory.GetFiles(directoryName);
                    if (recurse)
                    {
                        foreach (string filename in filenames)
                        {
                            if (this._addOperationCanceled)
                            {
                                break;
                            }
                            if (action == AddOrUpdateAction.AddOnly)
                            {
                                this.AddFile(filename, dirForEntries);
                            }
                            else
                            {
                                this.UpdateFile(filename, dirForEntries);
                            }
                        }
                        if (!this._addOperationCanceled)
                        {
                            string[] dirnames = Directory.GetDirectories(directoryName);
                            foreach (string dir in dirnames)
                            {
                                FileAttributes fileAttrs = File.GetAttributes(dir);
                                if (this.AddDirectoryWillTraverseReparsePoints || (fileAttrs & FileAttributes.ReparsePoint) == (FileAttributes)0)
                                {
                                    this.AddOrUpdateDirectoryImpl(dir, rootDirectoryPathInArchive, action, recurse, level + 1);
                                }
                            }
                        }
                    }
                }
                if (level == 0)
                {
                    this.OnAddCompleted();
                }
                result = baseDir;
            }
            return result;
        }

        /// <summary>
        ///   Checks a zip file to see if its directory is consistent.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   In cases of data error, the directory within a zip file can get out
        ///   of synch with the entries in the zip file.  This method checks the
        ///   given zip file and returns true if this has occurred.
        /// </para>
        ///
        /// <para> This method may take a long time to run for large zip files.  </para>
        ///
        /// <para>
        ///   This method is not supported in the Reduced or Compact Framework
        ///   versions of DotNetZip.
        /// </para>
        ///
        /// <para>
        ///   Developers using COM can use the <see cref="M:Ionic.Zip.ComHelper.CheckZip(System.String)">ComHelper.CheckZip(String)</see>
        ///   method.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="zipFileName">The filename to of the zip file to check.</param>
        ///
        /// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)" />
        // Token: 0x06000257 RID: 599 RVA: 0x000101D0 File Offset: 0x0000E3D0
        public static bool CheckZip(string zipFileName)
        {
            return ZipFile.CheckZip(zipFileName, false, null);
        }

        /// <summary>
        ///   Checks a zip file to see if its directory is consistent,
        ///   and optionally fixes the directory if necessary.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   In cases of data error, the directory within a zip file can get out of
        ///   synch with the entries in the zip file.  This method checks the given
        ///   zip file, and returns true if this has occurred. It also optionally
        ///   fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.
        /// </para>
        ///
        /// <para>
        ///   This method may take a long time to run for large zip files.  It
        ///   will take even longer if the file actually needs to be fixed, and if
        ///   <c>fixIfNecessary</c> is true.
        /// </para>
        ///
        /// <para>
        ///   This method is not supported in the Reduced or Compact
        ///   Framework versions of DotNetZip.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="zipFileName">The filename to of the zip file to check.</param>
        ///
        /// <param name="fixIfNecessary">If true, the method will fix the zip file if
        ///     necessary.</param>
        ///
        /// <param name="writer">
        /// a TextWriter in which messages generated while checking will be written.
        /// </param>
        ///
        /// <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
        // Token: 0x06000258 RID: 600 RVA: 0x000101EC File Offset: 0x0000E3EC
        public static bool CheckZip(string zipFileName, bool fixIfNecessary, TextWriter writer)
        {
            ZipFile zip = null;
            ZipFile zip2 = null;
            bool isOk = true;
            try
            {
                zip = new ZipFile();
                zip.FullScan = true;
                zip.Initialize(zipFileName);
                zip2 = ZipFile.Read(zipFileName);
                foreach (ZipEntry e in zip)
                {
                    foreach (ZipEntry e2 in zip2)
                    {
                        if (e.FileName == e2.FileName)
                        {
                            if (e._RelativeOffsetOfLocalHeader != e2._RelativeOffsetOfLocalHeader)
                            {
                                isOk = false;
                                if (writer != null)
                                {
                                    writer.WriteLine("{0}: mismatch in RelativeOffsetOfLocalHeader  (0x{1:X16} != 0x{2:X16})", e.FileName, e._RelativeOffsetOfLocalHeader, e2._RelativeOffsetOfLocalHeader);
                                }
                            }
                            if (e._CompressedSize != e2._CompressedSize)
                            {
                                isOk = false;
                                if (writer != null)
                                {
                                    writer.WriteLine("{0}: mismatch in CompressedSize  (0x{1:X16} != 0x{2:X16})", e.FileName, e._CompressedSize, e2._CompressedSize);
                                }
                            }
                            if (e._UncompressedSize != e2._UncompressedSize)
                            {
                                isOk = false;
                                if (writer != null)
                                {
                                    writer.WriteLine("{0}: mismatch in UncompressedSize  (0x{1:X16} != 0x{2:X16})", e.FileName, e._UncompressedSize, e2._UncompressedSize);
                                }
                            }
                            if (e.CompressionMethod != e2.CompressionMethod)
                            {
                                isOk = false;
                                if (writer != null)
                                {
                                    writer.WriteLine("{0}: mismatch in CompressionMethod  (0x{1:X4} != 0x{2:X4})", e.FileName, e.CompressionMethod, e2.CompressionMethod);
                                }
                            }
                            if (e.Crc != e2.Crc)
                            {
                                isOk = false;
                                if (writer != null)
                                {
                                    writer.WriteLine("{0}: mismatch in Crc32  (0x{1:X4} != 0x{2:X4})", e.FileName, e.Crc, e2.Crc);
                                }
                            }
                            break;
                        }
                    }
                }
                zip2.Dispose();
                zip2 = null;
                if (!isOk && fixIfNecessary)
                {
                    string newFileName = Path.GetFileNameWithoutExtension(zipFileName);
                    newFileName = string.Format("{0}_fixed.zip", newFileName);
                    zip.Save(newFileName);
                }
            }
            finally
            {
                if (zip != null)
                {
                    zip.Dispose();
                }
                if (zip2 != null)
                {
                    zip2.Dispose();
                }
            }
            return isOk;
        }

        /// <summary>
        ///   Rewrite the directory within a zipfile.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   In cases of data error, the directory in a zip file can get out of
        ///   synch with the entries in the zip file.  This method attempts to fix
        ///   the zip file if this has occurred.
        /// </para>
        ///
        /// <para> This can take a long time for large zip files. </para>
        ///
        /// <para> This won't work if the zip file uses a non-standard
        /// code page - neither IBM437 nor UTF-8. </para>
        ///
        /// <para>
        ///   This method is not supported in the Reduced or Compact Framework
        ///   versions of DotNetZip.
        /// </para>
        ///
        /// <para>
        ///   Developers using COM can use the <see cref="M:Ionic.Zip.ComHelper.FixZipDirectory(System.String)">ComHelper.FixZipDirectory(String)</see>
        ///   method.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="zipFileName">The filename to of the zip file to fix.</param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
        /// <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)" />
        // Token: 0x06000259 RID: 601 RVA: 0x000104F0 File Offset: 0x0000E6F0
        public static void FixZipDirectory(string zipFileName)
        {
            using (ZipFile zip = new ZipFile())
            {
                zip.FullScan = true;
                zip.Initialize(zipFileName);
                zip.Save(zipFileName);
            }
        }

        /// <summary>
        ///   Verify the password on a zip file.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     Keep in mind that passwords in zipfiles are applied to
        ///     zip entries, not to the entire zip file. So testing a
        ///     zipfile for a particular password doesn't work in the
        ///     general case. On the other hand, it's often the case
        ///     that a single password will be used on all entries in a
        ///     zip file. This method works for that case.
        ///   </para>
        ///   <para>
        ///     There is no way to check a password without doing the
        ///     decryption. So this code decrypts and extracts the given
        ///     zipfile into <see cref="F:System.IO.Stream.Null" />
        ///   </para>
        /// </remarks>
        ///
        /// <param name="zipFileName">The filename to of the zip file to fix.</param>
        ///
        /// <param name="password">The password to check.</param>
        ///
        /// <returns>a bool indicating whether the password matches.</returns>
        // Token: 0x0600025A RID: 602 RVA: 0x00010544 File Offset: 0x0000E744
        public static bool CheckZipPassword(string zipFileName, string password)
        {
            bool success = false;
            try
            {
                using (ZipFile zip = ZipFile.Read(zipFileName))
                {
                    foreach (ZipEntry e in zip)
                    {
                        if (!e.IsDirectory && e.UsesEncryption)
                        {
                            e.ExtractWithPassword(Stream.Null, password);
                        }
                    }
                }
                success = true;
            }
            catch (BadPasswordException)
            {
            }
            return success;
        }

        /// <summary>
        ///   Provides a human-readable string with information about the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     The information string contains 10 lines or so, about each ZipEntry,
        ///     describing whether encryption is in use, the compressed and uncompressed
        ///     length of the entry, the offset of the entry, and so on. As a result the
        ///     information string can be very long for zip files that contain many
        ///     entries.
        ///   </para>
        ///   <para>
        ///     This information is mostly useful for diagnostic purposes.
        ///   </para>
        /// </remarks>
        // Token: 0x1700009E RID: 158
        // (get) Token: 0x0600025B RID: 603 RVA: 0x00010610 File Offset: 0x0000E810
        public string Info
        {
            get
            {
                StringBuilder builder = new StringBuilder();
                builder.Append(string.Format("          ZipFile: {0}\n", this.Name));
                if (!string.IsNullOrEmpty(this._Comment))
                {
                    builder.Append(string.Format("          Comment: {0}\n", this._Comment));
                }
                if (this._versionMadeBy != 0)
                {
                    builder.Append(string.Format("  version made by: 0x{0:X4}\n", this._versionMadeBy));
                }
                if (this._versionNeededToExtract != 0)
                {
                    builder.Append(string.Format("needed to extract: 0x{0:X4}\n", this._versionNeededToExtract));
                }
                builder.Append(string.Format("       uses ZIP64: {0}\n", this.InputUsesZip64));
                builder.Append(string.Format("     disk with CD: {0}\n", this._diskNumberWithCd));
                if (this._OffsetOfCentralDirectory == 4294967295u)
                {
                    builder.Append(string.Format("      CD64 offset: 0x{0:X16}\n", this._OffsetOfCentralDirectory64));
                }
                else
                {
                    builder.Append(string.Format("        CD offset: 0x{0:X8}\n", this._OffsetOfCentralDirectory));
                }
                builder.Append("\n");
                foreach (ZipEntry entry in this._entries.Values)
                {
                    builder.Append(entry.Info);
                }
                return builder.ToString();
            }
        }

        /// <summary>
        /// Indicates whether to perform a full scan of the zip file when reading it.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   You almost never want to use this property.
        /// </para>
        ///
        /// <para>
        ///   When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
        ///   VB), the entire zip archive will be scanned and searched for entries.
        ///   For large archives, this can take a very, long time. The much more
        ///   efficient default behavior is to read the zip directory, which is
        ///   stored at the end of the zip file. But, in some cases the directory is
        ///   corrupted and you need to perform a full scan of the zip file to
        ///   determine the contents of the zip file. This property lets you do
        ///   that, when necessary.
        /// </para>
        ///
        /// <para>
        ///   This flag is effective only when calling <see cref="M:Ionic.Zip.ZipFile.Initialize(System.String)" />. Normally you would read a ZipFile with the
        ///   static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
        ///   method. But you can't set the <c>FullScan</c> property on the
        ///   <c>ZipFile</c> instance when you use a static factory method like
        ///   <c>ZipFile.Read</c>.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example shows how to read a zip file using the full scan approach,
        ///   and then save it, thereby producing a corrected zip file.
        ///
        /// <code lang="C#">
        /// using (var zip = new ZipFile())
        /// {
        ///     zip.FullScan = true;
        ///     zip.Initialize(zipFileName);
        ///     zip.Save(newName);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     zip.FullScan = True
        ///     zip.Initialize(zipFileName)
        ///     zip.Save(newName)
        /// End Using
        /// </code>
        /// </example>
        // Token: 0x1700009F RID: 159
        // (get) Token: 0x0600025C RID: 604 RVA: 0x000107AC File Offset: 0x0000E9AC
        // (set) Token: 0x0600025D RID: 605 RVA: 0x000107C3 File Offset: 0x0000E9C3
        public bool FullScan { get; set; }

        /// <summary>
        ///   Whether to sort the ZipEntries before saving the file.
        /// </summary>
        ///
        /// <remarks>
        ///   The default is false.  If you have a large number of zip entries, the sort
        ///   alone can consume significant time.
        /// </remarks>
        ///
        /// <example>
        /// <code lang="C#">
        /// using (var zip = new ZipFile())
        /// {
        ///     zip.AddFiles(filesToAdd);
        ///     zip.SortEntriesBeforeSaving = true;
        ///     zip.Save(name);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     zip.AddFiles(filesToAdd)
        ///     zip.SortEntriesBeforeSaving = True
        ///     zip.Save(name)
        /// End Using
        /// </code>
        /// </example>
        // Token: 0x170000A0 RID: 160
        // (get) Token: 0x0600025E RID: 606 RVA: 0x000107CC File Offset: 0x0000E9CC
        // (set) Token: 0x0600025F RID: 607 RVA: 0x000107E3 File Offset: 0x0000E9E3
        public bool SortEntriesBeforeSaving { get; set; }

        /// <summary>
        ///   Indicates whether NTFS Reparse Points, like junctions, should be
        ///   traversed during calls to <c>AddDirectory()</c>.
        /// </summary>
        ///
        /// <remarks>
        ///   By default, calls to AddDirectory() will traverse NTFS reparse
        ///   points, like mounted volumes, and directory junctions.  An example
        ///   of a junction is the "My Music" directory in Windows Vista.  In some
        ///   cases you may not want DotNetZip to traverse those directories.  In
        ///   that case, set this property to false.
        /// </remarks>
        ///
        /// <example>
        /// <code lang="C#">
        /// using (var zip = new ZipFile())
        /// {
        ///     zip.AddDirectoryWillTraverseReparsePoints = false;
        ///     zip.AddDirectory(dirToZip,"fodder");
        ///     zip.Save(zipFileToCreate);
        /// }
        /// </code>
        /// </example>
        // Token: 0x170000A1 RID: 161
        // (get) Token: 0x06000260 RID: 608 RVA: 0x000107EC File Offset: 0x0000E9EC
        // (set) Token: 0x06000261 RID: 609 RVA: 0x00010803 File Offset: 0x0000EA03
        public bool AddDirectoryWillTraverseReparsePoints { get; set; }

        /// <summary>
        ///   Size of the IO buffer used while saving.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   First, let me say that you really don't need to bother with this.  It is
        ///   here to allow for optimizations that you probably won't make! It will work
        ///   fine if you don't set or get this property at all. Ok?
        /// </para>
        ///
        /// <para>
        ///   Now that we have <em>that</em> out of the way, the fine print: This
        ///   property affects the size of the buffer that is used for I/O for each
        ///   entry contained in the zip file. When a file is read in to be compressed,
        ///   it uses a buffer given by the size here.  When you update a zip file, the
        ///   data for unmodified entries is copied from the first zip file to the
        ///   other, through a buffer given by the size here.
        /// </para>
        ///
        /// <para>
        ///   Changing the buffer size affects a few things: first, for larger buffer
        ///   sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
        ///   during I/O operations.  This may make operations faster for very much
        ///   larger files.  Last, for any given entry, when you use a larger buffer
        ///   there will be fewer progress events during I/O operations, because there's
        ///   one progress event generated for each time the buffer is filled and then
        ///   emptied.
        /// </para>
        ///
        /// <para>
        ///   The default buffer size is 8k.  Increasing the buffer size may speed
        ///   things up as you compress larger files.  But there are no hard-and-fast
        ///   rules here, eh?  You won't know til you test it.  And there will be a
        ///   limit where ever larger buffers actually slow things down.  So as I said
        ///   in the beginning, it's probably best if you don't set or get this property
        ///   at all.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// This example shows how you might set a large buffer size for efficiency when
        /// dealing with zip entries that are larger than 1gb.
        /// <code lang="C#">
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.SaveProgress += this.zip1_SaveProgress;
        ///     zip.AddDirectory(directoryToZip, "");
        ///     zip.UseZip64WhenSaving = Zip64Option.Always;
        ///     zip.BufferSize = 65536*8; // 65536 * 8 = 512k
        ///     zip.Save(ZipFileToCreate);
        /// }
        /// </code>
        /// </example>
        // Token: 0x170000A2 RID: 162
        // (get) Token: 0x06000262 RID: 610 RVA: 0x0001080C File Offset: 0x0000EA0C
        // (set) Token: 0x06000263 RID: 611 RVA: 0x00010824 File Offset: 0x0000EA24
        public int BufferSize
        {
            get
            {
                return this._BufferSize;
            }
            set
            {
                this._BufferSize = value;
            }
        }

        /// <summary>
        ///   Size of the work buffer to use for the ZLIB codec during compression.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     When doing ZLIB or Deflate compression, the library fills a buffer,
        ///     then passes it to the compressor for compression. Then the library
        ///     reads out the compressed bytes. This happens repeatedly until there
        ///     is no more uncompressed data to compress. This property sets the
        ///     size of the buffer that will be used for chunk-wise compression. In
        ///     order for the setting to take effect, your application needs to set
        ///     this property before calling one of the <c>ZipFile.Save()</c>
        ///     overloads.
        ///   </para>
        ///   <para>
        ///     Setting this affects the performance and memory efficiency of
        ///     compression and decompression. For larger files, setting this to a
        ///     larger size may improve compression performance, but the exact
        ///     numbers vary depending on available memory, the size of the streams
        ///     you are compressing, and a bunch of other variables. I don't have
        ///     good firm recommendations on how to set it.  You'll have to test it
        ///     yourself. Or just leave it alone and accept the default.
        ///   </para>
        /// </remarks>
        // Token: 0x170000A3 RID: 163
        // (get) Token: 0x06000264 RID: 612 RVA: 0x00010830 File Offset: 0x0000EA30
        // (set) Token: 0x06000265 RID: 613 RVA: 0x00010847 File Offset: 0x0000EA47
        public int CodecBufferSize { get; set; }

        /// <summary>
        ///   Indicates whether extracted files should keep their paths as
        ///   stored in the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    This property affects Extraction.  It is not used when creating zip
        ///    archives.
        ///  </para>
        ///
        ///  <para>
        ///    With this property set to <c>false</c>, the default, extracting entries
        ///    from a zip file will create files in the filesystem that have the full
        ///    path associated to the entry within the zip file.  With this property set
        ///    to <c>true</c>, extracting entries from the zip file results in files
        ///    with no path: the folders are "flattened."
        ///  </para>
        ///
        ///  <para>
        ///    An example: suppose the zip file contains entries /directory1/file1.txt and
        ///    /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
        ///    the files created will be \directory1\file1.txt and \directory2\file2.txt.
        ///    With the property set to true, the files created are file1.txt and file2.txt.
        ///  </para>
        ///
        /// </remarks>
        // Token: 0x170000A4 RID: 164
        // (get) Token: 0x06000266 RID: 614 RVA: 0x00010850 File Offset: 0x0000EA50
        // (set) Token: 0x06000267 RID: 615 RVA: 0x00010867 File Offset: 0x0000EA67
        public bool FlattenFoldersOnExtract { get; set; }

        /// <summary>
        ///   The compression strategy to use for all entries.
        /// </summary>
        ///
        /// <remarks>
        ///   Set the Strategy used by the ZLIB-compatible compressor, when
        ///   compressing entries using the DEFLATE method. Different compression
        ///   strategies work better on different sorts of data. The strategy
        ///   parameter can affect the compression ratio and the speed of
        ///   compression but not the correctness of the compresssion.  For more
        ///   information see <see cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
        /// </remarks>
        // Token: 0x170000A5 RID: 165
        // (get) Token: 0x06000268 RID: 616 RVA: 0x00010870 File Offset: 0x0000EA70
        // (set) Token: 0x06000269 RID: 617 RVA: 0x00010888 File Offset: 0x0000EA88
        public CompressionStrategy Strategy
        {
            get
            {
                return this._Strategy;
            }
            set
            {
                this._Strategy = value;
            }
        }

        /// <summary>
        ///   The name of the <c>ZipFile</c>, on disk.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When the <c>ZipFile</c> instance was created by reading an archive using
        ///   one of the <c>ZipFile.Read</c> methods, this property represents the name
        ///   of the zip file that was read.  When the <c>ZipFile</c> instance was
        ///   created by using the no-argument constructor, this value is <c>null</c>
        ///   (<c>Nothing</c> in VB).
        /// </para>
        ///
        /// <para>
        ///   If you use the no-argument constructor, and you then explicitly set this
        ///   property, when you call <see cref="M:Ionic.Zip.ZipFile.Save" />, this name will
        ///   specify the name of the zip file created.  Doing so is equivalent to
        ///   calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" />.  When instantiating a
        ///   <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
        ///   property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
        ///   property is implicitly set to <c>null</c>.
        /// </para>
        /// </remarks>
        // Token: 0x170000A6 RID: 166
        // (get) Token: 0x0600026A RID: 618 RVA: 0x00010894 File Offset: 0x0000EA94
        // (set) Token: 0x0600026B RID: 619 RVA: 0x000108AC File Offset: 0x0000EAAC
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                this._name = value;
            }
        }

        /// <summary>
        ///   Sets the compression level to be used for entries subsequently added to
        ///   the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    Varying the compression level used on entries can affect the
        ///    size-vs-speed tradeoff when compression and decompressing data streams
        ///    or files.
        ///  </para>
        ///
        ///  <para>
        ///    As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.Encryption" />, and <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, setting this property on a <c>ZipFile</c>
        ///    instance will cause the specified <c>CompressionLevel</c> to be used on all
        ///    <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
        ///    <c>ZipFile</c> instance. If you set this property after you have added
        ///    items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
        ///    those items will not use the specified compression level.
        ///  </para>
        ///
        ///  <para>
        ///    If you do not set this property, the default compression level is used,
        ///    which normally gives a good balance of compression efficiency and
        ///    compression speed.  In some tests, using <c>BestCompression</c> can
        ///    double the time it takes to compress, while delivering just a small
        ///    increase in compression efficiency.  This behavior will vary with the
        ///    type of data you compress.  If you are in doubt, just leave this setting
        ///    alone, and accept the default.
        ///  </para>
        /// </remarks>
        // Token: 0x170000A7 RID: 167
        // (get) Token: 0x0600026C RID: 620 RVA: 0x000108B8 File Offset: 0x0000EAB8
        // (set) Token: 0x0600026D RID: 621 RVA: 0x000108CF File Offset: 0x0000EACF
        public CompressionLevel CompressionLevel { get; set; }

        /// <summary>
        ///   The compression method for the zipfile.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     By default, the compression method is <c>CompressionMethod.Deflate.</c>
        ///   </para>
        /// </remarks>
        /// <seealso cref="T:Ionic.Zip.CompressionMethod" />
        // Token: 0x170000A8 RID: 168
        // (get) Token: 0x0600026E RID: 622 RVA: 0x000108D8 File Offset: 0x0000EAD8
        // (set) Token: 0x0600026F RID: 623 RVA: 0x000108F0 File Offset: 0x0000EAF0
        public CompressionMethod CompressionMethod
        {
            get
            {
                return this._compressionMethod;
            }
            set
            {
                this._compressionMethod = value;
            }
        }

        /// <summary>
        ///   A comment attached to the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This property is read/write. It allows the application to specify a
        ///   comment for the <c>ZipFile</c>, or read the comment for the
        ///   <c>ZipFile</c>.  After setting this property, changes are only made
        ///   permanent when you call a <c>Save()</c> method.
        /// </para>
        ///
        /// <para>
        ///   According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see>, the comment is not encrypted, even if there is a
        ///   password set on the zip file.
        /// </para>
        ///
        /// <para>
        ///   The specification does not describe how to indicate the encoding used
        ///   on a comment string. Many "compliant" zip tools and libraries use
        ///   IBM437 as the code page for comments; DotNetZip, too, follows that
        ///   practice.  On the other hand, there are situations where you want a
        ///   Comment to be encoded with something else, for example using code page
        ///   950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
        ///   comment following the same procedure it follows for encoding
        ///   filenames: (a) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is
        ///   <c>Never</c>, it uses the default encoding (IBM437). (b) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is <c>Always</c>, it always uses the
        ///   alternate encoding (<see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />). (c) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is <c>AsNecessary</c>, it uses the
        ///   alternate encoding only if the default encoding is not sufficient for
        ///   encoding the comment - in other words if decoding the result does not
        ///   produce the original string.  This decision is taken at the time of
        ///   the call to <c>ZipFile.Save()</c>.
        /// </para>
        ///
        /// <para>
        ///   When creating a zip archive using this library, it is possible to change
        ///   the value of <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> between each
        ///   entry you add, and between adding entries and the call to
        ///   <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
        ///   not readable by any tool or application.  For best interoperability, leave
        ///   <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> alone, or specify it only
        ///   once, before adding any entries to the <c>ZipFile</c> instance.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x170000A9 RID: 169
        // (get) Token: 0x06000270 RID: 624 RVA: 0x000108FC File Offset: 0x0000EAFC
        // (set) Token: 0x06000271 RID: 625 RVA: 0x00010914 File Offset: 0x0000EB14
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this._Comment = value;
                this._contentsChanged = true;
            }
        }

        /// <summary>
        ///   Specifies whether the Creation, Access, and Modified times for entries
        ///   added to the zip file will be emitted in Windows format
        ///   when the zip archive is saved.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   An application creating a zip archive can use this flag to explicitly
        ///   specify that the file times for the entries should or should not be stored
        ///   in the zip archive in the format used by Windows. By default this flag is
        ///   <c>true</c>, meaning the Windows-format times are stored in the zip
        ///   archive.
        /// </para>
        ///
        /// <para>
        ///   When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are
        ///   automatically set from the filesystem values. When adding an entry from a
        ///   stream or string, all three values are implicitly set to
        ///   <c>DateTime.Now</c>.  Applications can also explicitly set those times by
        ///   calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
        /// </para>
        ///
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see> describes multiple ways to format these times in a
        ///   zip file. One is the format Windows applications normally use: 100ns ticks
        ///   since January 1, 1601 UTC.  The other is a format Unix applications typically
        ///   use: seconds since January 1, 1970 UTC.  Each format can be stored in an
        ///   "extra field" in the zip entry when saving the zip archive. The former
        ///   uses an extra field with a Header Id of 0x000A, while the latter uses a
        ///   header ID of 0x5455, although you probably don't need to know that.
        /// </para>
        ///
        /// <para>
        ///   Not all tools and libraries can interpret these fields.  Windows
        ///   compressed folders is one that can read the Windows Format timestamps,
        ///   while I believe <see href="http://www.info-zip.org/">the Infozip
        ///   tools</see> can read the Unix format timestamps. Some tools and libraries
        ///   may be able to read only one or the other. DotNetZip can read or write
        ///   times in either or both formats.
        /// </para>
        ///
        /// <para>
        ///   The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
        /// </para>
        ///
        /// <para>
        ///   The value set here applies to all entries subsequently added to the
        ///   <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" /> property. It is possible and
        ///   legal and valid to produce a zip file that contains timestamps encoded in
        ///   the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
        ///   entry in the archive, a time that is always stored in "DOS format". And,
        ///   notwithstanding the names PKWare uses for these time formats, any of them
        ///   can be read and written by any computer, on any operating system.  But,
        ///   there are no guarantees that a program running on Mac or Linux will
        ///   gracefully handle a zip file with "Windows" formatted times, or that an
        ///   application that does not use DotNetZip but runs on Windows will be able to
        ///   handle file times in Unix format.
        /// </para>
        ///
        /// <para>
        ///   When in doubt, test.  Sorry, I haven't got a complete list of tools and
        ///   which sort of timestamps they can use and will tolerate.  If you get any
        ///   good information and would like to pass it on, please do so and I will
        ///   include that information in this documentation.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///   This example shows how to save a zip file that contains file timestamps
        ///   in a format normally used by Unix.
        /// <code lang="C#">
        /// using (var zip = new ZipFile())
        /// {
        ///     // produce a zip file the Mac will like
        ///     zip.EmitTimesInWindowsFormatWhenSaving = false;
        ///     zip.EmitTimesInUnixFormatWhenSaving = true;
        ///     zip.AddDirectory(directoryToZip, "files");
        ///     zip.Save(outputFile);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     '' produce a zip file the Mac will like
        ///     zip.EmitTimesInWindowsFormatWhenSaving = False
        ///     zip.EmitTimesInUnixFormatWhenSaving = True
        ///     zip.AddDirectory(directoryToZip, "files")
        ///     zip.Save(outputFile)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
        // Token: 0x170000AA RID: 170
        // (get) Token: 0x06000272 RID: 626 RVA: 0x00010928 File Offset: 0x0000EB28
        // (set) Token: 0x06000273 RID: 627 RVA: 0x00010940 File Offset: 0x0000EB40
        public bool EmitTimesInWindowsFormatWhenSaving
        {
            get
            {
                return this._emitNtfsTimes;
            }
            set
            {
                this._emitNtfsTimes = value;
            }
        }

        /// <summary>
        /// Specifies whether the Creation, Access, and Modified times
        /// for entries added to the zip file will be emitted in "Unix(tm)
        /// format" when the zip archive is saved.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   An application creating a zip archive can use this flag to explicitly
        ///   specify that the file times for the entries should or should not be stored
        ///   in the zip archive in the format used by Unix. By default this flag is
        ///   <c>false</c>, meaning the Unix-format times are not stored in the zip
        ///   archive.
        /// </para>
        ///
        /// <para>
        ///   When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are
        ///   automatically set from the filesystem values. When adding an entry from a
        ///   stream or string, all three values are implicitly set to DateTime.Now.
        ///   Applications can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
        /// </para>
        ///
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see> describes multiple ways to format these times in a
        ///   zip file. One is the format Windows applications normally use: 100ns ticks
        ///   since January 1, 1601 UTC.  The other is a format Unix applications
        ///   typically use: seconds since January 1, 1970 UTC.  Each format can be
        ///   stored in an "extra field" in the zip entry when saving the zip
        ///   archive. The former uses an extra field with a Header Id of 0x000A, while
        ///   the latter uses a header ID of 0x5455, although you probably don't need to
        ///   know that.
        /// </para>
        ///
        /// <para>
        ///   Not all tools and libraries can interpret these fields.  Windows
        ///   compressed folders is one that can read the Windows Format timestamps,
        ///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
        ///   tools can read the Unix format timestamps. Some tools and libraries may be
        ///   able to read only one or the other.  DotNetZip can read or write times in
        ///   either or both formats.
        /// </para>
        ///
        /// <para>
        ///   The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
        /// </para>
        ///
        /// <para>
        ///   This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" /> property. It is possible and
        ///   legal and valid to produce a zip file that contains timestamps encoded in
        ///   the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
        ///   entry in the zip archive, a time that is always stored in "DOS
        ///   format". And, notwithstanding the names PKWare uses for these time
        ///   formats, any of them can be read and written by any computer, on any
        ///   operating system.  But, there are no guarantees that a program running on
        ///   Mac or Linux will gracefully handle a zip file with "Windows" formatted
        ///   times, or that an application that does not use DotNetZip but runs on
        ///   Windows will be able to handle file times in Unix format.
        /// </para>
        ///
        /// <para>
        ///   When in doubt, test.  Sorry, I haven't got a complete list of tools and
        ///   which sort of timestamps they can use and will tolerate.  If you get any
        ///   good information and would like to pass it on, please do so and I will
        ///   include that information in this documentation.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" />
        // Token: 0x170000AB RID: 171
        // (get) Token: 0x06000274 RID: 628 RVA: 0x0001094C File Offset: 0x0000EB4C
        // (set) Token: 0x06000275 RID: 629 RVA: 0x00010964 File Offset: 0x0000EB64
        public bool EmitTimesInUnixFormatWhenSaving
        {
            get
            {
                return this._emitUnixTimes;
            }
            set
            {
                this._emitUnixTimes = value;
            }
        }

        /// <summary>
        ///   Indicates whether verbose output is sent to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> during <c>AddXxx()</c> and
        ///   <c>ReadXxx()</c> operations.
        /// </summary>
        ///
        /// <remarks>
        ///   This is a <em>synthetic</em> property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> is non-null.
        /// </remarks>
        // Token: 0x170000AC RID: 172
        // (get) Token: 0x06000276 RID: 630 RVA: 0x00010970 File Offset: 0x0000EB70
        internal bool Verbose
        {
            get
            {
                return this._StatusMessageTextWriter != null;
            }
        }

        /// <summary>
        ///   Returns true if an entry by the given name exists in the ZipFile.
        /// </summary>
        ///
        /// <param name="name">the name of the entry to find</param>
        /// <returns>true if an entry with the given name exists; otherwise false.
        /// </returns>
        // Token: 0x06000277 RID: 631 RVA: 0x00010990 File Offset: 0x0000EB90
        public bool ContainsEntry(string name)
        {
            return this._entries.ContainsKey(SharedUtilities.NormalizePathForUseInZipFile(name));
        }

        /// <summary>
        ///   Indicates whether to perform case-sensitive matching on the filename when
        ///   retrieving entries in the zipfile via the string-based indexer.
        /// </summary>
        ///
        /// <remarks>
        ///   The default value is <c>false</c>, which means don't do case-sensitive
        ///   matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
        ///   zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
        ///   if you are not running on Windows, which has case-insensitive
        ///   filenames. But since this library is not built for non-Windows platforms,
        ///   in most cases you should just leave this property alone.
        /// </remarks>
        // Token: 0x170000AD RID: 173
        // (get) Token: 0x06000278 RID: 632 RVA: 0x000109B4 File Offset: 0x0000EBB4
        // (set) Token: 0x06000279 RID: 633 RVA: 0x000109CC File Offset: 0x0000EBCC
        public bool CaseSensitiveRetrieval
        {
            get
            {
                return this._CaseSensitiveRetrieval;
            }
            set
            {
                if (value != this._CaseSensitiveRetrieval)
                {
                    this._CaseSensitiveRetrieval = value;
                    this._initEntriesDictionary();
                }
            }
        }

        /// <summary>
        ///   Indicates whether to encode entry filenames and entry comments using Unicode
        ///   (UTF-8).
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
        ///   PKWare zip specification</see> provides for encoding file names and file
        ///   comments in either the IBM437 code page, or in UTF-8.  This flag selects
        ///   the encoding according to that specification.  By default, this flag is
        ///   false, and filenames and comments are encoded into the zip file in the
        ///   IBM437 codepage.  Setting this flag to true will specify that filenames
        ///   and comments that cannot be encoded with IBM437 will be encoded with
        ///   UTF-8.
        /// </para>
        ///
        /// <para>
        ///   Zip files created with strict adherence to the PKWare specification with
        ///   respect to UTF-8 encoding can contain entries with filenames containing
        ///   any combination of Unicode characters, including the full range of
        ///   characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
        ///   alphabets.  However, because at this time, the UTF-8 portion of the PKWare
        ///   specification is not broadly supported by other zip libraries and
        ///   utilities, such zip files may not be readable by your favorite zip tool or
        ///   archiver. In other words, interoperability will decrease if you set this
        ///   flag to true.
        /// </para>
        ///
        /// <para>
        ///   In particular, Zip files created with strict adherence to the PKWare
        ///   specification with respect to UTF-8 encoding will not work well with
        ///   Explorer in Windows XP or Windows Vista, because Windows compressed
        ///   folders, as far as I know, do not support UTF-8 in zip files.  Vista can
        ///   read the zip files, but shows the filenames incorrectly. Unpacking from
        ///   Windows Vista Explorer will result in filenames that have rubbish
        ///   characters in place of the high-order UTF-8 bytes.
        /// </para>
        ///
        /// <para>
        ///   Also, zip files that use UTF-8 encoding will not work well with Java
        ///   applications that use the java.util.zip classes, as of v5.0 of the Java
        ///   runtime. The Java runtime does not correctly implement the PKWare
        ///   specification in this regard.
        /// </para>
        ///
        /// <para>
        ///   As a result, we have the unfortunate situation that "correct" behavior by
        ///   the DotNetZip library with regard to Unicode encoding of filenames during
        ///   zip creation will result in zip files that are readable by strictly
        ///   compliant and current tools (for example the most recent release of the
        ///   commercial WinZip tool); but these zip files will not be readable by
        ///   various other tools or libraries, including Windows Explorer.
        /// </para>
        ///
        /// <para>
        ///   The DotNetZip library can read and write zip files with UTF8-encoded
        ///   entries, according to the PKware spec.  If you use DotNetZip for both
        ///   creating and reading the zip file, and you use UTF-8, there will be no
        ///   loss of information in the filenames. For example, using a self-extractor
        ///   created by this library will allow you to unpack files correctly with no
        ///   loss of information in the filenames.
        /// </para>
        ///
        /// <para>
        ///   If you do not set this flag, it will remain false.  If this flag is false,
        ///   your <c>ZipFile</c> will encode all filenames and comments using the
        ///   IBM437 codepage.  This can cause "loss of information" on some filenames,
        ///   but the resulting zipfile will be more interoperable with other
        ///   utilities. As an example of the loss of information, diacritics can be
        ///   lost.  The o-tilde character will be down-coded to plain o.  The c with a
        ///   cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
        ///   Likewise, the O-stroke character (Unicode 248), used in Danish and
        ///   Norwegian, will be down-coded to plain o. Chinese characters cannot be
        ///   represented in codepage IBM437; when using the default encoding, Chinese
        ///   characters in filenames will be represented as ?. These are all examples
        ///   of "information loss".
        /// </para>
        ///
        /// <para>
        ///   The loss of information associated to the use of the IBM437 encoding is
        ///   inconvenient, and can also lead to runtime errors. For example, using
        ///   IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
        ///   your application creates a <c>ZipFile</c>, then adds two files, each with
        ///   names of four Chinese characters each, this will result in a duplicate
        ///   filename exception.  In the case where you add a single file with a name
        ///   containing four Chinese characters, calling Extract() on the entry that
        ///   has question marks in the filename will result in an exception, because
        ///   the question mark is not legal for use within filenames on Windows.  These
        ///   are just a few examples of the problems associated to loss of information.
        /// </para>
        ///
        /// <para>
        ///   This flag is independent of the encoding of the content within the entries
        ///   in the zip file. Think of the zip file as a container - it supports an
        ///   encoding.  Within the container are other "containers" - the file entries
        ///   themselves.  The encoding within those entries is independent of the
        ///   encoding of the zip archive container for those entries.
        /// </para>
        ///
        /// <para>
        ///   Rather than specify the encoding in a binary fashion using this flag, an
        ///   application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property.  Setting the encoding
        ///   explicitly when creating zip archives will result in non-compliant zip
        ///   files that, curiously, are fairly interoperable.  The challenge is, the
        ///   PKWare specification does not provide for a way to specify that an entry
        ///   in a zip archive uses a code page that is neither IBM437 nor UTF-8.
        ///   Therefore if you set the encoding explicitly when creating a zip archive,
        ///   you must take care upon reading the zip archive to use the same code page.
        ///   If you get it wrong, the behavior is undefined and may result in incorrect
        ///   filenames, exceptions, stomach upset, hair loss, and acne.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        // Token: 0x170000AE RID: 174
        // (get) Token: 0x0600027A RID: 634 RVA: 0x000109F8 File Offset: 0x0000EBF8
        // (set) Token: 0x0600027B RID: 635 RVA: 0x00010A28 File Offset: 0x0000EC28
        [Obsolete("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
        public bool UseUnicodeAsNecessary
        {
            get
            {
                return this._alternateEncoding == Encoding.GetEncoding("UTF-8") && this._alternateEncodingUsage == ZipOption.AsNecessary;
            }
            set
            {
                if (value)
                {
                    this._alternateEncoding = Encoding.GetEncoding("UTF-8");
                    this._alternateEncodingUsage = ZipOption.AsNecessary;
                }
                else
                {
                    this._alternateEncoding = ZipFile.DefaultEncoding;
                    this._alternateEncodingUsage = ZipOption.Default;
                }
            }
        }

        /// <summary>
        ///   Specify whether to use ZIP64 extensions when saving a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When creating a zip file, the default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never" />. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is
        ///   safest, in the sense that you will not get an Exception if a pre-ZIP64
        ///   limit is exceeded.
        /// </para>
        ///
        /// <para>
        ///   You may set the property at any time before calling Save().
        /// </para>
        ///
        /// <para>
        ///   When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
        ///   will properly read ZIP64-endowed zip archives, regardless of the value of
        ///   this property.  DotNetZip will always read ZIP64 archives.  This property
        ///   governs only whether DotNetZip will write them. Therefore, when updating
        ///   archives, be careful about setting this property after reading an archive
        ///   that may use ZIP64 extensions.
        /// </para>
        ///
        /// <para>
        ///   An interesting question is, if you have set this property to
        ///   <c>AsNecessary</c>, and then successfully saved, does the resulting
        ///   archive use ZIP64 extensions or not?  To learn this, check the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property, after calling <c>Save()</c>.
        /// </para>
        ///
        /// <para>
        ///   Have you thought about
        ///   <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
        /// </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
        // Token: 0x170000AF RID: 175
        // (get) Token: 0x0600027C RID: 636 RVA: 0x00010A70 File Offset: 0x0000EC70
        // (set) Token: 0x0600027D RID: 637 RVA: 0x00010A88 File Offset: 0x0000EC88
        public Zip64Option UseZip64WhenSaving
        {
            get
            {
                return this._zip64;
            }
            set
            {
                this._zip64 = value;
            }
        }

        /// <summary>
        ///   Indicates whether the archive requires ZIP64 extensions.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
        ///   not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
        ///   contained in the archive.
        /// </para>
        ///
        /// <para>
        ///   The <c>Value</c> is true if any of the following four conditions holds:
        ///   the uncompressed size of any entry is larger than 0xFFFFFFFF; the
        ///   compressed size of any entry is larger than 0xFFFFFFFF; the relative
        ///   offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
        ///   there are more than 65534 entries in the archive.  (0xFFFFFFFF =
        ///   4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
        ///   on the zip archive.  The Value of this <see cref="T:System.Nullable" />
        ///   property may be set only AFTER one of the Save() methods has been called.
        /// </para>
        ///
        /// <para>
        ///   If none of the four conditions holds, and the archive has been saved, then
        ///   the <c>Value</c> is false.
        /// </para>
        ///
        /// <para>
        ///   A <c>Value</c> of false does not indicate that the zip archive, as saved,
        ///   does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
        ///   archive may use ZIP64 even when not required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not
        ///   seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property to determine if
        ///   the most recent <c>Save()</c> method resulted in an archive that utilized
        ///   the ZIP64 extensions.
        /// </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" />
        // Token: 0x170000B0 RID: 176
        // (get) Token: 0x0600027E RID: 638 RVA: 0x00010A94 File Offset: 0x0000EC94
        public bool? RequiresZip64
        {
            get
            {
                bool? result;
                if (this._entries.Count > 65534)
                {
                    result = new bool?(true);
                }
                else if (!this._hasBeenSaved || this._contentsChanged)
                {
                    result = null;
                }
                else
                {
                    foreach (ZipEntry e in this._entries.Values)
                    {
                        if (e.RequiresZip64.Value)
                        {
                            return new bool?(true);
                        }
                    }
                    result = new bool?(false);
                }
                return result;
            }
        }

        /// <summary>
        ///   Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The use of ZIP64 extensions within an archive is not always necessary, and
        ///   for interoperability concerns, it may be desired to NOT use ZIP64 if
        ///   possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property can be
        ///   set to use ZIP64 extensions only when necessary.  In those cases,
        ///   Sometimes applications want to know whether a Save() actually used ZIP64
        ///   extensions.  Applications can query this read-only property to learn
        ///   whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
        /// </para>
        ///
        /// <para>
        ///   The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
        ///   been saved.
        /// </para>
        ///
        /// <para>
        ///   Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
        ///   extensions were used during the most recent <c>Save()</c> operation.  The
        ///   ZIP64 extensions may have been used as required by any particular entry
        ///   because of its uncompressed or compressed size, or because the archive is
        ///   larger than 4294967295 bytes, or because there are more than 65534 entries
        ///   in the archive, or because the <c>UseZip64WhenSaving</c> property was set
        ///   to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or because the
        ///   <c>UseZip64WhenSaving</c> property was set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not seekable.
        ///   The value of this property does not indicate the reason the ZIP64
        ///   extensions were used.
        /// </para>
        ///
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
        // Token: 0x170000B1 RID: 177
        // (get) Token: 0x0600027F RID: 639 RVA: 0x00010B60 File Offset: 0x0000ED60
        public bool? OutputUsedZip64
        {
            get
            {
                return this._OutputUsesZip64;
            }
        }

        /// <summary>
        ///   Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
        ///   ZIP64 extensions.
        /// </summary>
        ///
        /// <remarks>
        ///   This property will return null (Nothing in VB) if you've added an entry after reading
        ///   the zip file.
        /// </remarks>
        // Token: 0x170000B2 RID: 178
        // (get) Token: 0x06000280 RID: 640 RVA: 0x00010B78 File Offset: 0x0000ED78
        public bool? InputUsesZip64
        {
            get
            {
                bool? result;
                if (this._entries.Count > 65534)
                {
                    result = new bool?(true);
                }
                else
                {
                    foreach (ZipEntry e in this)
                    {
                        if (e.Source != ZipEntrySource.ZipFile)
                        {
                            return null;
                        }
                        if (e._InputUsesZip64)
                        {
                            return new bool?(true);
                        }
                    }
                    result = new bool?(false);
                }
                return result;
            }
        }

        /// <summary>
        ///   The text encoding to use when writing new entries to the <c>ZipFile</c>,
        ///   for those entries that cannot be encoded with the default (IBM437)
        ///   encoding; or, the text encoding that was used when reading the entries
        ///   from the <c>ZipFile</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
        ///   zip specification</see>, PKWare describes two options for encoding
        ///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
        ///   or libraries do not follow the specification, and instead encode
        ///   characters using the system default code page.  For example, WinRAR when
        ///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
        ///   (950) code page.  This behavior is contrary to the Zip specification, but
        ///   it occurs anyway.
        /// </para>
        ///
        /// <para>
        ///   When using DotNetZip to write zip archives that will be read by one of
        ///   these other archivers, set this property to specify the code page to use
        ///   when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each <c>ZipEntry</c> in the zip file, for
        ///   values that cannot be encoded with the default codepage for zip files,
        ///   IBM437.  This is why this property is "provisional".  In all cases, IBM437
        ///   is used where possible, in other words, where no loss of data would
        ///   result. It is possible, therefore, to have a given entry with a
        ///   <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
        ///   specified "provisional" codepage.
        /// </para>
        ///
        /// <para>
        ///   Be aware that a zip file created after you've explicitly set the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than
        ///   IBM437 may not be compliant to the PKWare specification, and may not be
        ///   readable by compliant archivers.  On the other hand, many (most?)
        ///   archivers are non-compliant and can read zip files created in arbitrary
        ///   code pages.  The trick is to use or specify the proper codepage when
        ///   reading the zip.
        /// </para>
        ///
        /// <para>
        ///   When creating a zip archive using this library, it is possible to change
        ///   the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each
        ///   entry you add, and between adding entries and the call to
        ///   <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
        ///   not readable.  For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once,
        ///   before adding any entries to the <c>ZipFile</c> instance.  There is one
        ///   exception to this recommendation, described later.
        /// </para>
        ///
        /// <para>
        ///   When using an arbitrary, non-UTF8 code page for encoding, there is no
        ///   standard way for the creator application - whether DotNetZip, WinZip,
        ///   WinRar, or something else - to formally specify in the zip file which
        ///   codepage has been used for the entries. As a result, readers of zip files
        ///   are not able to inspect the zip file and determine the codepage that was
        ///   used for the entries contained within it.  It is left to the application
        ///   or user to determine the necessary codepage when reading zip files encoded
        ///   this way.  In other words, if you explicitly specify the codepage when you
        ///   create the zipfile, you must explicitly specify the same codepage when
        ///   reading the zipfile.
        /// </para>
        ///
        /// <para>
        ///   The way you specify the code page to use when reading a zip file varies
        ///   depending on the tool or library you use to read the zip.  In DotNetZip,
        ///   you use a ZipFile.Read() method that accepts an encoding parameter.  It
        ///   isn't possible with Windows Explorer, as far as I know, to specify an
        ///   explicit codepage to use when reading a zip.  If you use an incorrect
        ///   codepage when reading a zipfile, you will get entries with filenames that
        ///   are incorrect, and the incorrect filenames may even contain characters
        ///   that are not legal for use within filenames in Windows. Extracting entries
        ///   with illegal characters in the filenames will lead to exceptions. It's too
        ///   bad, but this is just the way things are with code pages in zip
        ///   files. Caveat Emptor.
        /// </para>
        ///
        /// <para>
        ///   Example: Suppose you create a zipfile that contains entries with
        ///   filenames that have Danish characters.  If you use <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> equal to "iso-8859-1" (cp 28591),
        ///   the filenames will be correctly encoded in the zip.  But, to read that
        ///   zipfile correctly, you have to specify the same codepage at the time you
        ///   read it. If try to read that zip file with Windows Explorer or another
        ///   application that is not flexible with respect to the codepage used to
        ///   decode filenames in zipfiles, you will get a filename like "Inf°.txt".
        /// </para>
        ///
        /// <para>
        ///   When using DotNetZip to read a zip archive, and the zip archive uses an
        ///   arbitrary code page, you must specify the encoding to use before or when
        ///   the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
        ///   method that allows you to specify a System.Text.Encoding parameter.  Setting
        ///   the ProvisionalAlternateEncoding property after your application has read in
        ///   the zip archive will not affect the entry names of entries that have already
        ///   been read in.
        /// </para>
        ///
        /// <para>
        ///   And now, the exception to the rule described above.  One strategy for
        ///   specifying the code page for a given zip file is to describe the code page
        ///   in a human-readable form in the Zip comment. For example, the comment may
        ///   read "Entries in this archive are encoded in the Big5 code page".  For
        ///   maximum interoperability, the zip comment in this case should be encoded
        ///   in the default, IBM437 code page.  In this case, the zip comment is
        ///   encoded using a different page than the filenames.  To do this, Specify
        ///   <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
        ///   page, once before adding any entries, and then reset
        ///   <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see cref="P:Ionic.Zip.ZipFile.Comment" /> property and calling Save().
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example shows how to read a zip file using the Big-5 Chinese code page
        /// (950), and extract each entry in the zip file.  For this code to work as
        /// desired, the <c>Zipfile</c> must have been created using the big5 code page
        /// (CP950). This is typical, for example, when using WinRar on a machine with
        /// CP950 set as the default code page.  In that case, the names of entries
        /// within the Zip archive will be stored in that code page, and reading the zip
        /// archive must be done using that code page.  If the application did not use
        /// the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
        /// zip archive would not be correctly retrieved.
        /// <code>
        /// using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
        /// {
        ///     // retrieve and extract an entry using a name encoded with CP950
        ///     zip[MyDesiredEntry].Extract("unpack");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
        ///     ' retrieve and extract an entry using a name encoded with CP950
        ///     zip(MyDesiredEntry).Extract("unpack")
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        // Token: 0x170000B3 RID: 179
        // (get) Token: 0x06000281 RID: 641 RVA: 0x00010C24 File Offset: 0x0000EE24
        // (set) Token: 0x06000282 RID: 642 RVA: 0x00010C50 File Offset: 0x0000EE50
        [Obsolete("use AlternateEncoding instead.")]
        public Encoding ProvisionalAlternateEncoding
        {
            get
            {
                Encoding result;
                if (this._alternateEncodingUsage == ZipOption.AsNecessary)
                {
                    result = this._alternateEncoding;
                }
                else
                {
                    result = null;
                }
                return result;
            }
            set
            {
                this._alternateEncoding = value;
                this._alternateEncodingUsage = ZipOption.AsNecessary;
            }
        }

        /// <summary>
        ///   A Text Encoding to use when encoding the filenames and comments for
        ///   all the ZipEntry items, during a ZipFile.Save() operation.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Whether the encoding specified here is used during the save depends
        ///     on <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />.
        ///   </para>
        /// </remarks>
        // Token: 0x170000B4 RID: 180
        // (get) Token: 0x06000283 RID: 643 RVA: 0x00010C64 File Offset: 0x0000EE64
        // (set) Token: 0x06000284 RID: 644 RVA: 0x00010C7C File Offset: 0x0000EE7C
        public Encoding AlternateEncoding
        {
            get
            {
                return this._alternateEncoding;
            }
            set
            {
                this._alternateEncoding = value;
            }
        }

        /// <summary>
        ///   A flag that tells if and when this instance should apply
        ///   AlternateEncoding to encode the filenames and comments associated to
        ///   of ZipEntry objects contained within this instance.
        /// </summary>
        // Token: 0x170000B5 RID: 181
        // (get) Token: 0x06000285 RID: 645 RVA: 0x00010C88 File Offset: 0x0000EE88
        // (set) Token: 0x06000286 RID: 646 RVA: 0x00010CA0 File Offset: 0x0000EEA0
        public ZipOption AlternateEncodingUsage
        {
            get
            {
                return this._alternateEncodingUsage;
            }
            set
            {
                this._alternateEncodingUsage = value;
            }
        }

        /// <summary>
        /// The default text encoding used in zip archives.  It is numeric 437, also
        /// known as IBM437.
        /// </summary>
        /// <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        // Token: 0x170000B6 RID: 182
        // (get) Token: 0x06000287 RID: 647 RVA: 0x00010CAC File Offset: 0x0000EEAC
        public static Encoding DefaultEncoding
        {
            get
            {
                return ZipFile._defaultEncoding;
            }
        }

        /// <summary>
        /// Gets or sets the <c>TextWriter</c> to which status messages are delivered
        /// for the instance.
        /// </summary>
        ///
        /// <remarks>
        ///   If the TextWriter is set to a non-null value, then verbose output is sent
        ///   to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
        ///   <c>Extract</c> operations.  Typically, console applications might use
        ///   <c>Console.Out</c> and graphical or headless applications might use a
        ///   <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
        ///   by humans.
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   In this example, a console application instantiates a <c>ZipFile</c>, then
        ///   sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
        ///   point, all verbose status messages for that <c>ZipFile</c> are sent to the
        ///   console.
        /// </para>
        ///
        /// <code lang="C#">
        /// using (ZipFile zip= ZipFile.Read(FilePath))
        /// {
        ///   zip.StatusMessageTextWriter= System.Console.Out;
        ///   // messages are sent to the console during extraction
        ///   zip.ExtractAll();
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(FilePath)
        ///   zip.StatusMessageTextWriter= System.Console.Out
        ///   'Status Messages will be sent to the console during extraction
        ///   zip.ExtractAll()
        /// End Using
        /// </code>
        ///
        /// <para>
        ///   In this example, a Windows Forms application instantiates a
        ///   <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
        ///   <c>StringWriter</c>.  At that point, all verbose status messages for that
        ///   <c>ZipFile</c> are sent to the <c>StringWriter</c>.
        /// </para>
        ///
        /// <code lang="C#">
        /// var sw = new System.IO.StringWriter();
        /// using (ZipFile zip= ZipFile.Read(FilePath))
        /// {
        ///   zip.StatusMessageTextWriter= sw;
        ///   zip.ExtractAll();
        /// }
        /// Console.WriteLine("{0}", sw.ToString());
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim sw as New System.IO.StringWriter
        /// Using zip As ZipFile = ZipFile.Read(FilePath)
        ///   zip.StatusMessageTextWriter= sw
        ///   zip.ExtractAll()
        /// End Using
        /// 'Status Messages are now available in sw
        ///
        /// </code>
        /// </example>
        // Token: 0x170000B7 RID: 183
        // (get) Token: 0x06000288 RID: 648 RVA: 0x00010CC4 File Offset: 0x0000EEC4
        // (set) Token: 0x06000289 RID: 649 RVA: 0x00010CDC File Offset: 0x0000EEDC
        public TextWriter StatusMessageTextWriter
        {
            get
            {
                return this._StatusMessageTextWriter;
            }
            set
            {
                this._StatusMessageTextWriter = value;
            }
        }

        /// <summary>
        ///   Gets or sets the name for the folder to store the temporary file
        ///   this library writes when saving a zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This library will create a temporary file when saving a Zip archive to a
        ///   file.  This file is written when calling one of the <c>Save()</c> methods
        ///   that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
        ///   methods.
        /// </para>
        ///
        /// <para>
        ///   By default, the library will create the temporary file in the directory
        ///   specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name" /> property or via
        ///   the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> method.
        /// </para>
        ///
        /// <para>
        ///   Setting this property allows applications to override this default
        ///   behavior, so that the library will create the temporary file in the
        ///   specified folder. For example, to have the library create the temporary
        ///   file in the current working directory, regardless where the <c>ZipFile</c>
        ///   is saved, specfy ".".  To revert to the default behavior, set this
        ///   property to <c>null</c> (<c>Nothing</c> in VB).
        /// </para>
        ///
        /// <para>
        ///   When setting the property to a non-null value, the folder specified must
        ///   exist; if it does not an exception is thrown.  The application should have
        ///   write and delete permissions on the folder.  The permissions are not
        ///   explicitly checked ahead of time; if the application does not have the
        ///   appropriate rights, an exception will be thrown at the time <c>Save()</c>
        ///   is called.
        /// </para>
        ///
        /// <para>
        ///   There is no temporary file created when reading a zip archive.  When
        ///   saving to a Stream, there is no temporary file created.  For example, if
        ///   the application is an ASP.NET application and calls <c>Save()</c>
        ///   specifying the <c>Response.OutputStream</c> as the output stream, there is
        ///   no temporary file created.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.IO.FileNotFoundException">
        /// Thrown when setting the property if the directory does not exist.
        /// </exception>
        // Token: 0x170000B8 RID: 184
        // (get) Token: 0x0600028A RID: 650 RVA: 0x00010CE8 File Offset: 0x0000EEE8
        // (set) Token: 0x0600028B RID: 651 RVA: 0x00010D00 File Offset: 0x0000EF00
        public string TempFileFolder
        {
            get
            {
                return this._TempFileFolder;
            }
            set
            {
                this._TempFileFolder = value;
                if (value != null)
                {
                    if (!Directory.Exists(value))
                    {
                        throw new FileNotFoundException(string.Format("That directory ({0}) does not exist.", value));
                    }
                }
            }
        }

        /// <summary>
        /// Sets the password to be used on the <c>ZipFile</c> instance.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When writing a zip archive, this password is applied to the entries, not
        ///   to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
        ///   added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
        ///   <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
        ///   When reading a zip archive, this property applies to any entry
        ///   subsequently extracted from the <c>ZipFile</c> using one of the Extract
        ///   methods on the <c>ZipFile</c> class.
        /// </para>
        ///
        /// <para>
        ///   When writing a zip archive, keep this in mind: though the password is set
        ///   on the ZipFile object, according to the Zip spec, the "directory" of the
        ///   archive - in other words the list of entries or files contained in the archive - is
        ///   not encrypted with the password, or protected in any way.  If you set the
        ///   Password property, the password actually applies to individual entries
        ///   that are added to the archive, subsequent to the setting of this property.
        ///   The list of filenames in the archive that is eventually created will
        ///   appear in clear text, but the contents of the individual files are
        ///   encrypted.  This is how Zip encryption works.
        /// </para>
        ///
        /// <para>
        ///   One simple way around this limitation is to simply double-wrap sensitive
        ///   filenames: Store the files in a zip file, and then store that zip file
        ///   within a second, "outer" zip file.  If you apply a password to the outer
        ///   zip file, then readers will be able to see that the outer zip file
        ///   contains an inner zip file.  But readers will not be able to read the
        ///   directory or file list of the inner zip file.
        /// </para>
        ///
        /// <para>
        ///   If you set the password on the <c>ZipFile</c>, and then add a set of files
        ///   to the archive, then each entry is encrypted with that password.  You may
        ///   also want to change the password between adding different entries. If you
        ///   set the password, add an entry, then set the password to <c>null</c>
        ///   (<c>Nothing</c> in VB), and add another entry, the first entry is
        ///   encrypted and the second is not.  If you call <c>AddFile()</c>, then set
        ///   the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
        ///   added will not be password-protected, and no warning will be generated.
        /// </para>
        ///
        /// <para>
        ///   When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property, to specify how to encrypt the entries added
        ///   to the ZipFile.  If you set the Password to a non-null value and do not
        ///   set <see cref="P:Ionic.Zip.ZipFile.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.
        ///   This encryption is relatively weak but is very interoperable. If you set
        ///   the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
        ///   reset to None.
        /// </para>
        ///
        /// <para>
        ///   All of the preceding applies to writing zip archives, in other words when
        ///   you use one of the Save methods.  To use this property when reading or an
        ///   existing ZipFile, do the following: set the Password property on the
        ///   <c>ZipFile</c>, then call one of the Extract() overloads on the <see cref="T:Ionic.Zip.ZipEntry" />. In this case, the entry is extracted using the
        ///   <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
        ///   have not set the <c>Password</c> property, then the password is
        ///   <c>null</c>, and the entry is extracted with no password.
        /// </para>
        ///
        /// <para>
        ///   If you set the Password property on the <c>ZipFile</c>, then call
        ///   <c>Extract()</c> an entry that has not been encrypted with a password, the
        ///   password is not used for that entry, and the <c>ZipEntry</c> is extracted
        ///   as normal. In other words, the password is used only if necessary.
        /// </para>
        ///
        /// <para>
        ///   The <see cref="T:Ionic.Zip.ZipEntry" /> class also has a <see cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
        ///   over this property on the <c>ZipFile</c>.  Typically, you would use the
        ///   per-entry Password when most entries in the zip archive use one password,
        ///   and a few entries use a different password.  If all entries in the zip
        ///   file use the same password, then it is simpler to just set this property
        ///   on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
        ///   a zip archive.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example creates a zip file, using password protection for the
        ///   entries, and then extracts the entries from the zip file.  When creating
        ///   the zip file, the Readme.txt file is not protected with a password, but
        ///   the other two are password-protected as they are saved. During extraction,
        ///   each file is extracted with the appropriate password.
        /// </para>
        /// <code>
        /// // create a file with encryption
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddFile("ReadMe.txt");
        ///     zip.Password= "!Secret1";
        ///     zip.AddFile("MapToTheSite-7440-N49th.png");
        ///     zip.AddFile("2008-Regional-Sales-Report.pdf");
        ///     zip.Save("EncryptedArchive.zip");
        /// }
        ///
        /// // extract entries that use encryption
        /// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
        /// {
        ///     zip.Password= "!Secret1";
        ///     zip.ExtractAll("extractDir");
        /// }
        ///
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     zip.AddFile("ReadMe.txt")
        ///     zip.Password = "123456!"
        ///     zip.AddFile("MapToTheSite-7440-N49th.png")
        ///     zip.Password= "!Secret1";
        ///     zip.AddFile("2008-Regional-Sales-Report.pdf")
        ///     zip.Save("EncryptedArchive.zip")
        /// End Using
        ///
        ///
        /// ' extract entries that use encryption
        /// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
        ///     zip.Password= "!Secret1"
        ///     zip.ExtractAll("extractDir")
        /// End Using
        ///
        /// </code>
        ///
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        // Token: 0x170000B9 RID: 185
        // (get) Token: 0x0600028D RID: 653 RVA: 0x00010D8C File Offset: 0x0000EF8C
        // (set) Token: 0x0600028C RID: 652 RVA: 0x00010D40 File Offset: 0x0000EF40
        public string Password
        {
            private get
            {
                return this._Password;
            }
            set
            {
                this._Password = value;
                if (this._Password == null)
                {
                    this.Encryption = EncryptionAlgorithm.None;
                }
                else if (this.Encryption == EncryptionAlgorithm.None)
                {
                    this.Encryption = EncryptionAlgorithm.PkzipWeak;
                }
            }
        }

        /// <summary>
        ///   The action the library should take when extracting a file that already
        ///   exists.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This property affects the behavior of the Extract methods (one of the
        ///   <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
        ///   extraction would would overwrite an existing filesystem file. If you do
        ///   not set this property, the library throws an exception when extracting an
        ///   entry would overwrite an existing file.
        /// </para>
        ///
        /// <para>
        ///   This property has no effect when extracting to a stream, or when the file
        ///   to be extracted does not already exist.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        // Token: 0x170000BA RID: 186
        // (get) Token: 0x0600028E RID: 654 RVA: 0x00010DA4 File Offset: 0x0000EFA4
        // (set) Token: 0x0600028F RID: 655 RVA: 0x00010DBB File Offset: 0x0000EFBB
        public ExtractExistingFileAction ExtractExistingFile { get; set; }

        /// <summary>
        ///   The action the library should take when an error is encountered while
        ///   opening or reading files as they are saved into a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    Errors can occur as a file is being saved to the zip archive.  For
        ///    example, the File.Open may fail, or a File.Read may fail, because of
        ///    lock conflicts or other reasons.
        ///  </para>
        ///
        ///  <para>
        ///    The first problem might occur after having called AddDirectory() on a
        ///    directory that contains a Clipper .dbf file; the file is locked by
        ///    Clipper and cannot be opened for read by another process. An example of
        ///    the second problem might occur when trying to zip a .pst file that is in
        ///    use by Microsoft Outlook. Outlook locks a range on the file, which allows
        ///    other processes to open the file, but not read it in its entirety.
        ///  </para>
        ///
        ///  <para>
        ///    This property tells DotNetZip what you would like to do in the case of
        ///    these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
        ///    throw an exception (this is the default behavior if you don't set this
        ///    property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
        ///    was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
        ///    the entry that caused the problem; or
        ///    <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
        ///  </para>
        ///
        ///  <para>
        ///    This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
        ///    if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError" /> event.  If you set
        ///    this property to something other than
        ///    <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
        ///    event is implicitly cleared.  What it means is you can set one or the
        ///    other (or neither), depending on what you want, but you never need to set
        ///    both.
        ///  </para>
        ///
        ///  <para>
        ///    As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.Encryption" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, setting this property on a <c>ZipFile</c>
        ///    instance will cause the specified <c>ZipErrorAction</c> to be used on all
        ///    <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
        ///    <c>ZipFile</c> instance. If you set this property after you have added
        ///    items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
        ///    those items will not use the specified error handling action.
        ///  </para>
        ///
        ///  <para>
        ///    If you want to handle any errors that occur with any entry in the zip
        ///    file in the same way, then set this property once, before adding any
        ///    entries to the zip archive.
        ///  </para>
        ///
        ///  <para>
        ///    If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
        ///    learn which files may have been skipped after a <c>Save()</c>, you can
        ///    set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> on the ZipFile before
        ///    calling <c>Save()</c>. A message will be emitted into that writer for
        ///    each skipped file, if any.
        ///  </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///   This example shows how to tell DotNetZip to skip any files for which an
        ///   error is generated during the Save().
        /// <code lang="VB">
        /// Public Sub SaveZipFile()
        ///     Dim SourceFolder As String = "fodder"
        ///     Dim DestFile As String =  "eHandler.zip"
        ///     Dim sw as New StringWriter
        ///     Using zipArchive As ZipFile = New ZipFile
        ///         ' Tell DotNetZip to skip any files for which it encounters an error
        ///         zipArchive.ZipErrorAction = ZipErrorAction.Skip
        ///         zipArchive.StatusMessageTextWriter = sw
        ///         zipArchive.AddDirectory(SourceFolder)
        ///         zipArchive.Save(DestFile)
        ///     End Using
        ///     ' examine sw here to see any messages
        /// End Sub
        ///
        /// </code>
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ZipError" />
        // Token: 0x170000BB RID: 187
        // (get) Token: 0x06000290 RID: 656 RVA: 0x00010DC4 File Offset: 0x0000EFC4
        // (set) Token: 0x06000291 RID: 657 RVA: 0x00010DF0 File Offset: 0x0000EFF0
        public ZipErrorAction ZipErrorAction
        {
            get
            {
                if (this.ZipError != null)
                {
                    this._zipErrorAction = ZipErrorAction.InvokeErrorEvent;
                }
                return this._zipErrorAction;
            }
            set
            {
                this._zipErrorAction = value;
                if (this._zipErrorAction != ZipErrorAction.InvokeErrorEvent && this.ZipError != null)
                {
                    this.ZipError = null;
                }
            }
        }

        /// <summary>
        ///   The Encryption to use for entries added to the <c>ZipFile</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Set this when creating a zip archive, or when updating a zip archive. The
        ///   specified Encryption is applied to the entries subsequently added to the
        ///   <c>ZipFile</c> instance.  Applications do not need to set the
        ///   <c>Encryption</c> property when reading or extracting a zip archive.
        /// </para>
        ///
        /// <para>
        ///   If you set this to something other than EncryptionAlgorithm.None, you
        ///   will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password" />.
        /// </para>
        ///
        /// <para>
        ///   As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, setting this
        ///   property on a <c>ZipFile</c> instance will cause the specified
        ///   <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry" /> items
        ///   that are subsequently added to the <c>ZipFile</c> instance. In other
        ///   words, if you set this property after you have added items to the
        ///   <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
        ///   not be encrypted or protected with a password in the resulting zip
        ///   archive. To get a zip archive with encrypted entries, set this property,
        ///   along with the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, before calling
        ///   <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
        ///   <c>ZipFile</c> instance.
        /// </para>
        ///
        /// <para>
        ///   If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
        ///   encrypted entry, only by setting the <c>Encryption</c> property on the
        ///   <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
        ///   <c>ZipFile</c>, once it has been created via a call to
        ///   <c>ZipFile.Read()</c>, does not affect entries that were previously read.
        /// </para>
        ///
        /// <para>
        ///   For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
        ///   entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
        ///   then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
        ///   <c>Encryption</c> used for the entries in the archive.  Neither is an
        ///   exception thrown. Instead, what happens during the <c>Save()</c> is that
        ///   all previously existing entries are copied through to the new zip archive,
        ///   with whatever encryption and password that was used when originally
        ///   creating the zip archive. Upon re-reading that archive, to extract
        ///   entries, applications should use the original password or passwords, if
        ///   any.
        /// </para>
        ///
        /// <para>
        ///   Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
        ///   entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
        ///   then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
        ///   and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
        ///   <c>Encryption</c> on any of the entries that had previously been in the
        ///   <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
        ///   newly-added entries.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example creates a zip archive that uses encryption, and then extracts
        ///   entries from the archive.  When creating the zip archive, the ReadMe.txt
        ///   file is zipped without using a password or encryption.  The other files
        ///   use encryption.
        /// </para>
        ///
        /// <code>
        /// // Create a zip archive with AES Encryption.
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddFile("ReadMe.txt");
        ///     zip.Encryption= EncryptionAlgorithm.WinZipAes256;
        ///     zip.Password= "Top.Secret.No.Peeking!";
        ///     zip.AddFile("7440-N49th.png");
        ///     zip.AddFile("2008-Regional-Sales-Report.pdf");
        ///     zip.Save("EncryptedArchive.zip");
        /// }
        ///
        /// // Extract a zip archive that uses AES Encryption.
        /// // You do not need to specify the algorithm during extraction.
        /// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
        /// {
        ///     zip.Password= "Top.Secret.No.Peeking!";
        ///     zip.ExtractAll("extractDirectory");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// ' Create a zip that uses Encryption.
        /// Using zip As New ZipFile()
        ///     zip.Encryption= EncryptionAlgorithm.WinZipAes256
        ///     zip.Password= "Top.Secret.No.Peeking!"
        ///     zip.AddFile("ReadMe.txt")
        ///     zip.AddFile("7440-N49th.png")
        ///     zip.AddFile("2008-Regional-Sales-Report.pdf")
        ///     zip.Save("EncryptedArchive.zip")
        /// End Using
        ///
        /// ' Extract a zip archive that uses AES Encryption.
        /// ' You do not need to specify the algorithm during extraction.
        /// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
        ///     zip.Password= "Top.Secret.No.Peeking!"
        ///     zip.ExtractAll("extractDirectory")
        /// End Using
        /// </code>
        ///
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        // Token: 0x170000BC RID: 188
        // (get) Token: 0x06000292 RID: 658 RVA: 0x00010E28 File Offset: 0x0000F028
        // (set) Token: 0x06000293 RID: 659 RVA: 0x00010E40 File Offset: 0x0000F040
        public EncryptionAlgorithm Encryption
        {
            get
            {
                return this._Encryption;
            }
            set
            {
                if (value == EncryptionAlgorithm.Unsupported)
                {
                    throw new InvalidOperationException("You may not set Encryption to that value.");
                }
                this._Encryption = value;
            }
        }

        /// <summary>
        ///   A callback that allows the application to specify the compression level
        ///   to use for entries subsequently added to the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   With this callback, the DotNetZip library allows the application to
        ///   determine whether compression will be used, at the time of the
        ///   <c>Save</c>. This may be useful if the application wants to favor
        ///   speed over size, and wants to defer the decision until the time of
        ///   <c>Save</c>.
        /// </para>
        ///
        /// <para>
        ///   Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" /> property on
        ///   the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
        ///   compression used. This is done at the time the entry is added to the
        ///   <c>ZipFile</c>. Setting the property to
        ///   <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
        /// </para>
        ///
        /// <para>
        ///   This callback allows the application to defer the decision on the
        ///   <c>CompressionLevel</c> to use, until the time of the call to
        ///   <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
        ///   at the time the data for the entry is being written out as part of a
        ///   <c>Save()</c> operation. The application can use whatever criteria it
        ///   likes in determining the level to return.  For example, an application may
        ///   wish that no .mp3 files should be compressed, because they are already
        ///   compressed and the extra compression is not worth the CPU time incurred,
        ///   and so can return <c>None</c> for all .mp3 entries.
        /// </para>
        ///
        /// <para>
        ///   The library determines whether compression will be attempted for an entry
        ///   this way: If the entry is a zero length file, or a directory, no
        ///   compression is used.  Otherwise, if this callback is set, it is invoked
        ///   and the <c>CompressionLevel</c> is set to the return value. If this
        ///   callback has not been set, then the previously set value for
        ///   <c>CompressionLevel</c> is used.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x170000BD RID: 189
        // (get) Token: 0x06000294 RID: 660 RVA: 0x00010E6C File Offset: 0x0000F06C
        // (set) Token: 0x06000295 RID: 661 RVA: 0x00010E83 File Offset: 0x0000F083
        public SetCompressionCallback SetCompression { get; set; }

        /// <summary>
        /// The maximum size of an output segment, when saving a split Zip file.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save" /> or <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> to specify that the ZipFile should be saved as a
        ///     split archive, also sometimes called a spanned archive. Some also
        ///     call them multi-file archives.
        ///   </para>
        ///
        ///   <para>
        ///     A split zip archive is saved in a set of discrete filesystem files,
        ///     rather than in a single file. This is handy when transmitting the
        ///     archive in email or some other mechanism that has a limit to the size of
        ///     each file.  The first file in a split archive will be named
        ///     <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
        ///     so on. The final file is named <c>basename.zip</c>. According to the zip
        ///     specification from PKWare, the minimum value is 65536, for a 64k segment
        ///     size. The maximum number of segments allows in a split archive is 99.
        ///   </para>
        ///
        ///   <para>
        ///     The value of this property determines the maximum size of a split
        ///     segment when writing a split archive.  For example, suppose you have a
        ///     <c>ZipFile</c> that would save to a single file of 200k. If you set the
        ///     <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
        ///     will get four distinct output files. On the other hand if you set this
        ///     property to 256k, then you will get a single-file archive for that
        ///     <c>ZipFile</c>.
        ///   </para>
        ///
        ///   <para>
        ///     The size of each split output file will be as large as possible, up to
        ///     the maximum size set here. The zip specification requires that some data
        ///     fields in a zip archive may not span a split boundary, and an output
        ///     segment may be smaller than the maximum if necessary to avoid that
        ///     problem. Also, obviously the final segment of the archive may be smaller
        ///     than the maximum segment size. Segments will never be larger than the
        ///     value set with this property.
        ///   </para>
        ///
        ///   <para>
        ///     You can save a split Zip file only when saving to a regular filesystem
        ///     file. It's not possible to save a split zip file as a self-extracting
        ///     archive, nor is it possible to save a split zip file to a stream. When
        ///     saving to a SFX or to a Stream, this property is ignored.
        ///   </para>
        ///
        ///   <para>
        ///     About interoperability: Split or spanned zip files produced by DotNetZip
        ///     can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
        ///     not be readable by other tools, if those other tools don't support zip
        ///     spanning or splitting.  When in doubt, test.  I don't believe Windows
        ///     Explorer can extract a split archive.
        ///   </para>
        ///
        ///   <para>
        ///     This property has no effect when reading a split archive. You can read
        ///     a split archive in the normal way with DotNetZip.
        ///   </para>
        ///
        ///   <para>
        ///     When saving a zip file, if you want a regular zip file rather than a
        ///     split zip file, don't set this property, or set it to Zero.
        ///   </para>
        ///
        ///   <para>
        ///     If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> and
        ///     then subsequently call <c>ZipFile.Save()</c>, unless you set this
        ///     property before calling <c>Save()</c>, you will get a normal,
        ///     single-file archive.
        ///   </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave" />
        // Token: 0x170000BE RID: 190
        // (get) Token: 0x06000296 RID: 662 RVA: 0x00010E8C File Offset: 0x0000F08C
        // (set) Token: 0x06000297 RID: 663 RVA: 0x00010EA4 File Offset: 0x0000F0A4
        public int MaxOutputSegmentSize
        {
            get
            {
                return this._maxOutputSegmentSize;
            }
            set
            {
                if (value < 65536 && value != 0)
                {
                    throw new ZipException("The minimum acceptable segment size is 65536.");
                }
                this._maxOutputSegmentSize = value;
            }
        }

        /// <summary>
        ///   Returns the number of segments used in the most recent Save() operation.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     This is normally zero, unless you have set the <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" /> property.  If you have set <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" />, and then you save a file, after the call to
        ///     Save() completes, you can read this value to learn the number of segments that
        ///     were created.
        ///   </para>
        ///   <para>
        ///     If you call Save("Archive.zip"), and it creates 5 segments, then you
        ///     will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
        ///     Archive.z04, and Archive.zip, and the value of this property will be 5.
        ///   </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" />
        // Token: 0x170000BF RID: 191
        // (get) Token: 0x06000298 RID: 664 RVA: 0x00010ED8 File Offset: 0x0000F0D8
        public int NumberOfSegmentsForMostRecentSave
        {
            get
            {
                return (int)(this._numberOfSegmentsForMostRecentSave + 1u);
            }
        }

        /// <summary>
        ///   The size threshold for an entry, above which a parallel deflate is used.
        /// </summary>
        ///
        /// <remarks>
        ///
        ///   <para>
        ///     DotNetZip will use multiple threads to compress any ZipEntry,
        ///     if the entry is larger than the given size.  Zero means "always
        ///     use parallel deflate", while -1 means "never use parallel
        ///     deflate". The default value for this property is 512k. Aside
        ///     from the special values of 0 and 1, the minimum value is 65536.
        ///   </para>
        ///
        ///   <para>
        ///     If the entry size cannot be known before compression, as with a
        ///     read-forward stream, then Parallel deflate will never be
        ///     performed, unless the value of this property is zero.
        ///   </para>
        ///
        ///   <para>
        ///     A parallel deflate operations will speed up the compression of
        ///     large files, on computers with multiple CPUs or multiple CPU
        ///     cores.  For files above 1mb, on a dual core or dual-cpu (2p)
        ///     machine, the time required to compress the file can be 70% of the
        ///     single-threaded deflate.  For very large files on 4p machines the
        ///     compression can be done in 30% of the normal time.  The downside
        ///     is that parallel deflate consumes extra memory during the deflate,
        ///     and the deflation is not as effective.
        ///   </para>
        ///
        ///   <para>
        ///     Parallel deflate tends to yield slightly less compression when
        ///     compared to as single-threaded deflate; this is because the original
        ///     data stream is split into multiple independent buffers, each of which
        ///     is compressed in parallel.  But because they are treated
        ///     independently, there is no opportunity to share compression
        ///     dictionaries.  For that reason, a deflated stream may be slightly
        ///     larger when compressed using parallel deflate, as compared to a
        ///     traditional single-threaded deflate. Sometimes the increase over the
        ///     normal deflate is as much as 5% of the total compressed size. For
        ///     larger files it can be as small as 0.1%.
        ///   </para>
        ///
        ///   <para>
        ///     Multi-threaded compression does not give as much an advantage when
        ///     using Encryption. This is primarily because encryption tends to slow
        ///     down the entire pipeline. Also, multi-threaded compression gives less
        ///     of an advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed" />.  You may have to
        ///     perform some tests to determine the best approach for your situation.
        ///   </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs" />
        // Token: 0x170000C0 RID: 192
        // (get) Token: 0x0600029A RID: 666 RVA: 0x00010F34 File Offset: 0x0000F134
        // (set) Token: 0x06000299 RID: 665 RVA: 0x00010EF4 File Offset: 0x0000F0F4
        public long ParallelDeflateThreshold
        {
            get
            {
                return this._ParallelDeflateThreshold;
            }
            set
            {
                if (value != 0L && value != -1L && value < 65536L)
                {
                    throw new ArgumentOutOfRangeException("ParallelDeflateThreshold should be -1, 0, or > 65536");
                }
                this._ParallelDeflateThreshold = value;
            }
        }

        /// <summary>
        ///   The maximum number of buffer pairs to use when performing
        ///   parallel compression.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This property sets an upper limit on the number of memory
        ///   buffer pairs to create when performing parallel
        ///   compression.  The implementation of the parallel
        ///   compression stream allocates multiple buffers to
        ///   facilitate parallel compression.  As each buffer fills up,
        ///   the stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
        ///   ThreadPool.QueueUserWorkItem()</see> to compress those
        ///   buffers in a background threadpool thread. After a buffer
        ///   is compressed, it is re-ordered and written to the output
        ///   stream.
        /// </para>
        ///
        /// <para>
        ///   A higher number of buffer pairs enables a higher degree of
        ///   parallelism, which tends to increase the speed of compression on
        ///   multi-cpu computers.  On the other hand, a higher number of buffer
        ///   pairs also implies a larger memory consumption, more active worker
        ///   threads, and a higher cpu utilization for any compression. This
        ///   property enables the application to limit its memory consumption and
        ///   CPU utilization behavior depending on requirements.
        /// </para>
        ///
        /// <para>
        ///   For each compression "task" that occurs in parallel, there are 2
        ///   buffers allocated: one for input and one for output.  This property
        ///   sets a limit for the number of pairs.  The total amount of storage
        ///   space allocated for buffering will then be (N*S*2), where N is the
        ///   number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zip.ZipFile.BufferSize" />).  By default, DotNetZip allocates 4 buffer
        ///   pairs per CPU core, so if your machine has 4 cores, and you retain
        ///   the default buffer size of 128k, then the
        ///   ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
        ///   memory in total, or 4mb, in blocks of 128kb.  If you then set this
        ///   property to 8, then the number will be 8 * 2 * 128kb of buffer
        ///   memory, or 2mb.
        /// </para>
        ///
        /// <para>
        ///   CPU utilization will also go up with additional buffers, because a
        ///   larger number of buffer pairs allows a larger number of background
        ///   threads to compress in parallel. If you find that parallel
        ///   compression is consuming too much memory or CPU, you can adjust this
        ///   value downward.
        /// </para>
        ///
        /// <para>
        ///   The default value is 16. Different values may deliver better or
        ///   worse results, depending on your priorities and the dynamic
        ///   performance characteristics of your storage and compute resources.
        /// </para>
        ///
        /// <para>
        ///   This property is not the number of buffer pairs to use; it is an
        ///   upper limit. An illustration: Suppose you have an application that
        ///   uses the default value of this property (which is 16), and it runs
        ///   on a machine with 2 CPU cores. In that case, DotNetZip will allocate
        ///   4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
        ///   limit specified by this property has no effect.
        /// </para>
        ///
        /// <para>
        ///   The application can set this value at any time
        ///   before calling <c>ZipFile.Save()</c>.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold" />
        // Token: 0x170000C1 RID: 193
        // (get) Token: 0x0600029B RID: 667 RVA: 0x00010F4C File Offset: 0x0000F14C
        // (set) Token: 0x0600029C RID: 668 RVA: 0x00010F64 File Offset: 0x0000F164
        public int ParallelDeflateMaxBufferPairs
        {
            get
            {
                return this._maxBufferPairs;
            }
            set
            {
                if (value < 4)
                {
                    throw new ArgumentOutOfRangeException("ParallelDeflateMaxBufferPairs", "Value must be 4 or greater.");
                }
                this._maxBufferPairs = value;
            }
        }

        /// <summary>Provides a string representation of the instance.</summary>
        /// <returns>a string representation of the instance.</returns>
        // Token: 0x0600029D RID: 669 RVA: 0x00010F94 File Offset: 0x0000F194
        public override string ToString()
        {
            return string.Format("ZipFile::{0}", this.Name);
        }

        /// <summary>
        /// Returns the version number on the DotNetZip assembly.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     This property is exposed as a convenience.  Callers could also get the
        ///     version value by retrieving GetName().Version on the
        ///     System.Reflection.Assembly object pointing to the DotNetZip
        ///     assembly. But sometimes it is not clear which assembly is being loaded.
        ///     This property makes it clear.
        ///   </para>
        ///   <para>
        ///     This static property is primarily useful for diagnostic purposes.
        ///   </para>
        /// </remarks>
        // Token: 0x170000C2 RID: 194
        // (get) Token: 0x0600029E RID: 670 RVA: 0x00010FB8 File Offset: 0x0000F1B8
        public static Version LibraryVersion
        {
            get
            {
                return Assembly.GetExecutingAssembly().GetName().Version;
            }
        }

        // Token: 0x0600029F RID: 671 RVA: 0x00010FD9 File Offset: 0x0000F1D9
        internal void NotifyEntryChanged()
        {
            this._contentsChanged = true;
        }

        // Token: 0x060002A0 RID: 672 RVA: 0x00010FE4 File Offset: 0x0000F1E4
        internal Stream StreamForDiskNumber(uint diskNumber)
        {
            Stream result;
            if (diskNumber + 1u == this._diskNumberWithCd || (diskNumber == 0u && this._diskNumberWithCd == 0u))
            {
                result = this.ReadStream;
            }
            else
            {
                result = ZipSegmentedStream.ForReading(this._readName ?? this._name, diskNumber, this._diskNumberWithCd);
            }
            return result;
        }

        // Token: 0x060002A1 RID: 673 RVA: 0x00011040 File Offset: 0x0000F240
        internal void Reset(bool whileSaving)
        {
            if (this._JustSaved)
            {
                using (ZipFile x = new ZipFile())
                {
                    x._readName = (x._name = (whileSaving ? (this._readName ?? this._name) : this._name));
                    x.AlternateEncoding = this.AlternateEncoding;
                    x.AlternateEncodingUsage = this.AlternateEncodingUsage;
                    ZipFile.ReadIntoInstance(x);
                    foreach (ZipEntry e in x)
                    {
                        foreach (ZipEntry e2 in this)
                        {
                            if (e.FileName == e2.FileName)
                            {
                                e2.CopyMetaData(e);
                                break;
                            }
                        }
                    }
                }
                this._JustSaved = false;
            }
        }

        /// <summary>
        ///   Creates a new <c>ZipFile</c> instance, using the specified filename.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Applications can use this constructor to create a new ZipFile for writing,
        ///   or to slurp in an existing zip archive for read and update purposes.
        /// </para>
        ///
        /// <para>
        ///   To create a new zip archive, an application can call this constructor,
        ///   passing the name of a file that does not exist.  The name may be a fully
        ///   qualified path. Then the application can add directories or files to the
        ///   <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
        ///   and then write the zip archive to the disk by calling <c>Save()</c>. The
        ///   zip file is not actually opened and written to the disk until the
        ///   application calls <c>ZipFile.Save()</c>.  At that point the new zip file
        ///   with the given name is created.
        /// </para>
        ///
        /// <para>
        ///   If you won't know the name of the <c>Zipfile</c> until the time you call
        ///   <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
        ///   name), then you should use the no-argument constructor.
        /// </para>
        ///
        /// <para>
        ///   The application can also call this constructor to read an existing zip
        ///   archive.  passing the name of a valid zip file that does exist. But, it's
        ///   better form to use the static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> method,
        ///   passing the name of the zip file, because using <c>ZipFile.Read()</c> in
        ///   your code communicates very clearly what you are doing.  In either case,
        ///   the file is then read into the <c>ZipFile</c> instance.  The app can then
        ///   enumerate the entries or can modify the zip file, for example adding
        ///   entries, removing entries, changing comments, and so on.
        /// </para>
        ///
        /// <para>
        ///   One advantage to this parameterized constructor: it allows applications to
        ///   use the same code to add items to a zip archive, regardless of whether the
        ///   zip file exists.
        /// </para>
        ///
        /// <para>
        ///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
        ///   not party on a single instance with multiple threads.  You may have
        ///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
        ///   can synchronize multi-thread access to a single instance.
        /// </para>
        ///
        /// <para>
        ///   By the way, since DotNetZip is so easy to use, don't you think <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
        ///   donate $5 or $10</see>?
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:Ionic.Zip.ZipException">
        /// Thrown if name refers to an existing file that is not a valid zip file.
        /// </exception>
        ///
        /// <example>
        /// This example shows how to create a zipfile, and add a few files into it.
        /// <code>
        /// String ZipFileToCreate = "archive1.zip";
        /// String DirectoryToZip  = "c:\\reports";
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///   // Store all files found in the top level directory, into the zip archive.
        ///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
        ///   zip.AddFiles(filenames, "files");
        ///   zip.Save(ZipFileToCreate);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim ZipFileToCreate As String = "archive1.zip"
        /// Dim DirectoryToZip As String = "c:\reports"
        /// Using zip As ZipFile = New ZipFile()
        ///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
        ///     zip.AddFiles(filenames, "files")
        ///     zip.Save(ZipFileToCreate)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="fileName">The filename to use for the new zip archive.</param>
        // Token: 0x060002A2 RID: 674 RVA: 0x00011184 File Offset: 0x0000F384
        public ZipFile(string fileName)
        {
            try
            {
                this._InitInstance(fileName, null);
            }
            catch (Exception e)
            {
                throw new ZipException(string.Format("Could not read {0} as a zip file", fileName), e);
            }
        }

        /// <summary>
        ///   Creates a new <c>ZipFile</c> instance, using the specified name for the
        ///   filename, and the specified Encoding.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
        ///   constructor that accepts a single string argument</see> for basic
        ///   information on all the <c>ZipFile</c> constructors.
        /// </para>
        ///
        /// <para>
        ///   The Encoding is used as the default alternate encoding for entries with
        ///   filenames or comments that cannot be encoded with the IBM437 code page.
        ///   This is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the <c>ZipFile</c>
        ///   instance after construction.
        /// </para>
        ///
        /// <para>
        ///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
        ///   not party on a single instance with multiple threads.  You may have
        ///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
        ///   can synchronize multi-thread access to a single instance.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:Ionic.Zip.ZipException">
        /// Thrown if name refers to an existing file that is not a valid zip file.
        /// </exception>
        ///
        /// <param name="fileName">The filename to use for the new zip archive.</param>
        /// <param name="encoding">The Encoding is used as the default alternate
        /// encoding for entries with filenames or comments that cannot be encoded
        /// with the IBM437 code page. </param>
        // Token: 0x060002A3 RID: 675 RVA: 0x00011238 File Offset: 0x0000F438
        public ZipFile(string fileName, Encoding encoding)
        {
            try
            {
                this.AlternateEncoding = encoding;
                this.AlternateEncodingUsage = ZipOption.Always;
                this._InitInstance(fileName, null);
            }
            catch (Exception e)
            {
                throw new ZipException(string.Format("{0} is not a valid zip file", fileName), e);
            }
        }

        /// <summary>
        ///   Create a zip file, without specifying a target filename or stream to save to.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
        ///   constructor that accepts a single string argument</see> for basic
        ///   information on all the <c>ZipFile</c> constructors.
        /// </para>
        ///
        /// <para>
        ///   After instantiating with this constructor and adding entries to the
        ///   archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> or
        ///   <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)" /> to save to a file or a
        ///   stream, respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name" />
        ///   property and then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method.  (This
        ///   is the preferred approach for applications that use the library through
        ///   COM interop.)  If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method
        ///   without having set the <c>Name</c> of the <c>ZipFile</c>, either through
        ///   the parameterized constructor or through the explicit property , the
        ///   Save() will throw, because there is no place to save the file.  </para>
        ///
        /// <para>
        ///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
        ///   have multiple threads that each use a distinct <c>ZipFile</c> instance, or
        ///   you can synchronize multi-thread access to a single instance.  </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// This example creates a Zip archive called Backup.zip, containing all the files
        /// in the directory DirectoryToZip. Files within subdirectories are not zipped up.
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///   // Store all files found in the top level directory, into the zip archive.
        ///   // note: this code does not recurse subdirectories!
        ///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
        ///   zip.AddFiles(filenames, "files");
        ///   zip.Save("Backup.zip");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile
        ///     ' Store all files found in the top level directory, into the zip archive.
        ///     ' note: this code does not recurse subdirectories!
        ///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
        ///     zip.AddFiles(filenames, "files")
        ///     zip.Save("Backup.zip")
        /// End Using
        /// </code>
        /// </example>
        // Token: 0x060002A4 RID: 676 RVA: 0x000112FC File Offset: 0x0000F4FC
        public ZipFile()
        {
            this._InitInstance(null, null);
        }

        /// <summary>
        ///   Create a zip file, specifying a text Encoding, but without specifying a
        ///   target filename or stream to save to.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
        ///   constructor that accepts a single string argument</see> for basic
        ///   information on all the <c>ZipFile</c> constructors.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="encoding">
        /// The Encoding is used as the default alternate encoding for entries with
        /// filenames or comments that cannot be encoded with the IBM437 code page.
        /// </param>
        // Token: 0x060002A5 RID: 677 RVA: 0x00011384 File Offset: 0x0000F584
        public ZipFile(Encoding encoding)
        {
            this.AlternateEncoding = encoding;
            this.AlternateEncodingUsage = ZipOption.Always;
            this._InitInstance(null, null);
        }

        /// <summary>
        ///   Creates a new <c>ZipFile</c> instance, using the specified name for the
        ///   filename, and the specified status message writer.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
        ///   constructor that accepts a single string argument</see> for basic
        ///   information on all the <c>ZipFile</c> constructors.
        /// </para>
        ///
        /// <para>
        ///   This version of the constructor allows the caller to pass in a TextWriter,
        ///   to which verbose messages will be written during extraction or creation of
        ///   the zip archive.  A console application may wish to pass
        ///   System.Console.Out to get messages on the Console. A graphical or headless
        ///   application may wish to capture the messages in a different
        ///   <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
        ///   the messages in a TextBox, or generate an audit log of ZipFile operations.
        /// </para>
        ///
        /// <para>
        ///   To encrypt the data for the files added to the <c>ZipFile</c> instance,
        ///   set the Password property after creating the <c>ZipFile</c> instance.
        /// </para>
        ///
        /// <para>
        ///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
        ///   not party on a single instance with multiple threads.  You may have
        ///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
        ///   can synchronize multi-thread access to a single instance.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:Ionic.Zip.ZipException">
        /// Thrown if name refers to an existing file that is not a valid zip file.
        /// </exception>
        ///
        /// <example>
        /// <code>
        /// using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
        /// {
        ///   // Store all files found in the top level directory, into the zip archive.
        ///   // note: this code does not recurse subdirectories!
        ///   // Status messages will be written to Console.Out
        ///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
        ///   zip.AddFiles(filenames);
        ///   zip.Save();
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile("Backup.zip", Console.Out)
        ///     ' Store all files found in the top level directory, into the zip archive.
        ///     ' note: this code does not recurse subdirectories!
        ///     ' Status messages will be written to Console.Out
        ///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
        ///     zip.AddFiles(filenames)
        ///     zip.Save()
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="fileName">The filename to use for the new zip archive.</param>
        /// <param name="statusMessageWriter">A TextWriter to use for writing
        /// verbose status messages.</param>
        // Token: 0x060002A6 RID: 678 RVA: 0x0001141C File Offset: 0x0000F61C
        public ZipFile(string fileName, TextWriter statusMessageWriter)
        {
            try
            {
                this._InitInstance(fileName, statusMessageWriter);
            }
            catch (Exception e)
            {
                throw new ZipException(string.Format("{0} is not a valid zip file", fileName), e);
            }
        }

        /// <summary>
        ///   Creates a new <c>ZipFile</c> instance, using the specified name for the
        ///   filename, the specified status message writer, and the specified Encoding.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
        ///   constructor that accepts a single string argument.</see> See that
        ///   reference for detail on what this constructor does.
        /// </para>
        ///
        /// <para>
        ///   This version of the constructor allows the caller to pass in a
        ///   <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
        ///   verbose messages that are generated by the library during extraction or
        ///   creation of the zip archive.  A console application may wish to pass
        ///   <c>System.Console.Out</c> to get messages on the Console. A graphical or
        ///   headless application may wish to capture the messages in a different
        ///   <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
        ///   the messages in a <c>TextBox</c>, or generate an audit log of
        ///   <c>ZipFile</c> operations.
        /// </para>
        ///
        /// <para>
        ///   The <c>Encoding</c> is used as the default alternate encoding for entries
        ///   with filenames or comments that cannot be encoded with the IBM437 code
        ///   page.  This is a equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the <c>ZipFile</c>
        ///   instance after construction.
        /// </para>
        ///
        /// <para>
        ///   To encrypt the data for the files added to the <c>ZipFile</c> instance,
        ///   set the <c>Password</c> property after creating the <c>ZipFile</c>
        ///   instance.
        /// </para>
        ///
        /// <para>
        ///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
        ///   not party on a single instance with multiple threads.  You may have
        ///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
        ///   can synchronize multi-thread access to a single instance.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:Ionic.Zip.ZipException">
        /// Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
        /// </exception>
        ///
        /// <param name="fileName">The filename to use for the new zip archive.</param>
        /// <param name="statusMessageWriter">A TextWriter to use for writing verbose
        /// status messages.</param>
        /// <param name="encoding">
        /// The Encoding is used as the default alternate encoding for entries with
        /// filenames or comments that cannot be encoded with the IBM437 code page.
        /// </param>
        // Token: 0x060002A7 RID: 679 RVA: 0x000114D0 File Offset: 0x0000F6D0
        public ZipFile(string fileName, TextWriter statusMessageWriter, Encoding encoding)
        {
            try
            {
                this.AlternateEncoding = encoding;
                this.AlternateEncodingUsage = ZipOption.Always;
                this._InitInstance(fileName, statusMessageWriter);
            }
            catch (Exception e)
            {
                throw new ZipException(string.Format("{0} is not a valid zip file", fileName), e);
            }
        }

        /// <summary>
        ///   Initialize a <c>ZipFile</c> instance by reading in a zip file.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This method is primarily useful from COM Automation environments, when
        ///   reading or extracting zip files. In COM, it is not possible to invoke
        ///   parameterized constructors for a class. A COM Automation application can
        ///   update a zip file by using the <see cref="M:Ionic.Zip.ZipFile.#ctor">default (no argument)
        ///   constructor</see>, then calling <c>Initialize()</c> to read the contents
        ///   of an on-disk zip archive into the <c>ZipFile</c> instance.
        /// </para>
        ///
        /// <para>
        ///   .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
        ///   for better clarity.
        /// </para>
        ///
        /// </remarks>
        /// <param name="fileName">the name of the existing zip file to read in.</param>
        // Token: 0x060002A8 RID: 680 RVA: 0x00011594 File Offset: 0x0000F794
        public void Initialize(string fileName)
        {
            try
            {
                this._InitInstance(fileName, null);
            }
            catch (Exception e)
            {
                throw new ZipException(string.Format("{0} is not a valid zip file", fileName), e);
            }
        }

        // Token: 0x060002A9 RID: 681 RVA: 0x000115D4 File Offset: 0x0000F7D4
        private void _initEntriesDictionary()
        {
            StringComparer sc = this.CaseSensitiveRetrieval ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;
            this._entries = ((this._entries == null) ? new Dictionary<string, ZipEntry>(sc) : new Dictionary<string, ZipEntry>(this._entries, sc));
        }

        // Token: 0x060002AA RID: 682 RVA: 0x0001161C File Offset: 0x0000F81C
        private void _InitInstance(string zipFileName, TextWriter statusMessageWriter)
        {
            this._name = zipFileName;
            this._StatusMessageTextWriter = statusMessageWriter;
            this._contentsChanged = true;
            this.AddDirectoryWillTraverseReparsePoints = true;
            this.CompressionLevel = CompressionLevel.Default;
            this.ParallelDeflateThreshold = 524288L;
            this._initEntriesDictionary();
            if (File.Exists(this._name))
            {
                if (this.FullScan)
                {
                    ZipFile.ReadIntoInstance_Orig(this);
                }
                else
                {
                    ZipFile.ReadIntoInstance(this);
                }
                this._fileAlreadyExists = true;
            }
        }

        // Token: 0x170000C3 RID: 195
        // (get) Token: 0x060002AB RID: 683 RVA: 0x000116A0 File Offset: 0x0000F8A0
        private List<ZipEntry> ZipEntriesAsList
        {
            get
            {
                if (this._zipEntriesAsList == null)
                {
                    this._zipEntriesAsList = new List<ZipEntry>(this._entries.Values);
                }
                return this._zipEntriesAsList;
            }
        }

        /// <summary>
        ///   This is an integer indexer into the Zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This property is read-only.
        /// </para>
        ///
        /// <para>
        ///   Internally, the <c>ZipEntry</c> instances that belong to the
        ///   <c>ZipFile</c> are stored in a Dictionary.  When you use this
        ///   indexer the first time, it creates a read-only
        ///   <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
        ///   If at any time you modify the set of entries in the <c>ZipFile</c>,
        ///   either by adding an entry, removing an entry, or renaming an
        ///   entry, a new List will be created, and the numeric indexes for the
        ///   remaining entries may be different.
        /// </para>
        ///
        /// <para>
        ///   This means you cannot rename any ZipEntry from
        ///   inside an enumeration of the zip file.
        /// </para>
        ///
        /// <param name="ix">
        ///   The index value.
        /// </param>
        ///
        /// </remarks>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> within the Zip archive at the specified index. If the
        ///   entry does not exist in the archive, this indexer throws.
        /// </returns>
        // Token: 0x170000C4 RID: 196
        public ZipEntry this[int ix]
        {
            get
            {
                return this.ZipEntriesAsList[ix];
            }
        }

        /// <summary>
        ///   This is a name-based indexer into the Zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This property is read-only.
        /// </para>
        ///
        /// <para>
        ///   The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property on the <c>ZipFile</c>
        ///   determines whether retrieval via this indexer is done via case-sensitive
        ///   comparisons. By default, retrieval is not case sensitive.  This makes
        ///   sense on Windows, in which filesystems are not case sensitive.
        /// </para>
        ///
        /// <para>
        ///   Regardless of case-sensitivity, it is not always the case that
        ///   <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
        ///   property of the <c>ZipEntry</c> retrieved with this indexer, may or may
        ///   not be equal to the index value.
        /// </para>
        ///
        /// <para>
        ///   This is because DotNetZip performs a normalization of filenames passed to
        ///   this indexer, before attempting to retrieve the item.  That normalization
        ///   includes: removal of a volume letter and colon, swapping backward slashes
        ///   for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
        ///   "dir1/entry.txt"</c>.
        /// </para>
        ///
        /// <para>
        ///   Directory entries in the zip file may be retrieved via this indexer only
        ///   with names that have a trailing slash. DotNetZip automatically appends a
        ///   trailing slash to the names of any directory entries added to a zip.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// This example extracts only the entries in a zip file that are .txt files.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
        /// {
        ///   foreach (string s1 in zip.EntryFilenames)
        ///   {
        ///     if (s1.EndsWith(".txt"))
        ///       zip[s1].Extract("textfiles");
        ///   }
        /// }
        /// </code>
        /// <code lang="VB">
        ///   Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
        ///       Dim s1 As String
        ///       For Each s1 In zip.EntryFilenames
        ///           If s1.EndsWith(".txt") Then
        ///               zip(s1).Extract("textfiles")
        ///           End If
        ///       Next
        ///   End Using
        /// </code>
        /// </example>
        /// <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
        ///
        /// <exception cref="T:System.ArgumentException">
        ///   Thrown if the caller attempts to assign a non-null value to the indexer.
        /// </exception>
        ///
        /// <param name="fileName">
        ///   The name of the file, including any directory path, to retrieve from the
        ///   zip.  The filename match is not case-sensitive by default; you can use the
        ///   <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to change this behavior. The
        ///   pathname can use forward-slashes or backward slashes.
        /// </param>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> within the Zip archive, given by the specified
        ///   filename. If the named entry does not exist in the archive, this indexer
        ///   returns <c>null</c> (<c>Nothing</c> in VB).
        /// </returns>
        // Token: 0x170000C5 RID: 197
        public ZipEntry this[string fileName]
        {
            get
            {
                string key = SharedUtilities.NormalizePathForUseInZipFile(fileName);
                ZipEntry result;
                if (this._entries.ContainsKey(key))
                {
                    result = this._entries[key];
                }
                else
                {
                    key = key.Replace("/", "\\");
                    if (this._entries.ContainsKey(key))
                    {
                        result = this._entries[key];
                    }
                    else
                    {
                        result = null;
                    }
                }
                return result;
            }
        }

        /// <summary>
        ///   The list of filenames for the entries contained within the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///   According to the ZIP specification, the names of the entries use forward
        ///   slashes in pathnames.  If you are scanning through the list, you may have
        ///   to swap forward slashes for backslashes.
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)" />
        ///
        /// <example>
        ///   This example shows one way to test if a filename is already contained
        ///   within a zip archive.
        /// <code>
        /// String zipFileToRead= "PackedDocuments.zip";
        /// string candidate = "DatedMaterial.xps";
        /// using (ZipFile zip = new ZipFile(zipFileToRead))
        /// {
        ///   if (zip.EntryFilenames.Contains(candidate))
        ///     Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
        ///                       candidate,
        ///                       zipFileName);
        ///   else
        ///     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
        ///                       candidate,
        ///                       zipFileName);
        ///   Console.WriteLine();
        /// }
        /// </code>
        /// <code lang="VB">
        ///   Dim zipFileToRead As String = "PackedDocuments.zip"
        ///   Dim candidate As String = "DatedMaterial.xps"
        ///   Using zip As ZipFile.Read(ZipFileToRead)
        ///       If zip.EntryFilenames.Contains(candidate) Then
        ///           Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
        ///                       candidate, _
        ///                       zipFileName)
        ///       Else
        ///         Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
        ///                       candidate, _
        ///                       zipFileName)
        ///       End If
        ///       Console.WriteLine
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <returns>
        ///   The list of strings for the filenames contained within the Zip archive.
        /// </returns>
        // Token: 0x170000C6 RID: 198
        // (get) Token: 0x060002AE RID: 686 RVA: 0x00011770 File Offset: 0x0000F970
        public ICollection<string> EntryFileNames
        {
            get
            {
                return this._entries.Keys;
            }
        }

        /// <summary>
        ///   Returns the readonly collection of entries in the Zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   If there are no entries in the current <c>ZipFile</c>, the value returned is a
        ///   non-null zero-element collection.  If there are entries in the zip file,
        ///   the elements are returned in no particular order.
        /// </para>
        /// <para>
        ///   This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
        ///   <c>ZipFile</c> instance in a context that expects an enumerator, you will
        ///   get this collection.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted" />
        // Token: 0x170000C7 RID: 199
        // (get) Token: 0x060002AF RID: 687 RVA: 0x00011790 File Offset: 0x0000F990
        public ICollection<ZipEntry> Entries
        {
            get
            {
                return this._entries.Values;
            }
        }

        /// <summary>
        ///   Returns a readonly collection of entries in the Zip archive, sorted by FileName.
        /// </summary>
        ///
        /// <remarks>
        ///   If there are no entries in the current <c>ZipFile</c>, the value returned
        ///   is a non-null zero-element collection.  If there are entries in the zip
        ///   file, the elements are returned sorted by the name of the entry.
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example fills a Windows Forms ListView with the entries in a zip file.
        ///
        /// <code lang="C#">
        /// using (ZipFile zip = ZipFile.Read(zipFile))
        /// {
        ///     foreach (ZipEntry entry in zip.EntriesSorted)
        ///     {
        ///         ListViewItem item = new ListViewItem(n.ToString());
        ///         n++;
        ///         string[] subitems = new string[] {
        ///             entry.FileName.Replace("/","\\"),
        ///             entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
        ///             entry.UncompressedSize.ToString(),
        ///             String.Format("{0,5:F0}%", entry.CompressionRatio),
        ///             entry.CompressedSize.ToString(),
        ///             (entry.UsesEncryption) ? "Y" : "N",
        ///             String.Format("{0:X8}", entry.Crc)};
        ///
        ///         foreach (String s in subitems)
        ///         {
        ///             ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
        ///             subitem.Text = s;
        ///             item.SubItems.Add(subitem);
        ///         }
        ///
        ///         this.listView1.Items.Add(item);
        ///     }
        /// }
        /// </code>
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.Entries" />
        // Token: 0x170000C8 RID: 200
        // (get) Token: 0x060002B0 RID: 688 RVA: 0x000117E4 File Offset: 0x0000F9E4
        public ICollection<ZipEntry> EntriesSorted
        {
            get
            {
                List<ZipEntry> coll = new List<ZipEntry>();
                foreach (ZipEntry e in this.Entries)
                {
                    coll.Add(e);
                }
                StringComparison sc = this.CaseSensitiveRetrieval ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;
                coll.Sort((ZipEntry x, ZipEntry y) => string.Compare(x.FileName, y.FileName, sc));
                return coll.AsReadOnly();
            }
        }

        /// <summary>
        /// Returns the number of entries in the Zip archive.
        /// </summary>
        // Token: 0x170000C9 RID: 201
        // (get) Token: 0x060002B1 RID: 689 RVA: 0x00011884 File Offset: 0x0000FA84
        public int Count
        {
            get
            {
                return this._entries.Count;
            }
        }

        /// <summary>
        ///   Removes the given <c>ZipEntry</c> from the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
        ///   make the changes permanent.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.ArgumentException">
        ///   Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
        /// </exception>
        ///
        /// <example>
        ///   In this example, all entries in the zip archive dating from before
        ///   December 31st, 2007, are removed from the archive.  This is actually much
        ///   easier if you use the RemoveSelectedEntries method.  But I needed an
        ///   example for RemoveEntry, so here it is.
        /// <code>
        /// String ZipFileToRead = "ArchiveToModify.zip";
        /// System.DateTime Threshold = new System.DateTime(2007,12,31);
        /// using (ZipFile zip = ZipFile.Read(ZipFileToRead))
        /// {
        ///   var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
        ///   foreach (ZipEntry e in zip)
        ///   {
        ///     if (e.LastModified &lt; Threshold)
        ///     {
        ///       // We cannot remove the entry from the list, within the context of
        ///       // an enumeration of said list.
        ///       // So we add the doomed entry to a list to be removed later.
        ///       EntriesToRemove.Add(e);
        ///     }
        ///   }
        ///
        ///   // actually remove the doomed entries.
        ///   foreach (ZipEntry zombie in EntriesToRemove)
        ///     zip.RemoveEntry(zombie);
        ///
        ///   zip.Comment= String.Format("This zip archive was updated at {0}.",
        ///                              System.DateTime.Now.ToString("G"));
        ///
        ///   // save with a different name
        ///   zip.Save("Archive-Updated.zip");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        ///   Dim ZipFileToRead As String = "ArchiveToModify.zip"
        ///   Dim Threshold As New DateTime(2007, 12, 31)
        ///   Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
        ///       Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
        ///       Dim e As ZipEntry
        ///       For Each e In zip
        ///           If (e.LastModified &lt; Threshold) Then
        ///               ' We cannot remove the entry from the list, within the context of
        ///               ' an enumeration of said list.
        ///               ' So we add the doomed entry to a list to be removed later.
        ///               EntriesToRemove.Add(e)
        ///           End If
        ///       Next
        ///
        ///       ' actually remove the doomed entries.
        ///       Dim zombie As ZipEntry
        ///       For Each zombie In EntriesToRemove
        ///           zip.RemoveEntry(zombie)
        ///       Next
        ///       zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
        ///       'save as a different name
        ///       zip.Save("Archive-Updated.zip")
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <param name="entry">
        /// The <c>ZipEntry</c> to remove from the zip.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        // Token: 0x060002B2 RID: 690 RVA: 0x000118A4 File Offset: 0x0000FAA4
        public void RemoveEntry(ZipEntry entry)
        {
            if (entry == null)
            {
                throw new ArgumentNullException("entry");
            }
            this._entries.Remove(SharedUtilities.NormalizePathForUseInZipFile(entry.FileName));
            this._zipEntriesAsList = null;
            this._contentsChanged = true;
        }

        /// <summary>
        /// Removes the <c>ZipEntry</c> with the given filename from the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
        ///   make the changes permanent.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:System.InvalidOperationException">
        ///   Thrown if the <c>ZipFile</c> is not updatable.
        /// </exception>
        ///
        /// <exception cref="T:System.ArgumentException">
        ///   Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
        ///   the <c>ZipFile</c>.
        /// </exception>
        ///
        /// <example>
        ///
        ///   This example shows one way to remove an entry with a given filename from
        ///   an existing zip archive.
        ///
        /// <code>
        /// String zipFileToRead= "PackedDocuments.zip";
        /// string candidate = "DatedMaterial.xps";
        /// using (ZipFile zip = ZipFile.Read(zipFileToRead))
        /// {
        ///   if (zip.EntryFilenames.Contains(candidate))
        ///   {
        ///     zip.RemoveEntry(candidate);
        ///     zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
        ///                                Candidate);
        ///     zip.Save();
        ///   }
        /// }
        /// </code>
        /// <code lang="VB">
        ///   Dim zipFileToRead As String = "PackedDocuments.zip"
        ///   Dim candidate As String = "DatedMaterial.xps"
        ///   Using zip As ZipFile = ZipFile.Read(zipFileToRead)
        ///       If zip.EntryFilenames.Contains(candidate) Then
        ///           zip.RemoveEntry(candidate)
        ///           zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
        ///           zip.Save
        ///       End If
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <param name="fileName">
        /// The name of the file, including any directory path, to remove from the zip.
        /// The filename match is not case-sensitive by default; you can use the
        /// <c>CaseSensitiveRetrieval</c> property to change this behavior. The
        /// pathname can use forward-slashes or backward slashes.
        /// </param>
        // Token: 0x060002B3 RID: 691 RVA: 0x000118F0 File Offset: 0x0000FAF0
        public void RemoveEntry(string fileName)
        {
            string modifiedName = ZipEntry.NameInArchive(fileName, null);
            ZipEntry e = this[modifiedName];
            if (e == null)
            {
                throw new ArgumentException("The entry you specified was not found in the zip archive.");
            }
            this.RemoveEntry(e);
        }

        /// <summary>
        ///   Closes the read and write streams associated
        ///   to the <c>ZipFile</c>, if necessary.
        /// </summary>
        ///
        /// <remarks>
        ///   The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
        ///   statement. (<c>Using...End Using</c> in VB) If you do not employ a using
        ///   statement, insure that your application calls Dispose() explicitly.  For
        ///   example, in a Powershell application, or an application that uses the COM
        ///   interop interface, you must call Dispose() explicitly.
        /// </remarks>
        ///
        /// <example>
        /// This example extracts an entry selected by name, from the Zip file to the
        /// Console.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipfile))
        /// {
        ///   foreach (ZipEntry e in zip)
        ///   {
        ///     if (WantThisEntry(e.FileName))
        ///       zip.Extract(e.FileName, Console.OpenStandardOutput());
        ///   }
        /// } // Dispose() is called implicitly here.
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(zipfile)
        ///     Dim e As ZipEntry
        ///     For Each e In zip
        ///       If WantThisEntry(e.FileName) Then
        ///           zip.Extract(e.FileName, Console.OpenStandardOutput())
        ///       End If
        ///     Next
        /// End Using ' Dispose is implicity called here
        /// </code>
        /// </example>
        // Token: 0x060002B4 RID: 692 RVA: 0x0001192C File Offset: 0x0000FB2C
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        ///   Disposes any managed resources, if the flag is set, then marks the
        ///   instance disposed.  This method is typically not called explicitly from
        ///   application code.
        /// </summary>
        ///
        /// <remarks>
        ///   Applications should call <see cref="M:Ionic.Zip.ZipFile.Dispose">the no-arg Dispose method</see>.
        /// </remarks>
        ///
        /// <param name="disposeManagedResources">
        ///   indicates whether the method should dispose streams or not.
        /// </param>
        // Token: 0x060002B5 RID: 693 RVA: 0x00011940 File Offset: 0x0000FB40
        protected virtual void Dispose(bool disposeManagedResources)
        {
            if (!this._disposed)
            {
                if (disposeManagedResources)
                {
                    if (this._ReadStreamIsOurs)
                    {
                        if (this._readstream != null)
                        {
                            this._readstream.Dispose();
                            this._readstream = null;
                        }
                    }
                    if (this._temporaryFileName != null && this._name != null && this._writestream != null)
                    {
                        this._writestream.Dispose();
                        this._writestream = null;
                    }
                    if (this.ParallelDeflater != null)
                    {
                        this.ParallelDeflater.Dispose();
                        this.ParallelDeflater = null;
                    }
                }
                this._disposed = true;
            }
        }

        // Token: 0x170000CA RID: 202
        // (get) Token: 0x060002B6 RID: 694 RVA: 0x00011A00 File Offset: 0x0000FC00
        internal Stream ReadStream
        {
            get
            {
                if (this._readstream == null)
                {
                    if (this._readName != null || this._name != null)
                    {
                        this._readstream = File.Open(this._readName ?? this._name, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                        this._ReadStreamIsOurs = true;
                    }
                }
                return this._readstream;
            }
        }

        // Token: 0x170000CB RID: 203
        // (get) Token: 0x060002B7 RID: 695 RVA: 0x00011A6C File Offset: 0x0000FC6C
        // (set) Token: 0x060002B8 RID: 696 RVA: 0x00011B08 File Offset: 0x0000FD08
        private Stream WriteStream
        {
            get
            {
                Stream writestream;
                if (this._writestream != null)
                {
                    writestream = this._writestream;
                }
                else if (this._name == null)
                {
                    writestream = this._writestream;
                }
                else if (this._maxOutputSegmentSize != 0)
                {
                    this._writestream = ZipSegmentedStream.ForWriting(this._name, this._maxOutputSegmentSize);
                    writestream = this._writestream;
                }
                else
                {
                    SharedUtilities.CreateAndOpenUniqueTempFile(this.TempFileFolder ?? Path.GetDirectoryName(this._name), out this._writestream, out this._temporaryFileName);
                    writestream = this._writestream;
                }
                return writestream;
            }
            set
            {
                if (value != null)
                {
                    throw new ZipException("Cannot set the stream to a non-null value.");
                }
                this._writestream = null;
            }
        }

        // Token: 0x170000CC RID: 204
        // (get) Token: 0x060002B9 RID: 697 RVA: 0x00011B30 File Offset: 0x0000FD30
        private string ArchiveNameForEvent
        {
            get
            {
                return (this._name != null) ? this._name : "(stream)";
            }
        }

        /// <summary>
        ///   An event handler invoked when a Save() starts, before and after each
        ///   entry has been written to the archive, when a Save() completes, and
        ///   during other Save events.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.SaveProgressEventArgs" /> parameter are set.  The following
        ///   table summarizes the available EventTypes and the conditions under
        ///   which this event handler is invoked with a
        ///   <c>SaveProgressEventArgs</c> with the given EventType.
        /// </para>
        ///
        /// <list type="table">
        /// <listheader>
        /// <term>value of EntryType</term>
        /// <description>Meaning and conditions</description>
        /// </listheader>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_Started</term>
        /// <description>Fired when ZipFile.Save() begins.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
        /// <description>
        ///   Fired within ZipFile.Save(), just before writing data for each
        ///   particular entry.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
        /// <description>
        ///   Fired within ZipFile.Save(), just after having finished writing data
        ///   for each particular entry.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_Completed</term>
        /// <description>Fired when ZipFile.Save() has completed.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
        /// <description>
        ///   Fired after the temporary file has been created.  This happens only
        ///   when saving to a disk file.  This event will not be invoked when
        ///   saving to a stream.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
        /// <description>
        ///   Fired just before renaming the temporary file to the permanent
        ///   location.  This happens only when saving to a disk file.  This event
        ///   will not be invoked when saving to a stream.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
        /// <description>
        ///   Fired just after renaming the temporary file to the permanent
        ///   location.  This happens only when saving to a disk file.  This event
        ///   will not be invoked when saving to a stream.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
        /// <description>
        ///   Fired after a self-extracting archive has finished compiling.  This
        ///   EventType is used only within SaveSelfExtractor().
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Saving_BytesRead</term>
        /// <description>
        ///   Set during the save of a particular entry, to update progress of the
        ///   Save().  When this EventType is set, the BytesTransferred is the
        ///   number of bytes that have been read from the source stream.  The
        ///   TotalBytesToTransfer is the number of bytes in the uncompressed
        ///   file.
        /// </description>
        /// </item>
        ///
        /// </list>
        /// </remarks>
        ///
        /// <example>
        ///
        ///    This example uses an anonymous method to handle the
        ///    SaveProgress event, by updating a progress bar.
        ///
        /// <code lang="C#">
        /// progressBar1.Value = 0;
        /// progressBar1.Max = listbox1.Items.Count;
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///    // listbox1 contains a list of filenames
        ///    zip.AddFiles(listbox1.Items);
        ///
        ///    // do the progress bar:
        ///    zip.SaveProgress += (sender, e) =&gt; {
        ///       if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
        ///          progressBar1.PerformStep();
        ///       }
        ///    };
        ///
        ///    zip.Save(fs);
        /// }
        /// </code>
        /// </example>
        ///
        /// <example>
        ///   This example uses a named method as the
        ///   <c>SaveProgress</c> event handler, to update the user, in a
        ///   console-based application.
        ///
        /// <code lang="C#">
        /// static bool justHadByteUpdate= false;
        /// public static void SaveProgress(object sender, SaveProgressEventArgs e)
        /// {
        ///     if (e.EventType == ZipProgressEventType.Saving_Started)
        ///         Console.WriteLine("Saving: {0}", e.ArchiveName);
        ///
        ///     else if (e.EventType == ZipProgressEventType.Saving_Completed)
        ///     {
        ///         justHadByteUpdate= false;
        ///         Console.WriteLine();
        ///         Console.WriteLine("Done: {0}", e.ArchiveName);
        ///     }
        ///
        ///     else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
        ///     {
        ///         if (justHadByteUpdate)
        ///             Console.WriteLine();
        ///         Console.WriteLine("  Writing: {0} ({1}/{2})",
        ///                           e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
        ///         justHadByteUpdate= false;
        ///     }
        ///
        ///     else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
        ///     {
        ///         if (justHadByteUpdate)
        ///             Console.SetCursorPosition(0, Console.CursorTop);
        ///          Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
        ///                       e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
        ///         justHadByteUpdate= true;
        ///     }
        /// }
        ///
        /// public static ZipUp(string targetZip, string directory)
        /// {
        ///   using (var zip = new ZipFile()) {
        ///     zip.SaveProgress += SaveProgress;
        ///     zip.AddDirectory(directory);
        ///     zip.Save(targetZip);
        ///   }
        /// }
        ///
        /// </code>
        ///
        /// <code lang="VB">
        /// Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
        ///     Using zip As ZipFile = New ZipFile
        ///         AddHandler zip.SaveProgress, AddressOf MySaveProgress
        ///         zip.AddDirectory(directory)
        ///         zip.Save(targetZip)
        ///     End Using
        /// End Sub
        ///
        /// Private Shared justHadByteUpdate As Boolean = False
        ///
        /// Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
        ///     If (e.EventType Is ZipProgressEventType.Saving_Started) Then
        ///         Console.WriteLine("Saving: {0}", e.ArchiveName)
        ///
        ///     ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
        ///         justHadByteUpdate = False
        ///         Console.WriteLine
        ///         Console.WriteLine("Done: {0}", e.ArchiveName)
        ///
        ///     ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
        ///         If justHadByteUpdate Then
        ///             Console.WriteLine
        ///         End If
        ///         Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
        ///         justHadByteUpdate = False
        ///
        ///     ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
        ///         If justHadByteUpdate Then
        ///             Console.SetCursorPosition(0, Console.CursorTop)
        ///         End If
        ///         Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
        ///                       e.TotalBytesToTransfer, _
        ///                       (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
        ///         justHadByteUpdate = True
        ///     End If
        /// End Sub
        /// </code>
        /// </example>
        ///
        /// <example>
        ///
        /// This is a more complete example of using the SaveProgress
        /// events in a Windows Forms application, with a
        /// Thread object.
        ///
        /// <code lang="C#">
        /// delegate void SaveEntryProgress(SaveProgressEventArgs e);
        /// delegate void ButtonClick(object sender, EventArgs e);
        ///
        /// public class WorkerOptions
        /// {
        ///     public string ZipName;
        ///     public string Folder;
        ///     public string Encoding;
        ///     public string Comment;
        ///     public int ZipFlavor;
        ///     public Zip64Option Zip64;
        /// }
        ///
        /// private int _progress2MaxFactor;
        /// private bool _saveCanceled;
        /// private long _totalBytesBeforeCompress;
        /// private long _totalBytesAfterCompress;
        /// private Thread _workerThread;
        ///
        ///
        /// private void btnZipup_Click(object sender, EventArgs e)
        /// {
        ///     KickoffZipup();
        /// }
        ///
        /// private void btnCancel_Click(object sender, EventArgs e)
        /// {
        ///     if (this.lblStatus.InvokeRequired)
        ///     {
        ///         this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
        ///     }
        ///     else
        ///     {
        ///         _saveCanceled = true;
        ///         lblStatus.Text = "Canceled...";
        ///         ResetState();
        ///     }
        /// }
        ///
        /// private void KickoffZipup()
        /// {
        ///     _folderName = tbDirName.Text;
        ///
        ///     if (_folderName == null || _folderName == "") return;
        ///     if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
        ///
        ///     // check for existence of the zip file:
        ///     if (System.IO.File.Exists(this.tbZipName.Text))
        ///     {
        ///         var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
        ///                                                       "  Do you want to overwrite this file?", this.tbZipName.Text),
        ///                                         "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
        ///         if (dlgResult != DialogResult.Yes) return;
        ///         System.IO.File.Delete(this.tbZipName.Text);
        ///     }
        ///
        ///      _saveCanceled = false;
        ///     _nFilesCompleted = 0;
        ///     _totalBytesAfterCompress = 0;
        ///     _totalBytesBeforeCompress = 0;
        ///     this.btnOk.Enabled = false;
        ///     this.btnOk.Text = "Zipping...";
        ///     this.btnCancel.Enabled = true;
        ///     lblStatus.Text = "Zipping...";
        ///
        ///     var options = new WorkerOptions
        ///     {
        ///         ZipName = this.tbZipName.Text,
        ///         Folder = _folderName,
        ///         Encoding = "ibm437"
        ///     };
        ///
        ///     if (this.comboBox1.SelectedIndex != 0)
        ///     {
        ///         options.Encoding = this.comboBox1.SelectedItem.ToString();
        ///     }
        ///
        ///     if (this.radioFlavorSfxCmd.Checked)
        ///         options.ZipFlavor = 2;
        ///     else if (this.radioFlavorSfxGui.Checked)
        ///         options.ZipFlavor = 1;
        ///     else options.ZipFlavor = 0;
        ///
        ///     if (this.radioZip64AsNecessary.Checked)
        ///         options.Zip64 = Zip64Option.AsNecessary;
        ///     else if (this.radioZip64Always.Checked)
        ///         options.Zip64 = Zip64Option.Always;
        ///     else options.Zip64 = Zip64Option.Never;
        ///
        ///     options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
        ///                 options.Encoding,
        ///                 FlavorToString(options.ZipFlavor),
        ///                 options.Zip64.ToString(),
        ///                 System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
        ///                 this.Text);
        ///
        ///     if (this.tbComment.Text != TB_COMMENT_NOTE)
        ///         options.Comment += this.tbComment.Text;
        ///
        ///     _workerThread = new Thread(this.DoSave);
        ///     _workerThread.Name = "Zip Saver thread";
        ///     _workerThread.Start(options);
        ///     this.Cursor = Cursors.WaitCursor;
        ///  }
        ///
        ///
        /// private void DoSave(Object p)
        /// {
        ///     WorkerOptions options = p as WorkerOptions;
        ///     try
        ///     {
        ///         using (var zip1 = new ZipFile())
        ///         {
        ///             zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
        ///             zip1.Comment = options.Comment;
        ///             zip1.AddDirectory(options.Folder);
        ///             _entriesToZip = zip1.EntryFileNames.Count;
        ///             SetProgressBars();
        ///             zip1.SaveProgress += this.zip1_SaveProgress;
        ///
        ///             zip1.UseZip64WhenSaving = options.Zip64;
        ///
        ///             if (options.ZipFlavor == 1)
        ///                 zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
        ///             else if (options.ZipFlavor == 2)
        ///                 zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
        ///             else
        ///                 zip1.Save(options.ZipName);
        ///         }
        ///     }
        ///     catch (System.Exception exc1)
        ///     {
        ///         MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
        ///         btnCancel_Click(null, null);
        ///     }
        /// }
        ///
        ///
        ///
        /// void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
        /// {
        ///     switch (e.EventType)
        ///     {
        ///         case ZipProgressEventType.Saving_AfterWriteEntry:
        ///             StepArchiveProgress(e);
        ///             break;
        ///         case ZipProgressEventType.Saving_EntryBytesRead:
        ///             StepEntryProgress(e);
        ///             break;
        ///         case ZipProgressEventType.Saving_Completed:
        ///             SaveCompleted();
        ///             break;
        ///         case ZipProgressEventType.Saving_AfterSaveTempArchive:
        ///             // this event only occurs when saving an SFX file
        ///             TempArchiveSaved();
        ///             break;
        ///     }
        ///     if (_saveCanceled)
        ///         e.Cancel = true;
        /// }
        ///
        ///
        ///
        /// private void StepArchiveProgress(SaveProgressEventArgs e)
        /// {
        ///     if (this.progressBar1.InvokeRequired)
        ///     {
        ///         this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
        ///     }
        ///     else
        ///     {
        ///         if (!_saveCanceled)
        ///         {
        ///             _nFilesCompleted++;
        ///             this.progressBar1.PerformStep();
        ///             _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
        ///             _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
        ///
        ///             // reset the progress bar for the entry:
        ///             this.progressBar2.Value = this.progressBar2.Maximum = 1;
        ///
        ///             this.Update();
        ///         }
        ///     }
        /// }
        ///
        ///
        /// private void StepEntryProgress(SaveProgressEventArgs e)
        /// {
        ///     if (this.progressBar2.InvokeRequired)
        ///     {
        ///         this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
        ///     }
        ///     else
        ///     {
        ///         if (!_saveCanceled)
        ///         {
        ///             if (this.progressBar2.Maximum == 1)
        ///             {
        ///                 // reset
        ///                 Int64 max = e.TotalBytesToTransfer;
        ///                 _progress2MaxFactor = 0;
        ///                 while (max &gt; System.Int32.MaxValue)
        ///                 {
        ///                     max /= 2;
        ///                     _progress2MaxFactor++;
        ///                 }
        ///                 this.progressBar2.Maximum = (int)max;
        ///                 lblStatus.Text = String.Format("{0} of {1} files...({2})",
        ///                     _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
        ///             }
        ///
        ///              int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
        ///
        ///              this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
        ///                 ? this.progressBar2.Maximum
        ///                 : xferred;
        ///
        ///              this.Update();
        ///         }
        ///     }
        /// }
        ///
        /// private void SaveCompleted()
        /// {
        ///     if (this.lblStatus.InvokeRequired)
        ///     {
        ///         this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
        ///     }
        ///     else
        ///     {
        ///         lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
        ///             _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
        ///          ResetState();
        ///     }
        /// }
        ///
        /// private void ResetState()
        /// {
        ///     this.btnCancel.Enabled = false;
        ///     this.btnOk.Enabled = true;
        ///     this.btnOk.Text = "Zip it!";
        ///     this.progressBar1.Value = 0;
        ///     this.progressBar2.Value = 0;
        ///     this.Cursor = Cursors.Default;
        ///     if (!_workerThread.IsAlive)
        ///         _workerThread.Join();
        /// }
        /// </code>
        ///
        /// </example>
        ///
        /// <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        // Token: 0x14000001 RID: 1
        // (add) Token: 0x060002BA RID: 698 RVA: 0x00011B58 File Offset: 0x0000FD58
        // (remove) Token: 0x060002BB RID: 699 RVA: 0x00011B94 File Offset: 0x0000FD94
        public event EventHandler<SaveProgressEventArgs> SaveProgress;

        // Token: 0x060002BC RID: 700 RVA: 0x00011BD0 File Offset: 0x0000FDD0
        internal bool OnSaveBlock(ZipEntry entry, long bytesXferred, long totalBytesToXfer)
        {
            EventHandler<SaveProgressEventArgs> sp = this.SaveProgress;
            if (sp != null)
            {
                SaveProgressEventArgs e = SaveProgressEventArgs.ByteUpdate(this.ArchiveNameForEvent, entry, bytesXferred, totalBytesToXfer);
                sp(this, e);
                if (e.Cancel)
                {
                    this._saveOperationCanceled = true;
                }
            }
            return this._saveOperationCanceled;
        }

        // Token: 0x060002BD RID: 701 RVA: 0x00011C28 File Offset: 0x0000FE28
        private void OnSaveEntry(int current, ZipEntry entry, bool before)
        {
            EventHandler<SaveProgressEventArgs> sp = this.SaveProgress;
            if (sp != null)
            {
                SaveProgressEventArgs e = new SaveProgressEventArgs(this.ArchiveNameForEvent, before, this._entries.Count, current, entry);
                sp(this, e);
                if (e.Cancel)
                {
                    this._saveOperationCanceled = true;
                }
            }
        }

        // Token: 0x060002BE RID: 702 RVA: 0x00011C80 File Offset: 0x0000FE80
        private void OnSaveEvent(ZipProgressEventType eventFlavor)
        {
            EventHandler<SaveProgressEventArgs> sp = this.SaveProgress;
            if (sp != null)
            {
                SaveProgressEventArgs e = new SaveProgressEventArgs(this.ArchiveNameForEvent, eventFlavor);
                sp(this, e);
                if (e.Cancel)
                {
                    this._saveOperationCanceled = true;
                }
            }
        }

        // Token: 0x060002BF RID: 703 RVA: 0x00011CCC File Offset: 0x0000FECC
        private void OnSaveStarted()
        {
            EventHandler<SaveProgressEventArgs> sp = this.SaveProgress;
            if (sp != null)
            {
                SaveProgressEventArgs e = SaveProgressEventArgs.Started(this.ArchiveNameForEvent);
                sp(this, e);
                if (e.Cancel)
                {
                    this._saveOperationCanceled = true;
                }
            }
        }

        // Token: 0x060002C0 RID: 704 RVA: 0x00011D14 File Offset: 0x0000FF14
        private void OnSaveCompleted()
        {
            EventHandler<SaveProgressEventArgs> sp = this.SaveProgress;
            if (sp != null)
            {
                SaveProgressEventArgs e = SaveProgressEventArgs.Completed(this.ArchiveNameForEvent);
                sp(this, e);
            }
        }

        /// <summary>
        /// An event handler invoked before, during, and after the reading of a zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// Depending on the particular event being signaled, different properties on the
        /// <see cref="T:Ionic.Zip.ReadProgressEventArgs" /> parameter are set.  The following table
        /// summarizes the available EventTypes and the conditions under which this
        /// event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
        /// </para>
        ///
        /// <list type="table">
        /// <listheader>
        /// <term>value of EntryType</term>
        /// <description>Meaning and conditions</description>
        /// </listheader>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Reading_Started</term>
        /// <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Reading_Completed</term>
        /// <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
        /// <description>Fired while reading, updates the number of bytes read for the entire archive.
        /// Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
        /// <description>Indicates an entry is about to be read from the archive.
        /// Meaningful properties: ArchiveName, EntriesTotal.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Reading_AfterReadEntry</term>
        /// <description>Indicates an entry has just been read from the archive.
        /// Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
        /// </description>
        /// </item>
        ///
        /// </list>
        /// </remarks>
        ///
        /// <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        // Token: 0x14000002 RID: 2
        // (add) Token: 0x060002C1 RID: 705 RVA: 0x00011D48 File Offset: 0x0000FF48
        // (remove) Token: 0x060002C2 RID: 706 RVA: 0x00011D84 File Offset: 0x0000FF84
        public event EventHandler<ReadProgressEventArgs> ReadProgress;

        // Token: 0x060002C3 RID: 707 RVA: 0x00011DC0 File Offset: 0x0000FFC0
        private void OnReadStarted()
        {
            EventHandler<ReadProgressEventArgs> rp = this.ReadProgress;
            if (rp != null)
            {
                ReadProgressEventArgs e = ReadProgressEventArgs.Started(this.ArchiveNameForEvent);
                rp(this, e);
            }
        }

        // Token: 0x060002C4 RID: 708 RVA: 0x00011DF4 File Offset: 0x0000FFF4
        private void OnReadCompleted()
        {
            EventHandler<ReadProgressEventArgs> rp = this.ReadProgress;
            if (rp != null)
            {
                ReadProgressEventArgs e = ReadProgressEventArgs.Completed(this.ArchiveNameForEvent);
                rp(this, e);
            }
        }

        // Token: 0x060002C5 RID: 709 RVA: 0x00011E28 File Offset: 0x00010028
        internal void OnReadBytes(ZipEntry entry)
        {
            EventHandler<ReadProgressEventArgs> rp = this.ReadProgress;
            if (rp != null)
            {
                ReadProgressEventArgs e = ReadProgressEventArgs.ByteUpdate(this.ArchiveNameForEvent, entry, this.ReadStream.Position, this.LengthOfReadStream);
                rp(this, e);
            }
        }

        // Token: 0x060002C6 RID: 710 RVA: 0x00011E70 File Offset: 0x00010070
        internal void OnReadEntry(bool before, ZipEntry entry)
        {
            EventHandler<ReadProgressEventArgs> rp = this.ReadProgress;
            if (rp != null)
            {
                ReadProgressEventArgs e = before ? ReadProgressEventArgs.Before(this.ArchiveNameForEvent, this._entries.Count) : ReadProgressEventArgs.After(this.ArchiveNameForEvent, entry, this._entries.Count);
                rp(this, e);
            }
        }

        // Token: 0x170000CD RID: 205
        // (get) Token: 0x060002C7 RID: 711 RVA: 0x00011ECC File Offset: 0x000100CC
        private long LengthOfReadStream
        {
            get
            {
                if (this._lengthOfReadStream == -99L)
                {
                    this._lengthOfReadStream = (this._ReadStreamIsOurs ? SharedUtilities.GetFileLength(this._name) : -1L);
                }
                return this._lengthOfReadStream;
            }
        }

        /// <summary>
        ///   An event handler invoked before, during, and after extraction of
        ///   entries in the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.ExtractProgressEventArgs" /> parameter are set.  The following
        ///   table summarizes the available EventTypes and the conditions under
        ///   which this event handler is invoked with a
        ///   <c>ExtractProgressEventArgs</c> with the given EventType.
        /// </para>
        ///
        /// <list type="table">
        /// <listheader>
        /// <term>value of EntryType</term>
        /// <description>Meaning and conditions</description>
        /// </listheader>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
        /// <description>
        ///   Set when ExtractAll() begins. The ArchiveName, Overwrite, and
        ///   ExtractLocation properties are meaningful.</description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
        /// <description>
        ///   Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
        ///   and ExtractLocation properties are meaningful.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
        /// <description>
        ///   Set when an Extract() on an entry in the ZipFile has begun.
        ///   Properties that are meaningful: ArchiveName, EntriesTotal,
        ///   CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
        /// <description>
        ///   Set when an Extract() on an entry in the ZipFile has completed.
        ///   Properties that are meaningful: ArchiveName, EntriesTotal,
        ///   CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
        /// <description>
        ///   Set within a call to Extract() on an entry in the ZipFile, as data
        ///   is extracted for the entry.  Properties that are meaningful:
        ///   ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
        /// </description>
        /// </item>
        ///
        /// <item>
        /// <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
        /// <description>
        ///   Set within a call to Extract() on an entry in the ZipFile, when the
        ///   extraction would overwrite an existing file. This event type is used
        ///   only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
        ///   <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
        /// </description>
        /// </item>
        ///
        /// </list>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <code>
        /// private static bool justHadByteUpdate = false;
        /// public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
        /// {
        ///   if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
        ///   {
        ///     if (justHadByteUpdate)
        ///       Console.SetCursorPosition(0, Console.CursorTop);
        ///
        ///     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
        ///                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
        ///     justHadByteUpdate = true;
        ///   }
        ///   else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
        ///   {
        ///     if (justHadByteUpdate)
        ///       Console.WriteLine();
        ///     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
        ///     justHadByteUpdate= false;
        ///   }
        /// }
        ///
        /// public static ExtractZip(string zipToExtract, string directory)
        /// {
        ///   string TargetDirectory= "extract";
        ///   using (var zip = ZipFile.Read(zipToExtract)) {
        ///     zip.ExtractProgress += ExtractProgress;
        ///     foreach (var e in zip1)
        ///     {
        ///       e.Extract(TargetDirectory, true);
        ///     }
        ///   }
        /// }
        ///
        /// </code>
        /// <code lang="VB">
        /// Public Shared Sub Main(ByVal args As String())
        ///     Dim ZipToUnpack As String = "C1P3SML.zip"
        ///     Dim TargetDir As String = "ExtractTest_Extract"
        ///     Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
        ///     Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
        ///         AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
        ///         Dim e As ZipEntry
        ///         For Each e In zip1
        ///             e.Extract(TargetDir, True)
        ///         Next
        ///     End Using
        /// End Sub
        ///
        /// Private Shared justHadByteUpdate As Boolean = False
        ///
        /// Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
        ///     If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
        ///         If ExtractTest.justHadByteUpdate Then
        ///             Console.SetCursorPosition(0, Console.CursorTop)
        ///         End If
        ///         Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
        ///         ExtractTest.justHadByteUpdate = True
        ///     ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
        ///         If ExtractTest.justHadByteUpdate Then
        ///             Console.WriteLine
        ///         End If
        ///         Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
        ///         ExtractTest.justHadByteUpdate = False
        ///     End If
        /// End Sub
        /// </code>
        /// </example>
        ///
        /// <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
        // Token: 0x14000003 RID: 3
        // (add) Token: 0x060002C8 RID: 712 RVA: 0x00011F18 File Offset: 0x00010118
        // (remove) Token: 0x060002C9 RID: 713 RVA: 0x00011F54 File Offset: 0x00010154
        public event EventHandler<ExtractProgressEventArgs> ExtractProgress;

        // Token: 0x060002CA RID: 714 RVA: 0x00011F90 File Offset: 0x00010190
        private void OnExtractEntry(int current, bool before, ZipEntry currentEntry, string path)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = new ExtractProgressEventArgs(this.ArchiveNameForEvent, before, this._entries.Count, current, currentEntry, path);
                ep(this, e);
                if (e.Cancel)
                {
                    this._extractOperationCanceled = true;
                }
            }
        }

        // Token: 0x060002CB RID: 715 RVA: 0x00011FE8 File Offset: 0x000101E8
        internal bool OnExtractBlock(ZipEntry entry, long bytesWritten, long totalBytesToWrite)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = ExtractProgressEventArgs.ByteUpdate(this.ArchiveNameForEvent, entry, bytesWritten, totalBytesToWrite);
                ep(this, e);
                if (e.Cancel)
                {
                    this._extractOperationCanceled = true;
                }
            }
            return this._extractOperationCanceled;
        }

        // Token: 0x060002CC RID: 716 RVA: 0x00012040 File Offset: 0x00010240
        internal bool OnSingleEntryExtract(ZipEntry entry, string path, bool before)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = before ? ExtractProgressEventArgs.BeforeExtractEntry(this.ArchiveNameForEvent, entry, path) : ExtractProgressEventArgs.AfterExtractEntry(this.ArchiveNameForEvent, entry, path);
                ep(this, e);
                if (e.Cancel)
                {
                    this._extractOperationCanceled = true;
                }
            }
            return this._extractOperationCanceled;
        }

        // Token: 0x060002CD RID: 717 RVA: 0x000120A8 File Offset: 0x000102A8
        internal bool OnExtractExisting(ZipEntry entry, string path)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = ExtractProgressEventArgs.ExtractExisting(this.ArchiveNameForEvent, entry, path);
                ep(this, e);
                if (e.Cancel)
                {
                    this._extractOperationCanceled = true;
                }
            }
            return this._extractOperationCanceled;
        }

        // Token: 0x060002CE RID: 718 RVA: 0x000120FC File Offset: 0x000102FC
        private void OnExtractAllCompleted(string path)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = ExtractProgressEventArgs.ExtractAllCompleted(this.ArchiveNameForEvent, path);
                ep(this, e);
            }
        }

        // Token: 0x060002CF RID: 719 RVA: 0x00012134 File Offset: 0x00010334
        private void OnExtractAllStarted(string path)
        {
            EventHandler<ExtractProgressEventArgs> ep = this.ExtractProgress;
            if (ep != null)
            {
                ExtractProgressEventArgs e = ExtractProgressEventArgs.ExtractAllStarted(this.ArchiveNameForEvent, path);
                ep(this, e);
            }
        }

        /// <summary>
        /// An event handler invoked before, during, and after Adding entries to a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///     Adding a large number of entries to a zip file can take a long
        ///     time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" /> on a
        ///     directory that contains 50,000 files, it could take 3 minutes or so.
        ///     This event handler allws an application to track the progress of the Add
        ///     operation, and to optionally cancel a lengthy Add operation.
        /// </remarks>
        ///
        /// <example>
        /// <code lang="C#">
        ///
        /// int _numEntriesToAdd= 0;
        /// int _numEntriesAdded= 0;
        /// void AddProgressHandler(object sender, AddProgressEventArgs e)
        /// {
        ///     switch (e.EventType)
        ///     {
        ///         case ZipProgressEventType.Adding_Started:
        ///             Console.WriteLine("Adding files to the zip...");
        ///             break;
        ///         case ZipProgressEventType.Adding_AfterAddEntry:
        ///             _numEntriesAdded++;
        ///             Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
        ///                                      _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
        ///             break;
        ///         case ZipProgressEventType.Adding_Completed:
        ///             Console.WriteLine("Added all files");
        ///             break;
        ///     }
        /// }
        ///
        /// void CreateTheZip()
        /// {
        ///     using (ZipFile zip = new ZipFile())
        ///     {
        ///         zip.AddProgress += AddProgressHandler;
        ///         zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
        ///         zip.Save(ZipFileToCreate);
        ///     }
        /// }
        ///
        /// </code>
        ///
        /// <code lang="VB">
        ///
        /// Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
        ///     Select Case e.EventType
        ///         Case ZipProgressEventType.Adding_Started
        ///             Console.WriteLine("Adding files to the zip...")
        ///             Exit Select
        ///         Case ZipProgressEventType.Adding_AfterAddEntry
        ///             Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
        ///             Exit Select
        ///         Case ZipProgressEventType.Adding_Completed
        ///             Console.WriteLine("Added all files")
        ///             Exit Select
        ///     End Select
        /// End Sub
        ///
        /// Sub CreateTheZip()
        ///     Using zip as ZipFile = New ZipFile
        ///         AddHandler zip.AddProgress, AddressOf AddProgressHandler
        ///         zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
        ///         zip.Save(ZipFileToCreate);
        ///     End Using
        /// End Sub
        ///
        /// </code>
        ///
        /// </example>
        ///
        /// <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
        /// <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        // Token: 0x14000004 RID: 4
        // (add) Token: 0x060002D0 RID: 720 RVA: 0x0001216C File Offset: 0x0001036C
        // (remove) Token: 0x060002D1 RID: 721 RVA: 0x000121A8 File Offset: 0x000103A8
        public event EventHandler<AddProgressEventArgs> AddProgress;

        // Token: 0x060002D2 RID: 722 RVA: 0x000121E4 File Offset: 0x000103E4
        private void OnAddStarted()
        {
            EventHandler<AddProgressEventArgs> ap = this.AddProgress;
            if (ap != null)
            {
                AddProgressEventArgs e = AddProgressEventArgs.Started(this.ArchiveNameForEvent);
                ap(this, e);
                if (e.Cancel)
                {
                    this._addOperationCanceled = true;
                }
            }
        }

        // Token: 0x060002D3 RID: 723 RVA: 0x0001222C File Offset: 0x0001042C
        private void OnAddCompleted()
        {
            EventHandler<AddProgressEventArgs> ap = this.AddProgress;
            if (ap != null)
            {
                AddProgressEventArgs e = AddProgressEventArgs.Completed(this.ArchiveNameForEvent);
                ap(this, e);
            }
        }

        // Token: 0x060002D4 RID: 724 RVA: 0x00012260 File Offset: 0x00010460
        internal void AfterAddEntry(ZipEntry entry)
        {
            EventHandler<AddProgressEventArgs> ap = this.AddProgress;
            if (ap != null)
            {
                AddProgressEventArgs e = AddProgressEventArgs.AfterEntry(this.ArchiveNameForEvent, entry, this._entries.Count);
                ap(this, e);
                if (e.Cancel)
                {
                    this._addOperationCanceled = true;
                }
            }
        }

        /// <summary>
        /// An event that is raised when an error occurs during open or read of files
        /// while saving a zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///     Errors can occur as a file is being saved to the zip archive.  For
        ///     example, the File.Open may fail, or a File.Read may fail, because of
        ///     lock conflicts or other reasons.  If you add a handler to this event,
        ///     you can handle such errors in your own code.  If you don't add a
        ///     handler, the library will throw an exception if it encounters an I/O
        ///     error during a call to <c>Save()</c>.
        ///  </para>
        ///
        ///  <para>
        ///    Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" /> to
        ///    <c>ZipErrorAction.InvokeErrorEvent</c>.
        ///  </para>
        ///
        ///  <para>
        ///    The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry" /> items that are
        ///    subsequently added to the <c>ZipFile</c> instance. If you set this
        ///    property after you have added items to the <c>ZipFile</c>, but before you
        ///    have called <c>Save()</c>, errors that occur while saving those items
        ///    will not cause the error handler to be invoked.
        ///  </para>
        ///
        ///  <para>
        ///    If you want to handle any errors that occur with any entry in the zip
        ///    file using the same error handler, then add your error handler once,
        ///    before adding any entries to the zip archive.
        ///  </para>
        ///
        ///  <para>
        ///    In the error handler method, you need to set the <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" /> property on the
        ///    <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
        ///    DotNetZip what you would like to do with this particular error.  Within
        ///    an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
        ///    on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
        ///    you don't set it at all, the library will throw the exception. (It is the
        ///    same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
        ///    <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
        ///    <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
        ///    canceled.
        ///  </para>
        ///
        ///  <para>
        ///    In the case that you use <c>ZipErrorAction.Skip</c>, implying that
        ///    you want to skip the entry for which there's been an error, DotNetZip
        ///    tries to seek backwards in the output stream, and truncate all bytes
        ///    written on behalf of that particular entry. This works only if the
        ///    output stream is seekable.  It will not work, for example, when using
        ///    ASPNET's Response.OutputStream.
        ///  </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        /// This example shows how to use an event handler to handle
        /// errors during save of the zip file.
        /// <code lang="C#">
        ///
        /// public static void MyZipError(object sender, ZipErrorEventArgs e)
        /// {
        ///     Console.WriteLine("Error saving {0}...", e.FileName);
        ///     Console.WriteLine("   Exception: {0}", e.exception);
        ///     ZipEntry entry = e.CurrentEntry;
        ///     string response = null;
        ///     // Ask the user whether he wants to skip this error or not
        ///     do
        ///     {
        ///         Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
        ///         response = Console.ReadLine();
        ///         Console.WriteLine();
        ///
        ///     } while (response != null &amp;&amp;
        ///              response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
        ///              response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
        ///              response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
        ///              response[0]!='C' &amp;&amp; response[0]!='c');
        ///
        ///     e.Cancel = (response[0]=='C' || response[0]=='c');
        ///
        ///     if (response[0]=='S' || response[0]=='s')
        ///         entry.ZipErrorAction = ZipErrorAction.Skip;
        ///     else if (response[0]=='R' || response[0]=='r')
        ///         entry.ZipErrorAction = ZipErrorAction.Retry;
        ///     else if (response[0]=='T' || response[0]=='t')
        ///         entry.ZipErrorAction = ZipErrorAction.Throw;
        /// }
        ///
        /// public void SaveTheFile()
        /// {
        ///   string directoryToZip = "fodder";
        ///   string directoryInArchive = "files";
        ///   string zipFileToCreate = "Archive.zip";
        ///   using (var zip = new ZipFile())
        ///   {
        ///     // set the event handler before adding any entries
        ///     zip.ZipError += MyZipError;
        ///     zip.AddDirectory(directoryToZip, directoryInArchive);
        ///     zip.Save(zipFileToCreate);
        ///   }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
        ///     ' At this point, the application could prompt the user for an action to take.
        ///     ' But in this case, this application will simply automatically skip the file, in case of error.
        ///     Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
        ///     Console.WriteLine("   Exception: {0}", e.exception)
        ///     ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
        ///     e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
        /// End Sub
        ///
        /// Public Sub SaveTheFile()
        ///     Dim directoryToZip As String = "fodder"
        ///     Dim directoryInArchive As String = "files"
        ///     Dim zipFileToCreate as String = "Archive.zip"
        ///     Using zipArchive As ZipFile = New ZipFile
        ///         ' set the event handler before adding any entries
        ///         AddHandler zipArchive.ZipError, AddressOf MyZipError
        ///         zipArchive.AddDirectory(directoryToZip, directoryInArchive)
        ///         zipArchive.Save(zipFileToCreate)
        ///     End Using
        /// End Sub
        ///
        /// </code>
        /// </example>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />
        // Token: 0x14000005 RID: 5
        // (add) Token: 0x060002D5 RID: 725 RVA: 0x000122B4 File Offset: 0x000104B4
        // (remove) Token: 0x060002D6 RID: 726 RVA: 0x000122F0 File Offset: 0x000104F0
        public event EventHandler<ZipErrorEventArgs> ZipError;

        // Token: 0x060002D7 RID: 727 RVA: 0x0001232C File Offset: 0x0001052C
        internal bool OnZipErrorSaving(ZipEntry entry, Exception exc)
        {
            if (this.ZipError != null)
            {
                lock (this.LOCK)
                {
                    ZipErrorEventArgs e = ZipErrorEventArgs.Saving(this.Name, entry, exc);
                    this.ZipError(this, e);
                    if (e.Cancel)
                    {
                        this._saveOperationCanceled = true;
                    }
                }
            }
            return this._saveOperationCanceled;
        }

        /// <summary>
        /// Extracts all of the items in the zip archive, to the specified path in the
        /// filesystem.  The path can be relative or fully-qualified.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method will extract all entries in the <c>ZipFile</c> to the
        ///   specified path.
        /// </para>
        ///
        /// <para>
        ///   If an extraction of a file from the zip archive would overwrite an
        ///   existing file in the filesystem, the action taken is dictated by the
        ///   ExtractExistingFile property, which overrides any setting you may have
        ///   made on individual ZipEntry instances.  By default, if you have not
        ///   set that property on the <c>ZipFile</c> instance, the entry will not
        ///   be extracted, the existing file will not be overwritten and an
        ///   exception will be thrown. To change this, set the property, or use the
        ///   <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)" /> overload that allows you to
        ///   specify an ExtractExistingFileAction parameter.
        /// </para>
        ///
        /// <para>
        ///   The action to take when an extract would overwrite an existing file
        ///   applies to all entries.  If you want to set this on a per-entry basis,
        ///   then you must use one of the <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract</see> methods.
        /// </para>
        ///
        /// <para>
        ///   This method will send verbose output messages to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" />, if it is set on the <c>ZipFile</c>
        ///   instance.
        /// </para>
        ///
        /// <para>
        /// You may wish to take advantage of the <c>ExtractProgress</c> event.
        /// </para>
        ///
        /// <para>
        ///   About timestamps: When extracting a file entry from a zip archive, the
        ///   extracted file gets the last modified time of the entry as stored in
        ///   the archive. The archive may also store extended file timestamp
        ///   information, including last accessed and created times. If these are
        ///   present in the <c>ZipEntry</c>, then the extracted file will also get
        ///   these times.
        /// </para>
        ///
        /// <para>
        ///   A Directory entry is somewhat different. It will get the times as
        ///   described for a file entry, but, if there are file entries in the zip
        ///   archive that, when extracted, appear in the just-created directory,
        ///   then when those file entries are extracted, the last modified and last
        ///   accessed times of the directory will change, as a side effect.  The
        ///   result is that after an extraction of a directory and a number of
        ///   files within the directory, the last modified and last accessed
        ///   timestamps on the directory will reflect the time that the last file
        ///   was extracted into the directory, rather than the time stored in the
        ///   zip archive for the directory.
        /// </para>
        ///
        /// <para>
        ///   To compensate, when extracting an archive with <c>ExtractAll</c>,
        ///   DotNetZip will extract all the file and directory entries as described
        ///   above, but it will then make a second pass on the directories, and
        ///   reset the times on the directories to reflect what is stored in the
        ///   zip archive.
        /// </para>
        ///
        /// <para>
        ///   This compensation is performed only within the context of an
        ///   <c>ExtractAll</c>. If you call <c>ZipEntry.Extract</c> on a directory
        ///   entry, the timestamps on directory in the filesystem will reflect the
        ///   times stored in the zip.  If you then call <c>ZipEntry.Extract</c> on
        ///   a file entry, which is extracted into the directory, the timestamps on
        ///   the directory will be updated to the current time.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///   This example extracts all the entries in a zip archive file, to the
        ///   specified target directory.  The extraction will overwrite any
        ///   existing files silently.
        ///
        /// <code>
        /// String TargetDirectory= "unpack";
        /// using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
        /// {
        ///     zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
        ///     zip.ExtractAll(TargetDirectory);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim TargetDirectory As String = "unpack"
        /// Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
        ///     zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
        ///     zip.ExtractAll(TargetDirectory)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        /// <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
        ///
        /// <param name="path">
        ///   The path to which the contents of the zipfile will be extracted.
        ///   The path can be relative or fully-qualified.
        /// </param>
        // Token: 0x060002D8 RID: 728 RVA: 0x000123B0 File Offset: 0x000105B0
        public void ExtractAll(string path)
        {
            this._InternalExtractAll(path, true);
        }

        /// <summary>
        /// Extracts all of the items in the zip archive, to the specified path in the
        /// filesystem, using the specified behavior when extraction would overwrite an
        /// existing file.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        /// This method will extract all entries in the <c>ZipFile</c> to the specified
        /// path.  For an extraction that would overwrite an existing file, the behavior
        /// is dictated by <paramref name="extractExistingFile" />, which overrides any
        /// setting you may have made on individual ZipEntry instances.
        /// </para>
        ///
        /// <para>
        /// The action to take when an extract would overwrite an existing file
        /// applies to all entries.  If you want to set this on a per-entry basis,
        /// then you must use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" /> or one of the similar methods.
        /// </para>
        ///
        /// <para>
        /// Calling this method is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" /> property and then calling <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String)" />.
        /// </para>
        ///
        /// <para>
        /// This method will send verbose output messages to the
        /// <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" />, if it is set on the <c>ZipFile</c> instance.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example extracts all the entries in a zip archive file, to the
        /// specified target directory.  It does not overwrite any existing files.
        /// <code>
        /// String TargetDirectory= "c:\\unpack";
        /// using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
        /// {
        ///   zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim TargetDirectory As String = "c:\unpack"
        /// Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
        ///     zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="path">
        /// The path to which the contents of the zipfile will be extracted.
        /// The path can be relative or fully-qualified.
        /// </param>
        ///
        /// <param name="extractExistingFile">
        /// The action to take if extraction would overwrite an existing file.
        /// </param>
        /// <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
        // Token: 0x060002D9 RID: 729 RVA: 0x000123BC File Offset: 0x000105BC
        public void ExtractAll(string path, ExtractExistingFileAction extractExistingFile)
        {
            this.ExtractExistingFile = extractExistingFile;
            this._InternalExtractAll(path, true);
        }

        // Token: 0x060002DA RID: 730 RVA: 0x000123D0 File Offset: 0x000105D0
        private void _InternalExtractAll(string path, bool overrideExtractExistingProperty)
        {
            bool header = this.Verbose;
            this._inExtractAll = true;
            try
            {
                this.OnExtractAllStarted(path);
                int i = 0;
                foreach (ZipEntry e in this._entries.Values)
                {
                    if (header)
                    {
                        this.StatusMessageTextWriter.WriteLine("\n{1,-22} {2,-8} {3,4}   {4,-8}  {0}", new object[]
                        {
                            "Name",
                            "Modified",
                            "Size",
                            "Ratio",
                            "Packed"
                        });
                        this.StatusMessageTextWriter.WriteLine(new string('-', 72));
                        header = false;
                    }
                    if (this.Verbose)
                    {
                        this.StatusMessageTextWriter.WriteLine("{1,-22} {2,-8} {3,4:F0}%   {4,-8} {0}", new object[]
                        {
                            e.FileName,
                            e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                            e.UncompressedSize,
                            e.CompressionRatio,
                            e.CompressedSize
                        });
                        if (!string.IsNullOrEmpty(e.Comment))
                        {
                            this.StatusMessageTextWriter.WriteLine("  Comment: {0}", e.Comment);
                        }
                    }
                    e.Password = this._Password;
                    this.OnExtractEntry(i, true, e, path);
                    if (overrideExtractExistingProperty)
                    {
                        e.ExtractExistingFile = this.ExtractExistingFile;
                    }
                    e.Extract(path);
                    i++;
                    this.OnExtractEntry(i, false, e, path);
                    if (this._extractOperationCanceled)
                    {
                        break;
                    }
                }
                if (!this._extractOperationCanceled)
                {
                    foreach (ZipEntry e in this._entries.Values)
                    {
                        if (e.IsDirectory || e.FileName.EndsWith("/"))
                        {
                            string outputFile = e.FileName.StartsWith("/") ? Path.Combine(path, e.FileName.Substring(1)) : Path.Combine(path, e.FileName);
                            e._SetTimes(outputFile, false);
                        }
                    }
                    this.OnExtractAllCompleted(path);
                }
            }
            finally
            {
                this._inExtractAll = false;
            }
        }

        /// <summary>
        /// Reads a zip file archive and returns the instance.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The stream is read using the default <c>System.Text.Encoding</c>, which is the
        /// <c>IBM437</c> codepage.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.Exception">
        /// Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
        /// relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
        /// including specific exceptions if a file is not found, an unauthorized access
        /// exception, exceptions for poorly formatted filenames, and so on.
        /// </exception>
        ///
        /// <param name="fileName">
        /// The name of the zip archive to open.  This can be a fully-qualified or relative
        /// pathname.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />.
        ///
        /// <returns>The instance read from the zip archive.</returns>
        // Token: 0x060002DB RID: 731 RVA: 0x000126B8 File Offset: 0x000108B8
        public static ZipFile Read(string fileName)
        {
            return ZipFile.Read(fileName, null, null, null);
        }

        /// <summary>
        ///   Reads a zip file archive from the named filesystem file using the
        ///   specified options.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This version of the <c>Read()</c> method allows the caller to pass
        ///   in a <c>TextWriter</c> an <c>Encoding</c>, via an instance of the
        ///   <c>ReadOptions</c> class.  The <c>ZipFile</c> is read in using the
        ///   specified encoding for entries where UTF-8 encoding is not
        ///   explicitly specified.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///
        /// <para>
        ///   This example shows how to read a zip file using the Big-5 Chinese
        ///   code page (950), and extract each entry in the zip file, while
        ///   sending status messages out to the Console.
        /// </para>
        ///
        /// <para>
        ///   For this code to work as intended, the zipfile must have been
        ///   created using the big5 code page (CP950). This is typical, for
        ///   example, when using WinRar on a machine with CP950 set as the
        ///   default code page.  In that case, the names of entries within the
        ///   Zip archive will be stored in that code page, and reading the zip
        ///   archive must be done using that code page.  If the application did
        ///   not use the correct code page in ZipFile.Read(), then names of
        ///   entries within the zip archive would not be correctly retrieved.
        /// </para>
        ///
        /// <code lang="C#">
        /// string zipToExtract = "MyArchive.zip";
        /// string extractDirectory = "extract";
        /// var options = new ReadOptions
        /// {
        ///   StatusMessageWriter = System.Console.Out,
        ///   Encoding = System.Text.Encoding.GetEncoding(950)
        /// };
        /// using (ZipFile zip = ZipFile.Read(zipToExtract, options))
        /// {
        ///   foreach (ZipEntry e in zip)
        ///   {
        ///      e.Extract(extractDirectory);
        ///   }
        /// }
        /// </code>
        ///
        ///
        /// <code lang="VB">
        /// Dim zipToExtract as String = "MyArchive.zip"
        /// Dim extractDirectory as String = "extract"
        /// Dim options as New ReadOptions
        /// options.Encoding = System.Text.Encoding.GetEncoding(950)
        /// options.StatusMessageWriter = System.Console.Out
        /// Using zip As ZipFile = ZipFile.Read(zipToExtract, options)
        ///     Dim e As ZipEntry
        ///     For Each e In zip
        ///      e.Extract(extractDirectory)
        ///     Next
        /// End Using
        /// </code>
        /// </example>
        ///
        ///
        /// <example>
        ///
        /// <para>
        ///   This example shows how to read a zip file using the default
        ///   code page, to remove entries that have a modified date before a given threshold,
        ///   sending status messages out to a <c>StringWriter</c>.
        /// </para>
        ///
        /// <code lang="C#">
        /// var options = new ReadOptions
        /// {
        ///   StatusMessageWriter = new System.IO.StringWriter()
        /// };
        /// using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", options))
        /// {
        ///   var Threshold = new DateTime(2007,7,4);
        ///   // We cannot remove the entry from the list, within the context of
        ///   // an enumeration of said list.
        ///   // So we add the doomed entry to a list to be removed later.
        ///   // pass 1: mark the entries for removal
        ///   var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
        ///   foreach (ZipEntry e in zip)
        ///   {
        ///     if (e.LastModified &lt; Threshold)
        ///       MarkedEntries.Add(e);
        ///   }
        ///   // pass 2: actually remove the entry.
        ///   foreach (ZipEntry zombie in MarkedEntries)
        ///      zip.RemoveEntry(zombie);
        ///   zip.Comment = "This archive has been updated.";
        ///   zip.Save();
        /// }
        /// // can now use contents of sw, eg store in an audit log
        /// </code>
        ///
        /// <code lang="VB">
        /// Dim options as New ReadOptions
        /// options.StatusMessageWriter = New System.IO.StringWriter
        /// Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", options)
        ///     Dim Threshold As New DateTime(2007, 7, 4)
        ///     ' We cannot remove the entry from the list, within the context of
        ///     ' an enumeration of said list.
        ///     ' So we add the doomed entry to a list to be removed later.
        ///     ' pass 1: mark the entries for removal
        ///     Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
        ///     Dim e As ZipEntry
        ///     For Each e In zip
        ///         If (e.LastModified &lt; Threshold) Then
        ///             MarkedEntries.Add(e)
        ///         End If
        ///     Next
        ///     ' pass 2: actually remove the entry.
        ///     Dim zombie As ZipEntry
        ///     For Each zombie In MarkedEntries
        ///         zip.RemoveEntry(zombie)
        ///     Next
        ///     zip.Comment = "This archive has been updated."
        ///     zip.Save
        /// End Using
        /// ' can now use contents of sw, eg store in an audit log
        /// </code>
        /// </example>
        ///
        /// <exception cref="T:System.Exception">
        ///   Thrown if the zipfile cannot be read. The implementation of
        ///   this method relies on <c>System.IO.File.OpenRead</c>, which
        ///   can throw a variety of exceptions, including specific
        ///   exceptions if a file is not found, an unauthorized access
        ///   exception, exceptions for poorly formatted filenames, and so
        ///   on.
        /// </exception>
        ///
        /// <param name="fileName">
        /// The name of the zip archive to open.
        /// This can be a fully-qualified or relative pathname.
        /// </param>
        ///
        /// <param name="options">
        /// The set of options to use when reading the zip file.
        /// </param>
        ///
        /// <returns>The ZipFile instance read from the zip archive.</returns>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)" />
        // Token: 0x060002DC RID: 732 RVA: 0x000126D4 File Offset: 0x000108D4
        public static ZipFile Read(string fileName, ReadOptions options)
        {
            if (options == null)
            {
                throw new ArgumentNullException("options");
            }
            return ZipFile.Read(fileName, options.StatusMessageWriter, options.Encoding, options.ReadProgress);
        }

        /// <summary>
        /// Reads a zip file archive using the specified text encoding,  the specified
        /// TextWriter for status messages, and the specified ReadProgress event handler,
        /// and returns the instance.
        /// </summary>
        ///
        /// <param name="fileName">
        /// The name of the zip archive to open.
        /// This can be a fully-qualified or relative pathname.
        /// </param>
        ///
        /// <param name="readProgress">
        /// An event handler for Read operations.
        /// </param>
        ///
        /// <param name="statusMessageWriter">
        /// The <c>System.IO.TextWriter</c> to use for writing verbose status messages
        /// during operations on the zip archive.  A console application may wish to
        /// pass <c>System.Console.Out</c> to get messages on the Console. A graphical
        /// or headless application may wish to capture the messages in a different
        /// <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
        /// </param>
        ///
        /// <param name="encoding">
        /// The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
        /// careful specifying the encoding.  If the value you use here is not the same
        /// as the Encoding used when the zip archive was created (possibly by a
        /// different archiver) you will get unexpected results and possibly exceptions.
        /// </param>
        ///
        /// <returns>The instance read from the zip archive.</returns>
        // Token: 0x060002DD RID: 733 RVA: 0x00012714 File Offset: 0x00010914
        private static ZipFile Read(string fileName, TextWriter statusMessageWriter, Encoding encoding, EventHandler<ReadProgressEventArgs> readProgress)
        {
            ZipFile zf = new ZipFile();
            zf.AlternateEncoding = (encoding ?? ZipFile.DefaultEncoding);
            zf.AlternateEncodingUsage = ZipOption.Always;
            zf._StatusMessageTextWriter = statusMessageWriter;
            zf._name = fileName;
            if (readProgress != null)
            {
                zf.ReadProgress = readProgress;
            }
            if (zf.Verbose)
            {
                zf._StatusMessageTextWriter.WriteLine("reading from {0}...", fileName);
            }
            ZipFile.ReadIntoInstance(zf);
            zf._fileAlreadyExists = true;
            return zf;
        }

        /// <summary>
        ///   Reads a zip archive from a stream.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When reading from a file, it's probably easier to just use
        ///   <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
        ///   overload is useful when when the zip archive content is
        ///   available from an already-open stream. The stream must be
        ///   open and readable and seekable when calling this method.  The
        ///   stream is left open when the reading is completed.
        /// </para>
        ///
        /// <para>
        ///   Using this overload, the stream is read using the default
        ///   <c>System.Text.Encoding</c>, which is the <c>IBM437</c>
        ///   codepage. If you want to specify the encoding to use when
        ///   reading the zipfile content, see
        ///   <see cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">ZipFile.Read(Stream, ReadOptions)</see>.  This
        /// </para>
        ///
        /// <para>
        ///   Reading of zip content begins at the current position in the
        ///   stream.  This means if you have a stream that concatenates
        ///   regular data and zip data, if you position the open, readable
        ///   stream at the start of the zip data, you will be able to read
        ///   the zip archive using this constructor, or any of the ZipFile
        ///   constructors that accept a <see cref="T:System.IO.Stream" /> as
        ///   input. Some examples of where this might be useful: the zip
        ///   content is concatenated at the end of a regular EXE file, as
        ///   some self-extracting archives do.  (Note: SFX files produced
        ///   by DotNetZip do not work this way; they can be read as normal
        ///   ZIP files). Another example might be a stream being read from
        ///   a database, where the zip content is embedded within an
        ///   aggregate stream of data.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <para>
        ///   This example shows how to Read zip content from a stream, and
        ///   extract one entry into a different stream. In this example,
        ///   the filename "NameOfEntryInArchive.doc", refers only to the
        ///   name of the entry within the zip archive.  A file by that
        ///   name is not created in the filesystem.  The I/O is done
        ///   strictly with the given streams.
        /// </para>
        ///
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(InputStream))
        /// {
        ///    zip.Extract("NameOfEntryInArchive.doc", OutputStream);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip as ZipFile = ZipFile.Read(InputStream)
        ///    zip.Extract("NameOfEntryInArchive.doc", OutputStream)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="zipStream">the stream containing the zip data.</param>
        ///
        /// <returns>The ZipFile instance read from the stream</returns>
        // Token: 0x060002DE RID: 734 RVA: 0x00012790 File Offset: 0x00010990
        public static ZipFile Read(Stream zipStream)
        {
            return ZipFile.Read(zipStream, null, null, null);
        }

        /// <summary>
        ///   Reads a zip file archive from the given stream using the
        ///   specified options.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When reading from a file, it's probably easier to just use
        ///   <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
        ///   overload is useful when when the zip archive content is
        ///   available from an already-open stream. The stream must be
        ///   open and readable and seekable when calling this method.  The
        ///   stream is left open when the reading is completed.
        /// </para>
        ///
        /// <para>
        ///   Reading of zip content begins at the current position in the
        ///   stream.  This means if you have a stream that concatenates
        ///   regular data and zip data, if you position the open, readable
        ///   stream at the start of the zip data, you will be able to read
        ///   the zip archive using this constructor, or any of the ZipFile
        ///   constructors that accept a <see cref="T:System.IO.Stream" /> as
        ///   input. Some examples of where this might be useful: the zip
        ///   content is concatenated at the end of a regular EXE file, as
        ///   some self-extracting archives do.  (Note: SFX files produced
        ///   by DotNetZip do not work this way; they can be read as normal
        ///   ZIP files). Another example might be a stream being read from
        ///   a database, where the zip content is embedded within an
        ///   aggregate stream of data.
        /// </para>
        /// </remarks>
        ///
        /// <param name="zipStream">the stream containing the zip data.</param>
        ///
        /// <param name="options">
        ///   The set of options to use when reading the zip file.
        /// </param>
        ///
        /// <exception cref="T:System.Exception">
        ///   Thrown if the zip archive cannot be read.
        /// </exception>
        ///
        /// <returns>The ZipFile instance read from the stream.</returns>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />
        // Token: 0x060002DF RID: 735 RVA: 0x000127AC File Offset: 0x000109AC
        public static ZipFile Read(Stream zipStream, ReadOptions options)
        {
            if (options == null)
            {
                throw new ArgumentNullException("options");
            }
            return ZipFile.Read(zipStream, options.StatusMessageWriter, options.Encoding, options.ReadProgress);
        }

        /// <summary>
        /// Reads a zip archive from a stream, using the specified text Encoding, the
        /// specified TextWriter for status messages,
        /// and the specified ReadProgress event handler.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// Reading of zip content begins at the current position in the stream.  This
        /// means if you have a stream that concatenates regular data and zip data, if
        /// you position the open, readable stream at the start of the zip data, you
        /// will be able to read the zip archive using this constructor, or any of the
        /// ZipFile constructors that accept a <see cref="T:System.IO.Stream" /> as
        /// input. Some examples of where this might be useful: the zip content is
        /// concatenated at the end of a regular EXE file, as some self-extracting
        /// archives do.  (Note: SFX files produced by DotNetZip do not work this
        /// way). Another example might be a stream being read from a database, where
        /// the zip content is embedded within an aggregate stream of data.
        /// </para>
        /// </remarks>
        ///
        /// <param name="zipStream">the stream containing the zip data.</param>
        ///
        /// <param name="statusMessageWriter">
        /// The <c>System.IO.TextWriter</c> to which verbose status messages are written
        /// during operations on the <c>ZipFile</c>.  For example, in a console
        /// application, System.Console.Out works, and will get a message for each entry
        /// added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
        /// are written.
        /// </param>
        ///
        /// <param name="encoding">
        /// The text encoding to use when reading entries that do not have the UTF-8
        /// encoding bit set.  Be careful specifying the encoding.  If the value you use
        /// here is not the same as the Encoding used when the zip archive was created
        /// (possibly by a different archiver) you will get unexpected results and
        /// possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        /// property for more information.
        /// </param>
        ///
        /// <param name="readProgress">
        /// An event handler for Read operations.
        /// </param>
        ///
        /// <returns>an instance of ZipFile</returns>
        // Token: 0x060002E0 RID: 736 RVA: 0x000127EC File Offset: 0x000109EC
        private static ZipFile Read(Stream zipStream, TextWriter statusMessageWriter, Encoding encoding, EventHandler<ReadProgressEventArgs> readProgress)
        {
            if (zipStream == null)
            {
                throw new ArgumentNullException("zipStream");
            }
            ZipFile zf = new ZipFile();
            zf._StatusMessageTextWriter = statusMessageWriter;
            zf._alternateEncoding = (encoding ?? ZipFile.DefaultEncoding);
            zf._alternateEncodingUsage = ZipOption.Always;
            if (readProgress != null)
            {
                zf.ReadProgress += readProgress;
            }
            zf._readstream = ((zipStream.Position == 0L) ? zipStream : new OffsetStream(zipStream));
            zf._ReadStreamIsOurs = false;
            if (zf.Verbose)
            {
                zf._StatusMessageTextWriter.WriteLine("reading from stream...");
            }
            ZipFile.ReadIntoInstance(zf);
            return zf;
        }

        // Token: 0x060002E1 RID: 737 RVA: 0x00012890 File Offset: 0x00010A90
        private static void ReadIntoInstance(ZipFile zf)
        {
            Stream s = zf.ReadStream;
            try
            {
                zf._readName = zf._name;
                if (!s.CanSeek)
                {
                    ZipFile.ReadIntoInstance_Orig(zf);
                    return;
                }
                zf.OnReadStarted();
                uint datum = ZipFile.ReadFirstFourBytes(s);
                if (datum == 101010256u)
                {
                    return;
                }
                int nTries = 0;
                bool success = false;
                long posn = s.Length - 64L;
                long maxSeekback = Math.Max(s.Length - 16384L, 10L);
                do
                {
                    if (posn < 0L)
                    {
                        posn = 0L;
                    }
                    s.Seek(posn, SeekOrigin.Begin);
                    long bytesRead = SharedUtilities.FindSignature(s, 101010256);
                    if (bytesRead != -1L)
                    {
                        success = true;
                    }
                    else
                    {
                        if (posn == 0L)
                        {
                            break;
                        }
                        nTries++;
                        posn -= (long)(32 * (nTries + 1) * nTries);
                    }
                }
                while (!success && posn > maxSeekback);
                if (success)
                {
                    zf._locEndOfCDS = s.Position - 4L;
                    byte[] block = new byte[16];
                    s.Read(block, 0, block.Length);
                    zf._diskNumberWithCd = (uint)BitConverter.ToUInt16(block, 2);
                    if (zf._diskNumberWithCd == 65535u)
                    {
                        throw new ZipException("Spanned archives with more than 65534 segments are not supported at this time.");
                    }
                    zf._diskNumberWithCd += 1u;
                    int i = 12;
                    uint offset32 = BitConverter.ToUInt32(block, i);
                    if (offset32 == 4294967295u)
                    {
                        ZipFile.Zip64SeekToCentralDirectory(zf);
                    }
                    else
                    {
                        zf._OffsetOfCentralDirectory = offset32;
                        s.Seek((long)((ulong)offset32), SeekOrigin.Begin);
                    }
                    ZipFile.ReadCentralDirectory(zf);
                }
                else
                {
                    s.Seek(0L, SeekOrigin.Begin);
                    ZipFile.ReadIntoInstance_Orig(zf);
                }
            }
            catch (Exception ex)
            {
                if (zf._ReadStreamIsOurs && zf._readstream != null)
                {
                    try
                    {
                        zf._readstream.Dispose();
                        zf._readstream = null;
                    }
                    finally
                    {
                    }
                }
                throw new ZipException("Cannot read that as a ZipFile", ex);
            }
            zf._contentsChanged = false;
        }

        // Token: 0x060002E2 RID: 738 RVA: 0x00012ADC File Offset: 0x00010CDC
        private static void Zip64SeekToCentralDirectory(ZipFile zf)
        {
            Stream s = zf.ReadStream;
            byte[] block = new byte[16];
            s.Seek(-40L, SeekOrigin.Current);
            s.Read(block, 0, 16);
            long offset64 = BitConverter.ToInt64(block, 8);
            zf._OffsetOfCentralDirectory = uint.MaxValue;
            zf._OffsetOfCentralDirectory64 = offset64;
            s.Seek(offset64, SeekOrigin.Begin);
            uint datum = (uint)SharedUtilities.ReadInt(s);
            if (datum != 101075792u)
            {
                throw new BadReadException(string.Format("  Bad signature (0x{0:X8}) looking for ZIP64 EoCD Record at position 0x{1:X8}", datum, s.Position));
            }
            s.Read(block, 0, 8);
            long Size = BitConverter.ToInt64(block, 0);
            block = new byte[Size];
            s.Read(block, 0, block.Length);
            offset64 = BitConverter.ToInt64(block, 36);
            s.Seek(offset64, SeekOrigin.Begin);
        }

        // Token: 0x060002E3 RID: 739 RVA: 0x00012BA0 File Offset: 0x00010DA0
        private static uint ReadFirstFourBytes(Stream s)
        {
            return (uint)SharedUtilities.ReadInt(s);
        }

        // Token: 0x060002E4 RID: 740 RVA: 0x00012BBC File Offset: 0x00010DBC
        private static void ReadCentralDirectory(ZipFile zf)
        {
            bool inputUsesZip64 = false;
            Dictionary<string, object> previouslySeen = new Dictionary<string, object>();
            ZipEntry de;
            while ((de = ZipEntry.ReadDirEntry(zf, previouslySeen)) != null)
            {
                de.ResetDirEntry();
                zf.OnReadEntry(true, null);
                if (zf.Verbose)
                {
                    zf.StatusMessageTextWriter.WriteLine("entry {0}", de.FileName);
                }
                zf._entries.Add(de.FileName, de);
                if (de._InputUsesZip64)
                {
                    inputUsesZip64 = true;
                }
                previouslySeen.Add(de.FileName, null);
            }
            if (inputUsesZip64)
            {
                zf.UseZip64WhenSaving = Zip64Option.Always;
            }
            if (zf._locEndOfCDS > 0L)
            {
                zf.ReadStream.Seek(zf._locEndOfCDS, SeekOrigin.Begin);
            }
            ZipFile.ReadCentralDirectoryFooter(zf);
            if (zf.Verbose && !string.IsNullOrEmpty(zf.Comment))
            {
                zf.StatusMessageTextWriter.WriteLine("Zip file Comment: {0}", zf.Comment);
            }
            if (zf.Verbose)
            {
                zf.StatusMessageTextWriter.WriteLine("read in {0} entries.", zf._entries.Count);
            }
            zf.OnReadCompleted();
        }

        // Token: 0x060002E5 RID: 741 RVA: 0x00012CF0 File Offset: 0x00010EF0
        private static void ReadIntoInstance_Orig(ZipFile zf)
        {
            zf.OnReadStarted();
            zf._entries = new Dictionary<string, ZipEntry>();
            if (zf.Verbose)
            {
                if (zf.Name == null)
                {
                    zf.StatusMessageTextWriter.WriteLine("Reading zip from stream...");
                }
                else
                {
                    zf.StatusMessageTextWriter.WriteLine("Reading zip {0}...", zf.Name);
                }
            }
            bool firstEntry = true;
            ZipContainer zc = new ZipContainer(zf);
            ZipEntry e;
            while ((e = ZipEntry.ReadEntry(zc, firstEntry)) != null)
            {
                if (zf.Verbose)
                {
                    zf.StatusMessageTextWriter.WriteLine("  {0}", e.FileName);
                }
                zf._entries.Add(e.FileName, e);
                firstEntry = false;
            }
            try
            {
                Dictionary<string, object> previouslySeen = new Dictionary<string, object>();
                ZipEntry de;
                while ((de = ZipEntry.ReadDirEntry(zf, previouslySeen)) != null)
                {
                    ZipEntry e2 = zf._entries[de.FileName];
                    if (e2 != null)
                    {
                        e2._Comment = de.Comment;
                        if (de.IsDirectory)
                        {
                            e2.MarkAsDirectory();
                        }
                    }
                    previouslySeen.Add(de.FileName, null);
                }
                if (zf._locEndOfCDS > 0L)
                {
                    zf.ReadStream.Seek(zf._locEndOfCDS, SeekOrigin.Begin);
                }
                ZipFile.ReadCentralDirectoryFooter(zf);
                if (zf.Verbose && !string.IsNullOrEmpty(zf.Comment))
                {
                    zf.StatusMessageTextWriter.WriteLine("Zip file Comment: {0}", zf.Comment);
                }
            }
            catch (ZipException)
            {
            }
            catch (IOException)
            {
            }
            zf.OnReadCompleted();
        }

        // Token: 0x060002E6 RID: 742 RVA: 0x00012EC0 File Offset: 0x000110C0
        private static void ReadCentralDirectoryFooter(ZipFile zf)
        {
            Stream s = zf.ReadStream;
            int signature = SharedUtilities.ReadSignature(s);
            int i = 0;
            byte[] block;
            if ((long)signature == 101075792L)
            {
                block = new byte[52];
                s.Read(block, 0, block.Length);
                long DataSize = BitConverter.ToInt64(block, 0);
                if (DataSize < 44L)
                {
                    throw new ZipException("Bad size in the ZIP64 Central Directory.");
                }
                zf._versionMadeBy = BitConverter.ToUInt16(block, i);
                i += 2;
                zf._versionNeededToExtract = BitConverter.ToUInt16(block, i);
                i += 2;
                zf._diskNumberWithCd = BitConverter.ToUInt32(block, i);
                i += 2;
                block = new byte[DataSize - 44L];
                s.Read(block, 0, block.Length);
                signature = SharedUtilities.ReadSignature(s);
                if ((long)signature != 117853008L)
                {
                    throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");
                }
                block = new byte[16];
                s.Read(block, 0, block.Length);
                signature = SharedUtilities.ReadSignature(s);
            }
            if ((long)signature != 101010256L)
            {
                s.Seek(-4L, SeekOrigin.Current);
                throw new BadReadException(string.Format("Bad signature ({0:X8}) at position 0x{1:X8}", signature, s.Position));
            }
            block = new byte[16];
            zf.ReadStream.Read(block, 0, block.Length);
            if (zf._diskNumberWithCd == 0u)
            {
                zf._diskNumberWithCd = (uint)BitConverter.ToUInt16(block, 2);
            }
            ZipFile.ReadZipFileComment(zf);
        }

        // Token: 0x060002E7 RID: 743 RVA: 0x00013038 File Offset: 0x00011238
        private static void ReadZipFileComment(ZipFile zf)
        {
            byte[] block = new byte[2];
            zf.ReadStream.Read(block, 0, block.Length);
            short commentLength = (short)((int)block[0] + (int)block[1] * 256);
            if (commentLength > 0)
            {
                block = new byte[(int)commentLength];
                zf.ReadStream.Read(block, 0, block.Length);
                string s = zf.AlternateEncoding.GetString(block, 0, block.Length);
                zf.Comment = s;
            }
        }

        /// <summary>
        /// Checks the given file to see if it appears to be a valid zip file.
        /// </summary>
        /// <remarks>
        ///
        /// <para>
        ///   Calling this method is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)" /> with the testExtract parameter set to false.
        /// </para>
        /// </remarks>
        ///
        /// <param name="fileName">The file to check.</param>
        /// <returns>true if the file appears to be a zip file.</returns>
        // Token: 0x060002E8 RID: 744 RVA: 0x000130AC File Offset: 0x000112AC
        public static bool IsZipFile(string fileName)
        {
            return ZipFile.IsZipFile(fileName, false);
        }

        /// <summary>
        /// Checks a file to see if it is a valid zip file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method opens the specified zip file, reads in the zip archive,
        ///   verifying the ZIP metadata as it reads.
        /// </para>
        ///
        /// <para>
        ///   If everything succeeds, then the method returns true.  If anything fails -
        ///   for example if an incorrect signature or CRC is found, indicating a
        ///   corrupt file, the the method returns false.  This method also returns
        ///   false for a file that does not exist.
        /// </para>
        ///
        /// <para>
        ///   If <paramref name="testExtract" /> is true, as part of its check, this
        ///   method reads in the content for each entry, expands it, and checks CRCs.
        ///   This provides an additional check beyond verifying the zip header and
        ///   directory data.
        /// </para>
        ///
        /// <para>
        ///   If <paramref name="testExtract" /> is true, and if any of the zip entries
        ///   are protected with a password, this method will return false.  If you want
        ///   to verify a <c>ZipFile</c> that has entries which are protected with a
        ///   password, you will need to do that manually.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="fileName">The zip file to check.</param>
        /// <param name="testExtract">true if the caller wants to extract each entry.</param>
        /// <returns>true if the file contains a valid zip file.</returns>
        // Token: 0x060002E9 RID: 745 RVA: 0x000130C8 File Offset: 0x000112C8
        public static bool IsZipFile(string fileName, bool testExtract)
        {
            bool result = false;
            try
            {
                if (!File.Exists(fileName))
                {
                    return false;
                }
                using (FileStream s = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    result = ZipFile.IsZipFile(s, testExtract);
                }
            }
            catch (IOException)
            {
            }
            catch (ZipException)
            {
            }
            return result;
        }

        /// <summary>
        /// Checks a stream to see if it contains a valid zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method reads the zip archive contained in the specified stream, verifying
        /// the ZIP metadata as it reads.  If testExtract is true, this method also extracts
        /// each entry in the archive, dumping all the bits into <see cref="F:System.IO.Stream.Null" />.
        /// </para>
        ///
        /// <para>
        /// If everything succeeds, then the method returns true.  If anything fails -
        /// for example if an incorrect signature or CRC is found, indicating a corrupt
        /// file, the the method returns false.  This method also returns false for a
        /// file that does not exist.
        /// </para>
        ///
        /// <para>
        /// If <c>testExtract</c> is true, this method reads in the content for each
        /// entry, expands it, and checks CRCs.  This provides an additional check
        /// beyond verifying the zip header data.
        /// </para>
        ///
        /// <para>
        /// If <c>testExtract</c> is true, and if any of the zip entries are protected
        /// with a password, this method will return false.  If you want to verify a
        /// ZipFile that has entries which are protected with a password, you will need
        /// to do that manually.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)" />
        ///
        /// <param name="stream">The stream to check.</param>
        /// <param name="testExtract">true if the caller wants to extract each entry.</param>
        /// <returns>true if the stream contains a valid zip archive.</returns>
        // Token: 0x060002EA RID: 746 RVA: 0x0001314C File Offset: 0x0001134C
        public static bool IsZipFile(Stream stream, bool testExtract)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }
            bool result = false;
            try
            {
                if (!stream.CanRead)
                {
                    return false;
                }
                Stream bitBucket = Stream.Null;
                using (ZipFile zip = ZipFile.Read(stream, null, null, null))
                {
                    if (testExtract)
                    {
                        foreach (ZipEntry e in zip)
                        {
                            if (!e.IsDirectory)
                            {
                                e.Extract(bitBucket);
                            }
                        }
                    }
                }
                result = true;
            }
            catch (IOException)
            {
            }
            catch (ZipException)
            {
            }
            return result;
        }

        /// <summary>
        ///   Delete file with retry on UnauthorizedAccessException.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///     When calling File.Delete() on a file that has been "recently"
        ///     created, the call sometimes fails with
        ///     UnauthorizedAccessException. This method simply retries the Delete 3
        ///     times with a sleep between tries.
        ///   </para>
        /// </remarks>
        ///
        /// <param name="filename">the name of the file to be deleted</param>
        // Token: 0x060002EB RID: 747 RVA: 0x00013258 File Offset: 0x00011458
        private void DeleteFileWithRetry(string filename)
        {
            bool done = false;
            int nRetries = 3;
            int i = 0;
            while (i < nRetries && !done)
            {
                try
                {
                    File.Delete(filename);
                    done = true;
                }
                catch (UnauthorizedAccessException)
                {
                    Console.WriteLine("************************************************** Retry delete.");
                    Thread.Sleep(200 + i * 200);
                }
                i++;
            }
        }

        /// <summary>
        ///   Saves the Zip archive to a file, specified by the Name property of the
        ///   <c>ZipFile</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The <c>ZipFile</c> instance is written to storage, typically a zip file
        ///   in a filesystem, only when the caller calls <c>Save</c>.  In the typical
        ///   case, the Save operation writes the zip content to a temporary file, and
        ///   then renames the temporary file to the desired name. If necessary, this
        ///   method will delete a pre-existing file before the rename.
        /// </para>
        ///
        /// <para>
        ///   The <see cref="P:Ionic.Zip.ZipFile.Name" /> property is specified either explicitly,
        ///   or implicitly using one of the parameterized ZipFile constructors.  For
        ///   COM Automation clients, the <c>Name</c> property must be set explicitly,
        ///   because COM Automation clients cannot call parameterized constructors.
        /// </para>
        ///
        /// <para>
        ///   When using a filesystem file for the Zip output, it is possible to call
        ///   <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each
        ///   call the zip content is re-written to the same output file.
        /// </para>
        ///
        /// <para>
        ///   Data for entries that have been added to the <c>ZipFile</c> instance is
        ///   written to the output when the <c>Save</c> method is called. This means
        ///   that the input streams for those entries must be available at the time
        ///   the application calls <c>Save</c>.  If, for example, the application
        ///   adds entries with <c>AddEntry</c> using a dynamically-allocated
        ///   <c>MemoryStream</c>, the memory stream must not have been disposed
        ///   before the call to <c>Save</c>. See the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property for more discussion of the
        ///   availability requirements of the input stream for an entry, and an
        ///   approach for providing just-in-time stream lifecycle management.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />
        ///
        /// <exception cref="T:Ionic.Zip.BadStateException">
        ///   Thrown if you haven't specified a location or stream for saving the zip,
        ///   either in the constructor or by setting the Name property, or if you try
        ///   to save a regular zip archive to a filename with a .exe extension.
        /// </exception>
        ///
        /// <exception cref="T:System.OverflowException">
        ///   Thrown if <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" /> is non-zero, and the number
        ///   of segments that would be generated for the spanned zip file during the
        ///   save operation exceeds 99.  If this happens, you need to increase the
        ///   segment size.
        /// </exception>
        // Token: 0x060002EC RID: 748 RVA: 0x000132C4 File Offset: 0x000114C4
        public void Save()
        {
            try
            {
                bool thisSaveUsedZip64 = false;
                this._saveOperationCanceled = false;
                this._numberOfSegmentsForMostRecentSave = 0u;
                this.OnSaveStarted();
                if (this.WriteStream == null)
                {
                    throw new BadStateException("You haven't specified where to save the zip.");
                }
                if (this._name != null && this._name.EndsWith(".exe") && !this._SavingSfx)
                {
                    throw new BadStateException("You specified an EXE for a plain zip file.");
                }
                if (!this._contentsChanged)
                {
                    this.OnSaveCompleted();
                    if (this.Verbose)
                    {
                        this.StatusMessageTextWriter.WriteLine("No save is necessary....");
                    }
                }
                else
                {
                    this.Reset(true);
                    if (this.Verbose)
                    {
                        this.StatusMessageTextWriter.WriteLine("saving....");
                    }
                    if (this._entries.Count >= 65535 && this._zip64 == Zip64Option.Default)
                    {
                        throw new ZipException("The number of entries is 65535 or greater. Consider setting the UseZip64WhenSaving property on the ZipFile instance.");
                    }
                    int i = 0;
                    ICollection<ZipEntry> c = this.SortEntriesBeforeSaving ? this.EntriesSorted : this.Entries;
                    foreach (ZipEntry e in c)
                    {
                        this.OnSaveEntry(i, e, true);
                        e.Write(this.WriteStream);
                        if (this._saveOperationCanceled)
                        {
                            break;
                        }
                        i++;
                        this.OnSaveEntry(i, e, false);
                        if (this._saveOperationCanceled)
                        {
                            break;
                        }
                        if (e.IncludedInMostRecentSave)
                        {
                            thisSaveUsedZip64 |= e.OutputUsedZip64.Value;
                        }
                    }
                    if (!this._saveOperationCanceled)
                    {
                        ZipSegmentedStream zss = this.WriteStream as ZipSegmentedStream;
                        this._numberOfSegmentsForMostRecentSave = ((zss != null) ? zss.CurrentSegment : 1u);
                        bool directoryNeededZip64 = ZipOutput.WriteCentralDirectoryStructure(this.WriteStream, c, this._numberOfSegmentsForMostRecentSave, this._zip64, this.Comment, new ZipContainer(this));
                        this.OnSaveEvent(ZipProgressEventType.Saving_AfterSaveTempArchive);
                        this._hasBeenSaved = true;
                        this._contentsChanged = false;
                        thisSaveUsedZip64 = (thisSaveUsedZip64 || directoryNeededZip64);
                        this._OutputUsesZip64 = new bool?(thisSaveUsedZip64);
                        if (this._name != null && (this._temporaryFileName != null || zss != null))
                        {
                            this.WriteStream.Dispose();
                            if (this._saveOperationCanceled)
                            {
                                return;
                            }
                            if (this._fileAlreadyExists && this._readstream != null)
                            {
                                this._readstream.Close();
                                this._readstream = null;
                                foreach (ZipEntry e in c)
                                {
                                    ZipSegmentedStream zss2 = e._archiveStream as ZipSegmentedStream;
                                    if (zss2 != null)
                                    {
                                        zss2.Dispose();
                                    }
                                    e._archiveStream = null;
                                }
                            }
                            string tmpName = null;
                            if (File.Exists(this._name))
                            {
                                tmpName = this._name + "." + Path.GetRandomFileName();
                                if (File.Exists(tmpName))
                                {
                                    this.DeleteFileWithRetry(tmpName);
                                }
                                File.Move(this._name, tmpName);
                            }
                            this.OnSaveEvent(ZipProgressEventType.Saving_BeforeRenameTempArchive);
                            File.Move((zss != null) ? zss.CurrentTempName : this._temporaryFileName, this._name);
                            this.OnSaveEvent(ZipProgressEventType.Saving_AfterRenameTempArchive);
                            if (tmpName != null)
                            {
                                try
                                {
                                    if (File.Exists(tmpName))
                                    {
                                        File.Delete(tmpName);
                                    }
                                }
                                catch
                                {
                                }
                            }
                            this._fileAlreadyExists = true;
                        }
                        ZipFile.NotifyEntriesSaveComplete(c);
                        this.OnSaveCompleted();
                        this._JustSaved = true;
                    }
                }
            }
            finally
            {
                this.CleanupAfterSaveOperation();
            }
        }

        // Token: 0x060002ED RID: 749 RVA: 0x00013728 File Offset: 0x00011928
        private static void NotifyEntriesSaveComplete(ICollection<ZipEntry> c)
        {
            foreach (ZipEntry e in c)
            {
                e.NotifySaveComplete();
            }
        }

        // Token: 0x060002EE RID: 750 RVA: 0x00013780 File Offset: 0x00011980
        private void RemoveTempFile()
        {
            try
            {
                if (File.Exists(this._temporaryFileName))
                {
                    File.Delete(this._temporaryFileName);
                }
            }
            catch (IOException ex)
            {
                if (this.Verbose)
                {
                    this.StatusMessageTextWriter.WriteLine("ZipFile::Save: could not delete temp file: {0}.", ex.Message);
                }
            }
        }

        // Token: 0x060002EF RID: 751 RVA: 0x000137EC File Offset: 0x000119EC
        private void CleanupAfterSaveOperation()
        {
            if (this._name != null)
            {
                if (this._writestream != null)
                {
                    try
                    {
                        this._writestream.Dispose();
                    }
                    catch (IOException)
                    {
                    }
                }
                this._writestream = null;
                if (this._temporaryFileName != null)
                {
                    this.RemoveTempFile();
                    this._temporaryFileName = null;
                }
            }
        }

        /// <summary>
        /// Save the file to a new zipfile, with the given name.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method allows the application to explicitly specify the name of the zip
        /// file when saving. Use this when creating a new zip file, or when
        /// updating a zip archive.
        /// </para>
        ///
        /// <para>
        /// An application can also save a zip archive in several places by calling this
        /// method multiple times in succession, with different filenames.
        /// </para>
        ///
        /// <para>
        /// The <c>ZipFile</c> instance is written to storage, typically a zip file in a
        /// filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
        /// the zip content to a temporary file, and then renames the temporary file
        /// to the desired name. If necessary, this method will delete a pre-existing file
        /// before the rename.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <exception cref="T:System.ArgumentException">
        /// Thrown if you specify a directory for the filename.
        /// </exception>
        ///
        /// <param name="fileName">
        /// The name of the zip archive to save to. Existing files will
        /// be overwritten with great prejudice.
        /// </param>
        ///
        /// <example>
        /// This example shows how to create and Save a zip file.
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///   zip.AddDirectory(@"c:\reports\January");
        ///   zip.Save("January.zip");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As New ZipFile()
        ///   zip.AddDirectory("c:\reports\January")
        ///   zip.Save("January.zip")
        /// End Using
        /// </code>
        ///
        /// </example>
        ///
        /// <example>
        /// This example shows how to update a zip file.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
        /// {
        ///   zip.AddFile("NewData.csv");
        ///   zip.Save("UpdatedArchive.zip");
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
        ///   zip.AddFile("NewData.csv")
        ///   zip.Save("UpdatedArchive.zip")
        /// End Using
        /// </code>
        ///
        /// </example>
        // Token: 0x060002F0 RID: 752 RVA: 0x00013864 File Offset: 0x00011A64
        public void Save(string fileName)
        {
            if (this._name == null)
            {
                this._writestream = null;
            }
            else
            {
                this._readName = this._name;
            }
            this._name = fileName;
            if (Directory.Exists(this._name))
            {
                throw new ZipException("Bad Directory", new ArgumentException("That name specifies an existing directory. Please specify a filename.", "fileName"));
            }
            this._contentsChanged = true;
            this._fileAlreadyExists = File.Exists(this._name);
            this.Save();
        }

        /// <summary>
        ///   Save the zip archive to the specified stream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The <c>ZipFile</c> instance is written to storage - typically a zip file
        ///   in a filesystem, but using this overload, the storage can be anything
        ///   accessible via a writable stream - only when the caller calls <c>Save</c>.
        /// </para>
        ///
        /// <para>
        ///   Use this method to save the zip content to a stream directly.  A common
        ///   scenario is an ASP.NET application that dynamically generates a zip file
        ///   and allows the browser to download it. The application can call
        ///   <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
        ///   output stream, without creating a zip file on the disk on the ASP.NET
        ///   server.
        /// </para>
        ///
        /// <para>
        ///   Be careful when saving a file to a non-seekable stream, including
        ///   <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
        ///   stream, the zip archive is formatted in such a way that may not be
        ///   compatible with all zip tools on all platforms.  It's a perfectly legal
        ///   and compliant zip file, but some people have reported problems opening
        ///   files produced this way using the Mac OS archive utility.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example saves the zipfile content into a MemoryStream, and
        ///   then gets the array of bytes from that MemoryStream.
        ///
        /// <code lang="C#">
        /// using (var zip = new Ionic.Zip.ZipFile())
        /// {
        ///     zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
        ///     zip.Password = "VerySecret.";
        ///     zip.Encryption = EncryptionAlgorithm.WinZipAes128;
        ///     zip.AddFile(sourceFileName);
        ///     MemoryStream output = new MemoryStream();
        ///     zip.Save(output);
        ///
        ///     byte[] zipbytes = output.ToArray();
        /// }
        /// </code>
        /// </example>
        ///
        /// <example>
        /// <para>
        ///   This example shows a pitfall you should avoid. DO NOT read
        ///   from a stream, then try to save to the same stream.  DO
        ///   NOT DO THIS:
        /// </para>
        ///
        /// <code lang="C#">
        /// using (var fs = new FileSteeam(filename, FileMode.Open))
        /// {
        ///   using (var zip = Ionic.Zip.ZipFile.Read(inputStream))
        ///   {
        ///     zip.AddEntry("Name1.txt", "this is the content");
        ///     zip.Save(inputStream);  // NO NO NO!!
        ///   }
        /// }
        /// </code>
        ///
        /// <para>
        ///   Better like this:
        /// </para>
        ///
        /// <code lang="C#">
        /// using (var zip = Ionic.Zip.ZipFile.Read(filename))
        /// {
        ///     zip.AddEntry("Name1.txt", "this is the content");
        ///     zip.Save();  // YES!
        /// }
        /// </code>
        ///
        /// </example>
        ///
        /// <param name="outputStream">
        ///   The <c>System.IO.Stream</c> to write to. It must be
        ///   writable. If you created the ZipFile instanct by calling
        ///   ZipFile.Read(), this stream must not be the same stream
        ///   you passed to ZipFile.Read().
        /// </param>
        // Token: 0x060002F1 RID: 753 RVA: 0x000138EC File Offset: 0x00011AEC
        public void Save(Stream outputStream)
        {
            if (outputStream == null)
            {
                throw new ArgumentNullException("outputStream");
            }
            if (!outputStream.CanWrite)
            {
                throw new ArgumentException("Must be a writable stream.", "outputStream");
            }
            this._name = null;
            this._writestream = new CountingStream(outputStream);
            this._contentsChanged = true;
            this._fileAlreadyExists = false;
            this.Save();
        }

        /// <summary>
        ///   Adds to the ZipFile a set of files from the current working directory on
        ///   disk, that conform to the specified criteria.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method selects files from the the current working directory matching
        ///   the specified criteria, and adds them to the ZipFile.
        /// </para>
        ///
        /// <para>
        ///   Specify the criteria in statements of 3 elements: a noun, an operator, and
        ///   a value.  Consider the string "name != *.doc" .  The noun is "name".  The
        ///   operator is "!=", implying "Not Equal".  The value is "*.doc".  That
        ///   criterion, in English, says "all files with a name that does not end in
        ///   the .doc extension."
        /// </para>
        ///
        /// <para>
        ///   Supported nouns include "name" (or "filename") for the filename; "atime",
        ///   "mtime", and "ctime" for last access time, last modfied time, and created
        ///   time of the file, respectively; "attributes" (or "attrs") for the file
        ///   attributes; "size" (or "length") for the file length (uncompressed), and
        ///   "type" for the type of object, either a file or a directory.  The
        ///   "attributes", "name" and "type" nouns both support = and != as operators.
        ///   The "size", "atime", "mtime", and "ctime" nouns support = and !=, and
        ///   &gt;, &gt;=, &lt;, &lt;= as well. The times are taken to be expressed in
        ///   local time.
        /// </para>
        ///
        /// <para>
        /// Specify values for the file attributes as a string with one or more of the
        /// characters H,R,S,A,I,L in any order, implying file attributes of Hidden,
        /// ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint (symbolic
        /// link) respectively.
        /// </para>
        ///
        /// <para>
        /// To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as the
        /// format.  If you omit the HH:mm:ss portion, it is assumed to be 00:00:00
        /// (midnight).
        /// </para>
        ///
        /// <para>
        /// The value for a size criterion is expressed in integer quantities of bytes,
        /// kilobytes (use k or kb after the number), megabytes (m or mb), or gigabytes
        /// (g or gb).
        /// </para>
        ///
        /// <para>
        /// The value for a name is a pattern to match against the filename, potentially
        /// including wildcards.  The pattern follows CMD.exe glob rules: * implies one
        /// or more of any character, while ?  implies one character.  If the name
        /// pattern contains any slashes, it is matched to the entire filename,
        /// including the path; otherwise, it is matched against only the filename
        /// without the path.  This means a pattern of "*\*.*" matches all files one
        /// directory level deep, while a pattern of "*.*" matches all files in all
        /// directories.
        /// </para>
        ///
        /// <para>
        /// To specify a name pattern that includes spaces, use single quotes around the
        /// pattern.  A pattern of "'* *.*'" will match all files that have spaces in
        /// the filename.  The full criteria string for that would be "name = '* *.*'" .
        /// </para>
        ///
        /// <para>
        /// The value for a type criterion is either F (implying a file) or D (implying
        /// a directory).
        /// </para>
        ///
        /// <para>
        /// Some examples:
        /// </para>
        ///
        /// <list type="table">
        ///   <listheader>
        ///     <term>criteria</term>
        ///     <description>Files retrieved</description>
        ///   </listheader>
        ///
        ///   <item>
        ///     <term>name != *.xls </term>
        ///     <description>any file with an extension that is not .xls
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>name = *.mp3 </term>
        ///     <description>any file with a .mp3 extension.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>*.mp3</term>
        ///     <description>(same as above) any file with a .mp3 extension.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>attributes = A </term>
        ///     <description>all files whose attributes include the Archive bit.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>attributes != H </term>
        ///     <description>all files whose attributes do not include the Hidden bit.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>mtime &gt; 2009-01-01</term>
        ///     <description>all files with a last modified time after January 1st, 2009.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>size &gt; 2gb</term>
        ///     <description>all files whose uncompressed size is greater than 2gb.
        ///     </description>
        ///   </item>
        ///
        ///   <item>
        ///     <term>type = D</term>
        ///     <description>all directories in the filesystem. </description>
        ///   </item>
        ///
        /// </list>
        ///
        /// <para>
        /// You can combine criteria with the conjunctions AND or OR. Using a string
        /// like "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves
        /// entries whose names end in .txt, and whose uncompressed size is greater than
        /// or equal to 100 kilobytes.
        /// </para>
        ///
        /// <para>
        /// For more complex combinations of criteria, you can use parenthesis to group
        /// clauses in the boolean logic.  Without parenthesis, the precedence of the
        /// criterion atoms is determined by order of appearance.  Unlike the C#
        /// language, the AND conjunction does not take precendence over the logical OR.
        /// This is important only in strings that contain 3 or more criterion atoms.
        /// In other words, "name = *.txt and size &gt; 1000 or attributes = H" implies
        /// "((name = *.txt AND size &gt; 1000) OR attributes = H)" while "attributes =
        /// H OR name = *.txt and size &gt; 1000" evaluates to "((attributes = H OR name
        /// = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
        /// </para>
        ///
        /// <para>
        /// Using time properties requires some extra care. If you want to retrieve all
        /// entries that were last updated on 2009 February 14, specify a time range
        /// like so:"mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to
        /// say: all files updated after 12:00am on February 14th, until 12:00am on
        /// February 15th.  You can use the same bracketing approach to specify any time
        /// period - a year, a month, a week, and so on.
        /// </para>
        ///
        /// <para>
        /// The syntax allows one special case: if you provide a string with no spaces, it is
        /// treated as a pattern to match for the filename.  Therefore a string like "*.xls"
        /// will be equivalent to specifying "name = *.xls".
        /// </para>
        ///
        /// <para>
        /// There is no logic in this method that insures that the file inclusion
        /// criteria are internally consistent.  For example, it's possible to specify
        /// criteria that says the file must have a size of less than 100 bytes, as well
        /// as a size that is greater than 1000 bytes. Obviously no file will ever
        /// satisfy such criteria, but this method does not detect such logical
        /// inconsistencies. The caller is responsible for insuring the criteria are
        /// sensible.
        /// </para>
        ///
        /// <para>
        ///   Using this method, the file selection does not recurse into
        ///   subdirectories, and the full path of the selected files is included in the
        ///   entries added into the zip archive.  If you don't like these behaviors,
        ///   see the other overloads of this method.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example zips up all *.csv files in the current working directory.
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     // To just match on filename wildcards,
        ///     // use the shorthand form of the selectionCriteria string.
        ///     zip.AddSelectedFiles("*.csv");
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile()
        ///     zip.AddSelectedFiles("*.csv")
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">The criteria for file selection</param>
        // Token: 0x060002F2 RID: 754 RVA: 0x00013952 File Offset: 0x00011B52
        public void AddSelectedFiles(string selectionCriteria)
        {
            this.AddSelectedFiles(selectionCriteria, ".", null, false);
        }

        /// <summary>
        ///   Adds to the ZipFile a set of files from the disk that conform to the
        ///   specified criteria, optionally recursing into subdirectories.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method selects files from the the current working directory matching
        ///   the specified criteria, and adds them to the ZipFile.  If
        ///   <c>recurseDirectories</c> is true, files are also selected from
        ///   subdirectories, and the directory structure in the filesystem is
        ///   reproduced in the zip archive, rooted at the current working directory.
        /// </para>
        ///
        /// <para>
        ///   Using this method, the full path of the selected files is included in the
        ///   entries added into the zip archive.  If you don't want this behavior, use
        ///   one of the overloads of this method that allows the specification of a
        ///   <c>directoryInArchive</c>.
        /// </para>
        ///
        /// <para>
        ///   For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example zips up all *.xml files in the current working directory, or any
        ///   subdirectory, that are larger than 1mb.
        ///
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     // Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true);
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile()
        ///     ' Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true)
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">The criteria for file selection</param>
        ///
        /// <param name="recurseDirectories">
        ///   If true, the file selection will recurse into subdirectories.
        /// </param>
        // Token: 0x060002F3 RID: 755 RVA: 0x00013964 File Offset: 0x00011B64
        public void AddSelectedFiles(string selectionCriteria, bool recurseDirectories)
        {
            this.AddSelectedFiles(selectionCriteria, ".", null, recurseDirectories);
        }

        /// <summary>
        ///   Adds to the ZipFile a set of files from a specified directory in the
        ///   filesystem, that conform to the specified criteria.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method selects files that conform to the specified criteria, from the
        ///   the specified directory on disk, and adds them to the ZipFile.  The search
        ///   does not recurse into subdirectores.
        /// </para>
        ///
        /// <para>
        ///   Using this method, the full filesystem path of the files on disk is
        ///   reproduced on the entries added to the zip file.  If you don't want this
        ///   behavior, use one of the other overloads of this method.
        /// </para>
        ///
        /// <para>
        ///   For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example zips up all *.xml files larger than 1mb in the directory
        ///   given by "d:\rawdata".
        ///
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     // Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\\rawdata");
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile()
        ///     ' Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\rawdata)
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">The criteria for file selection</param>
        ///
        /// <param name="directoryOnDisk">
        /// The name of the directory on the disk from which to select files.
        /// </param>
        // Token: 0x060002F4 RID: 756 RVA: 0x00013976 File Offset: 0x00011B76
        public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk)
        {
            this.AddSelectedFiles(selectionCriteria, directoryOnDisk, null, false);
        }

        /// <summary>
        ///   Adds to the ZipFile a set of files from the specified directory on disk,
        ///   that conform to the specified criteria.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This method selects files from the the specified disk directory matching
        ///   the specified selection criteria, and adds them to the ZipFile.  If
        ///   <c>recurseDirectories</c> is true, files are also selected from
        ///   subdirectories.
        /// </para>
        ///
        /// <para>
        ///   The full directory structure in the filesystem is reproduced on the
        ///   entries added to the zip archive.  If you don't want this behavior, use
        ///   one of the overloads of this method that allows the specification of a
        ///   <c>directoryInArchive</c>.
        /// </para>
        ///
        /// <para>
        ///   For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example zips up all *.csv files in the "files" directory, or any
        ///   subdirectory, that have been saved since 2009 February 14th.
        ///
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     // Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true);
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile()
        ///     ' Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true)
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <example>
        ///   This example zips up all files in the current working
        ///   directory, and all its child directories, except those in
        ///   the <c>excludethis</c> subdirectory.
        /// <code lang="VB">
        /// Using Zip As ZipFile = New ZipFile(zipfile)
        ///   Zip.AddSelectedFfiles("name != 'excludethis\*.*'", datapath, True)
        ///   Zip.Save()
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">The criteria for file selection</param>
        ///
        /// <param name="directoryOnDisk">
        ///   The filesystem path from which to select files.
        /// </param>
        ///
        /// <param name="recurseDirectories">
        ///   If true, the file selection will recurse into subdirectories.
        /// </param>
        // Token: 0x060002F5 RID: 757 RVA: 0x00013984 File Offset: 0x00011B84
        public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, bool recurseDirectories)
        {
            this.AddSelectedFiles(selectionCriteria, directoryOnDisk, null, recurseDirectories);
        }

        /// <summary>
        ///   Adds to the ZipFile a selection of files from the specified directory on
        ///   disk, that conform to the specified criteria, and using a specified root
        ///   path for entries added to the zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method selects files from the specified disk directory matching the
        ///   specified selection criteria, and adds those files to the ZipFile, using
        ///   the specified directory path in the archive.  The search does not recurse
        ///   into subdirectories.  For details on the syntax for the selectionCriteria
        ///   parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example zips up all *.psd files in the "photos" directory that have
        ///   been saved since 2009 February 14th, and puts them all in a zip file,
        ///   using the directory name of "content" in the zip archive itself. When the
        ///   zip archive is unzipped, the folder containing the .psd files will be
        ///   named "content".
        ///
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     // Use a compound expression in the selectionCriteria string.
        ///     zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content");
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile
        ///     zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content")
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">
        ///   The criteria for selection of files to add to the <c>ZipFile</c>.
        /// </param>
        ///
        /// <param name="directoryOnDisk">
        ///   The path to the directory in the filesystem from which to select files.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to in place of the
        ///   <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
        ///   directory in the current filesystem.  If the files within the zip are
        ///   later extracted, this is the path used for the extracted file.  Passing
        ///   null (nothing in VB) will use the path on the file name, if any; in other
        ///   words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
        ///   the empty string ("") will insert the item at the root path within the
        ///   archive.
        /// </param>
        // Token: 0x060002F6 RID: 758 RVA: 0x00013992 File Offset: 0x00011B92
        public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive)
        {
            this.AddSelectedFiles(selectionCriteria, directoryOnDisk, directoryPathInArchive, false);
        }

        /// <summary>
        ///   Adds to the ZipFile a selection of files from the specified directory on
        ///   disk, that conform to the specified criteria, optionally recursing through
        ///   subdirectories, and using a specified root path for entries added to the
        ///   zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///   This method selects files from the specified disk directory that match the
        ///   specified selection criteria, and adds those files to the ZipFile, using
        ///   the specified directory path in the archive. If <c>recurseDirectories</c>
        ///   is true, files are also selected from subdirectories, and the directory
        ///   structure in the filesystem is reproduced in the zip archive, rooted at
        ///   the directory specified by <c>directoryOnDisk</c>.  For details on the
        ///   syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example zips up all files that are NOT *.pst files, in the current
        ///   working directory and any subdirectories.
        ///
        /// <code>
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
        ///     zip.Save(PathToZipArchive);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = New ZipFile
        ///     zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
        ///     zip.Save(PathToZipArchive)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">
        ///   The criteria for selection of files to add to the <c>ZipFile</c>.
        /// </param>
        ///
        /// <param name="directoryOnDisk">
        ///   The path to the directory in the filesystem from which to select files.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to in place of the
        ///   <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
        ///   directory in the current filesystem.  If the files within the zip are
        ///   later extracted, this is the path used for the extracted file.  Passing
        ///   null (nothing in VB) will use the path on the file name, if any; in other
        ///   words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
        ///   the empty string ("") will insert the item at the root path within the
        ///   archive.
        /// </param>
        ///
        /// <param name="recurseDirectories">
        ///   If true, the method also scans subdirectories for files matching the
        ///   criteria.
        /// </param>
        // Token: 0x060002F7 RID: 759 RVA: 0x000139A0 File Offset: 0x00011BA0
        public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories)
        {
            this._AddOrUpdateSelectedFiles(selectionCriteria, directoryOnDisk, directoryPathInArchive, recurseDirectories, false);
        }

        /// <summary>
        ///   Updates the ZipFile with a selection of files from the disk that conform
        ///   to the specified criteria.
        /// </summary>
        ///
        /// <remarks>
        ///   This method selects files from the specified disk directory that match the
        ///   specified selection criteria, and Updates the <c>ZipFile</c> with those
        ///   files, using the specified directory path in the archive. If
        ///   <c>recurseDirectories</c> is true, files are also selected from
        ///   subdirectories, and the directory structure in the filesystem is
        ///   reproduced in the zip archive, rooted at the directory specified by
        ///   <c>directoryOnDisk</c>.  For details on the syntax for the
        ///   selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </remarks>
        ///
        /// <param name="selectionCriteria">
        ///   The criteria for selection of files to add to the <c>ZipFile</c>.
        /// </param>
        ///
        /// <param name="directoryOnDisk">
        ///   The path to the directory in the filesystem from which to select files.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        ///   Specifies a directory path to use to in place of the
        ///   <c>directoryOnDisk</c>. This path may, or may not, correspond to a
        ///   real directory in the current filesystem. If the files within the zip
        ///   are later extracted, this is the path used for the extracted file.
        ///   Passing null (nothing in VB) will use the path on the file name, if
        ///   any; in other words it would use <c>directoryOnDisk</c>, plus any
        ///   subdirectory.  Passing the empty string ("") will insert the item at
        ///   the root path within the archive.
        /// </param>
        ///
        /// <param name="recurseDirectories">
        ///   If true, the method also scans subdirectories for files matching the criteria.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)" />
        // Token: 0x060002F8 RID: 760 RVA: 0x000139B0 File Offset: 0x00011BB0
        public void UpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories)
        {
            this._AddOrUpdateSelectedFiles(selectionCriteria, directoryOnDisk, directoryPathInArchive, recurseDirectories, true);
        }

        // Token: 0x060002F9 RID: 761 RVA: 0x000139C0 File Offset: 0x00011BC0
        private string EnsureendInSlash(string s)
        {
            string result;
            if (s.EndsWith("\\"))
            {
                result = s;
            }
            else
            {
                result = s + "\\";
            }
            return result;
        }

        // Token: 0x060002FA RID: 762 RVA: 0x000139F4 File Offset: 0x00011BF4
        private void _AddOrUpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories, bool wantUpdate)
        {
            if (directoryOnDisk == null && Directory.Exists(selectionCriteria))
            {
                directoryOnDisk = selectionCriteria;
                selectionCriteria = "*.*";
            }
            else if (string.IsNullOrEmpty(directoryOnDisk))
            {
                directoryOnDisk = ".";
            }
            while (directoryOnDisk.EndsWith("\\"))
            {
                directoryOnDisk = directoryOnDisk.Substring(0, directoryOnDisk.Length - 1);
            }
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("adding selection '{0}' from dir '{1}'...", selectionCriteria, directoryOnDisk);
            }
            FileSelector ff = new FileSelector(selectionCriteria, this.AddDirectoryWillTraverseReparsePoints);
            ReadOnlyCollection<string> itemsToAdd = ff.SelectFiles(directoryOnDisk, recurseDirectories);
            if (this.Verbose)
            {
                this.StatusMessageTextWriter.WriteLine("found {0} files...", itemsToAdd.Count);
            }
            this.OnAddStarted();
            AddOrUpdateAction action = wantUpdate ? AddOrUpdateAction.AddOrUpdate : AddOrUpdateAction.AddOnly;
            foreach (string item in itemsToAdd)
            {
                string dirInArchive = (directoryPathInArchive == null) ? null : ZipFile.ReplaceLeadingDirectory(Path.GetDirectoryName(item), directoryOnDisk, directoryPathInArchive);
                if (File.Exists(item))
                {
                    if (wantUpdate)
                    {
                        this.UpdateFile(item, dirInArchive);
                    }
                    else
                    {
                        this.AddFile(item, dirInArchive);
                    }
                }
                else
                {
                    this.AddOrUpdateDirectoryImpl(item, dirInArchive, action, false, 0);
                }
            }
            this.OnAddCompleted();
        }

        // Token: 0x060002FB RID: 763 RVA: 0x00013B80 File Offset: 0x00011D80
        private static string ReplaceLeadingDirectory(string original, string pattern, string replacement)
        {
            string upperString = original.ToUpper();
            string upperPattern = pattern.ToUpper();
            int p = upperString.IndexOf(upperPattern);
            string result;
            if (p != 0)
            {
                result = original;
            }
            else
            {
                result = replacement + original.Substring(upperPattern.Length);
            }
            return result;
        }

        /// <summary>
        /// Retrieve entries from the zipfile by specified criteria.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method allows callers to retrieve the collection of entries from the zipfile
        /// that fit the specified criteria.  The criteria are described in a string format, and
        /// can include patterns for the filename; constraints on the size of the entry;
        /// constraints on the last modified, created, or last accessed time for the file
        /// described by the entry; or the attributes of the entry.
        /// </para>
        ///
        /// <para>
        /// For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// <para>
        /// This method is intended for use with a ZipFile that has been read from storage.
        /// When creating a new ZipFile, this method will work only after the ZipArchive has
        /// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
        /// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
        /// saved will deliver undefined results.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.Exception">
        /// Thrown if selectionCriteria has an invalid syntax.
        /// </exception>
        ///
        /// <example>
        /// This example selects all the PhotoShop files from within an archive, and extracts them
        /// to the current working directory.
        /// <code>
        /// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
        /// {
        ///     var PhotoShopFiles = zip1.SelectEntries("*.psd");
        ///     foreach (ZipEntry psd in PhotoShopFiles)
        ///     {
        ///         psd.Extract();
        ///     }
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
        ///     Dim PhotoShopFiles as ICollection(Of ZipEntry)
        ///     PhotoShopFiles = zip1.SelectEntries("*.psd")
        ///     Dim psd As ZipEntry
        ///     For Each psd In PhotoShopFiles
        ///         psd.Extract
        ///     Next
        /// End Using
        /// </code>
        /// </example>
        /// <param name="selectionCriteria">the string that specifies which entries to select</param>
        /// <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        // Token: 0x060002FC RID: 764 RVA: 0x00013BC8 File Offset: 0x00011DC8
        public ICollection<ZipEntry> SelectEntries(string selectionCriteria)
        {
            FileSelector ff = new FileSelector(selectionCriteria, this.AddDirectoryWillTraverseReparsePoints);
            return ff.SelectEntries(this);
        }

        /// <summary>
        /// Retrieve entries from the zipfile by specified criteria.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method allows callers to retrieve the collection of entries from the zipfile
        /// that fit the specified criteria.  The criteria are described in a string format, and
        /// can include patterns for the filename; constraints on the size of the entry;
        /// constraints on the last modified, created, or last accessed time for the file
        /// described by the entry; or the attributes of the entry.
        /// </para>
        ///
        /// <para>
        /// For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// <para>
        /// This method is intended for use with a ZipFile that has been read from storage.
        /// When creating a new ZipFile, this method will work only after the ZipArchive has
        /// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
        /// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
        /// saved will deliver undefined results.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.Exception">
        /// Thrown if selectionCriteria has an invalid syntax.
        /// </exception>
        ///
        /// <example>
        /// <code>
        /// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
        /// {
        ///     var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
        ///     foreach (ZipEntry e in UpdatedPhotoShopFiles)
        ///     {
        ///         // prompt for extract here
        ///         if (WantExtract(e.FileName))
        ///             e.Extract();
        ///     }
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
        ///     Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
        ///     Dim e As ZipEntry
        ///     For Each e In UpdatedPhotoShopFiles
        ///         ' prompt for extract here
        ///         If Me.WantExtract(e.FileName) Then
        ///             e.Extract
        ///         End If
        ///     Next
        /// End Using
        /// </code>
        /// </example>
        /// <param name="selectionCriteria">the string that specifies which entries to select</param>
        ///
        /// <param name="directoryPathInArchive">
        /// the directory in the archive from which to select entries. If null, then
        /// all directories in the archive are used.
        /// </param>
        ///
        /// <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        // Token: 0x060002FD RID: 765 RVA: 0x00013BF0 File Offset: 0x00011DF0
        public ICollection<ZipEntry> SelectEntries(string selectionCriteria, string directoryPathInArchive)
        {
            FileSelector ff = new FileSelector(selectionCriteria, this.AddDirectoryWillTraverseReparsePoints);
            return ff.SelectEntries(this, directoryPathInArchive);
        }

        /// <summary>
        /// Remove entries from the zipfile by specified criteria.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method allows callers to remove the collection of entries from the zipfile
        /// that fit the specified criteria.  The criteria are described in a string format, and
        /// can include patterns for the filename; constraints on the size of the entry;
        /// constraints on the last modified, created, or last accessed time for the file
        /// described by the entry; or the attributes of the entry.
        /// </para>
        ///
        /// <para>
        /// For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// <para>
        /// This method is intended for use with a ZipFile that has been read from storage.
        /// When creating a new ZipFile, this method will work only after the ZipArchive has
        /// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
        /// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
        /// saved will deliver undefined results.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.Exception">
        /// Thrown if selectionCriteria has an invalid syntax.
        /// </exception>
        ///
        /// <example>
        /// This example removes all entries in a zip file that were modified prior to January 1st, 2008.
        /// <code>
        /// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
        /// {
        ///     // remove all entries from prior to Jan 1, 2008
        ///     zip1.RemoveEntries("mtime &lt; 2008-01-01");
        ///     // don't forget to save the archive!
        ///     zip1.Save();
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(ZipFileName)
        ///     ' remove all entries from prior to Jan 1, 2008
        ///     zip1.RemoveEntries("mtime &lt; 2008-01-01")
        ///     ' do not forget to save the archive!
        ///     zip1.Save
        /// End Using
        /// </code>
        /// </example>
        /// <param name="selectionCriteria">the string that specifies which entries to select</param>
        /// <returns>the number of entries removed</returns>
        // Token: 0x060002FE RID: 766 RVA: 0x00013C18 File Offset: 0x00011E18
        public int RemoveSelectedEntries(string selectionCriteria)
        {
            ICollection<ZipEntry> selection = this.SelectEntries(selectionCriteria);
            this.RemoveEntries(selection);
            return selection.Count;
        }

        /// <summary>
        /// Remove entries from the zipfile by specified criteria, and within the specified
        /// path in the archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// This method allows callers to remove the collection of entries from the zipfile
        /// that fit the specified criteria.  The criteria are described in a string format, and
        /// can include patterns for the filename; constraints on the size of the entry;
        /// constraints on the last modified, created, or last accessed time for the file
        /// described by the entry; or the attributes of the entry.
        /// </para>
        ///
        /// <para>
        /// For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        ///
        /// <para>
        /// This method is intended for use with a ZipFile that has been read from storage.
        /// When creating a new ZipFile, this method will work only after the ZipArchive has
        /// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
        /// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
        /// saved will deliver undefined results.
        /// </para>
        /// </remarks>
        ///
        /// <exception cref="T:System.Exception">
        /// Thrown if selectionCriteria has an invalid syntax.
        /// </exception>
        ///
        /// <example>
        /// <code>
        /// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
        /// {
        ///     // remove all entries from prior to Jan 1, 2008
        ///     zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
        ///     // a call to ZipFile.Save will make the modifications permanent
        ///     zip1.Save();
        /// }
        /// </code>
        /// <code lang="VB">
        /// Using zip As ZipFile = ZipFile.Read(ZipFileName)
        ///     ' remove all entries from prior to Jan 1, 2008
        ///     zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
        ///     ' a call to ZipFile.Save will make the modifications permanent
        ///     zip1.Save
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">the string that specifies which entries to select</param>
        /// <param name="directoryPathInArchive">
        /// the directory in the archive from which to select entries. If null, then
        /// all directories in the archive are used.
        /// </param>
        /// <returns>the number of entries removed</returns>
        // Token: 0x060002FF RID: 767 RVA: 0x00013C40 File Offset: 0x00011E40
        public int RemoveSelectedEntries(string selectionCriteria, string directoryPathInArchive)
        {
            ICollection<ZipEntry> selection = this.SelectEntries(selectionCriteria, directoryPathInArchive);
            this.RemoveEntries(selection);
            return selection.Count;
        }

        /// <summary>
        /// Selects and Extracts a set of Entries from the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The entries are extracted into the current working directory.
        /// </para>
        ///
        /// <para>
        /// If any of the files to be extracted already exist, then the action taken is as
        /// specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
        /// corresponding ZipEntry instance.  By default, the action taken in this case is to
        /// throw an exception.
        /// </para>
        ///
        /// <para>
        /// For information on the syntax of the selectionCriteria string,
        /// see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example shows how extract all XML files modified after 15 January 2009.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipArchiveName))
        /// {
        ///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
        /// }
        /// </code>
        /// </example>
        /// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
        // Token: 0x06000300 RID: 768 RVA: 0x00013C6C File Offset: 0x00011E6C
        public void ExtractSelectedEntries(string selectionCriteria)
        {
            foreach (ZipEntry e in this.SelectEntries(selectionCriteria))
            {
                e.Password = this._Password;
                e.Extract();
            }
        }

        /// <summary>
        /// Selects and Extracts a set of Entries from the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The entries are extracted into the current working directory. When extraction would would
        /// overwrite an existing filesystem file, the action taken is as specified in the
        /// <paramref name="extractExistingFile" /> parameter.
        /// </para>
        ///
        /// <para>
        /// For information on the syntax of the string describing the entry selection criteria,
        /// see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example shows how extract all XML files modified after 15 January 2009,
        /// overwriting any existing files.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipArchiveName))
        /// {
        ///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
        ///                              ExtractExistingFileAction.OverwriteSilently);
        /// }
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
        ///
        /// <param name="extractExistingFile">
        /// The action to take if extraction would overwrite an existing file.
        /// </param>
        // Token: 0x06000301 RID: 769 RVA: 0x00013CD4 File Offset: 0x00011ED4
        public void ExtractSelectedEntries(string selectionCriteria, ExtractExistingFileAction extractExistingFile)
        {
            foreach (ZipEntry e in this.SelectEntries(selectionCriteria))
            {
                e.Password = this._Password;
                e.Extract(extractExistingFile);
            }
        }

        /// <summary>
        /// Selects and Extracts a set of Entries from the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The entries are selected from the specified directory within the archive, and then
        /// extracted into the current working directory.
        /// </para>
        ///
        /// <para>
        /// If any of the files to be extracted already exist, then the action taken is as
        /// specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
        /// corresponding ZipEntry instance.  By default, the action taken in this case is to
        /// throw an exception.
        /// </para>
        ///
        /// <para>
        /// For information on the syntax of the string describing the entry selection criteria,
        /// see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example shows how extract all XML files modified after 15 January 2009,
        /// and writes them to the "unpack" directory.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipArchiveName))
        /// {
        ///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
        /// }
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
        ///
        /// <param name="directoryPathInArchive">
        /// the directory in the archive from which to select entries. If null, then
        /// all directories in the archive are used.
        /// </param>
        ///
        /// <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)" />
        // Token: 0x06000302 RID: 770 RVA: 0x00013D40 File Offset: 0x00011F40
        public void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive)
        {
            foreach (ZipEntry e in this.SelectEntries(selectionCriteria, directoryPathInArchive))
            {
                e.Password = this._Password;
                e.Extract();
            }
        }

        /// <summary>
        /// Selects and Extracts a set of Entries from the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The entries are extracted into the specified directory. If any of the files to be
        /// extracted already exist, an exception will be thrown.
        /// </para>
        /// <para>
        /// For information on the syntax of the string describing the entry selection criteria,
        /// see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
        ///
        /// <param name="directoryInArchive">
        /// the directory in the archive from which to select entries. If null, then
        /// all directories in the archive are used.
        /// </param>
        ///
        /// <param name="extractDirectory">
        /// the directory on the disk into which to extract. It will be created
        /// if it does not exist.
        /// </param>
        // Token: 0x06000303 RID: 771 RVA: 0x00013DAC File Offset: 0x00011FAC
        public void ExtractSelectedEntries(string selectionCriteria, string directoryInArchive, string extractDirectory)
        {
            foreach (ZipEntry e in this.SelectEntries(selectionCriteria, directoryInArchive))
            {
                e.Password = this._Password;
                e.Extract(extractDirectory);
            }
        }

        /// <summary>
        /// Selects and Extracts a set of Entries from the ZipFile.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// The entries are extracted into the specified directory. When extraction would would
        /// overwrite an existing filesystem file, the action taken is as specified in the
        /// <paramref name="extractExistingFile" /> parameter.
        /// </para>
        ///
        /// <para>
        /// For information on the syntax of the string describing the entry selection criteria,
        /// see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
        /// and puts them in the unpack directory.  For any files that already exist in
        /// that destination directory, they will not be overwritten.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipArchiveName))
        /// {
        ///   zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
        ///                              null,
        ///                              "unpack",
        ///                              ExtractExistingFileAction.DontOverwrite);
        /// }
        /// </code>
        /// </example>
        ///
        /// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
        ///
        /// <param name="extractDirectory">
        /// The directory on the disk into which to extract. It will be created if it does not exist.
        /// </param>
        ///
        /// <param name="directoryPathInArchive">
        /// The directory in the archive from which to select entries. If null, then
        /// all directories in the archive are used.
        /// </param>
        ///
        /// <param name="extractExistingFile">
        /// The action to take if extraction would overwrite an existing file.
        /// </param>
        // Token: 0x06000304 RID: 772 RVA: 0x00013E18 File Offset: 0x00012018
        public void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive, string extractDirectory, ExtractExistingFileAction extractExistingFile)
        {
            foreach (ZipEntry e in this.SelectEntries(selectionCriteria, directoryPathInArchive))
            {
                e.Password = this._Password;
                e.Extract(extractDirectory, extractExistingFile);
            }
        }

        /// <summary>
        /// Saves the ZipFile instance to a self-extracting zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        /// The generated exe image will execute on any machine that has the .NET
        /// Framework 2.0 installed on it.  The generated exe image is also a
        /// valid ZIP file, readable with DotNetZip or another Zip library or tool
        /// such as WinZip.
        /// </para>
        ///
        /// <para>
        /// There are two "flavors" of self-extracting archive.  The
        /// <c>WinFormsApplication</c> version will pop up a GUI and allow the
        /// user to select a target directory into which to extract. There's also
        /// a checkbox allowing the user to specify to overwrite existing files,
        /// and another checkbox to allow the user to request that Explorer be
        /// opened to see the extracted files after extraction.  The other flavor
        /// is <c>ConsoleApplication</c>.  A self-extractor generated with that
        /// flavor setting will run from the command line. It accepts command-line
        /// options to set the overwrite behavior, and to specify the target
        /// extraction directory.
        /// </para>
        ///
        /// <para>
        /// There are a few temporary files created during the saving to a
        /// self-extracting zip.  These files are created in the directory pointed
        /// to by <see cref="P:Ionic.Zip.ZipFile.TempFileFolder" />, which defaults to <see cref="M:System.IO.Path.GetTempPath" />.  These temporary files are
        /// removed upon successful completion of this method.
        /// </para>
        ///
        /// <para>
        /// When a user runs the WinForms SFX, the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal">Environment.SpecialFolder.Personal</see>)
        /// will be used as the default extract location.  If you want to set the
        /// default extract location, you should use the other overload of
        /// <c>SaveSelfExtractor()</c>/ The user who runs the SFX will have the
        /// opportunity to change the extract directory before extracting. When
        /// the user runs the Command-Line SFX, the user must explicitly specify
        /// the directory to which to extract.  The .NET Framework 2.0 is required
        /// on the computer when the self-extracting archive is run.
        /// </para>
        ///
        /// <para>
        /// NB: This method is not available in the version of DotNetZip build for
        /// the .NET Compact Framework, nor in the "Reduced" DotNetZip library.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        /// <code>
        /// string DirectoryPath = "c:\\Documents\\Project7";
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
        ///     zip.Comment = "This will be embedded into a self-extracting console-based exe";
        ///     zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Dim DirectoryPath As String = "c:\Documents\Project7"
        /// Using zip As New ZipFile()
        ///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
        ///     zip.Comment = "This will be embedded into a self-extracting console-based exe"
        ///     zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="exeToGenerate">
        ///   a pathname, possibly fully qualified, to be created. Typically it
        ///   will end in an .exe extension.</param>
        /// <param name="flavor">
        ///   Indicates whether a Winforms or Console self-extractor is
        ///   desired. </param>
        // Token: 0x06000305 RID: 773 RVA: 0x00013E84 File Offset: 0x00012084
        public void SaveSelfExtractor(string exeToGenerate, SelfExtractorFlavor flavor)
        {
            this.SaveSelfExtractor(exeToGenerate, new SelfExtractorSaveOptions
            {
                Flavor = flavor
            });
        }

        /// <summary>
        ///   Saves the ZipFile instance to a self-extracting zip archive, using
        ///   the specified save options.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method saves a self extracting archive, using the specified save
        ///   options. These options include the flavor of the SFX, the default extract
        ///   directory, the icon file, and so on.  See the documentation
        ///   for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)" /> for more
        ///   details.
        /// </para>
        ///
        /// <para>
        ///   The user who runs the SFX will have the opportunity to change the extract
        ///   directory before extracting. If at the time of extraction, the specified
        ///   directory does not exist, the SFX will create the directory before
        ///   extracting the files.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///   This example saves a WinForms-based self-extracting archive EXE that
        ///   will use c:\ExtractHere as the default extract location. The C# code
        ///   shows syntax for .NET 3.0, which uses an object initializer for
        ///   the SelfExtractorOptions object.
        /// <code>
        /// string DirectoryPath = "c:\\Documents\\Project7";
        /// using (ZipFile zip = new ZipFile())
        /// {
        ///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
        ///     zip.Comment = "This will be embedded into a self-extracting WinForms-based exe";
        ///     var options = new SelfExtractorOptions
        ///     {
        ///       Flavor = SelfExtractorFlavor.WinFormsApplication,
        ///       DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere",
        ///       PostExtractCommandLine = ExeToRunAfterExtract,
        ///       SfxExeWindowTitle = "My Custom Window Title",
        ///       RemoveUnpackedFilesAfterExecute = true
        ///     };
        ///     zip.SaveSelfExtractor("archive.exe", options);
        /// }
        /// </code>
        /// <code lang="VB">
        /// Dim DirectoryPath As String = "c:\Documents\Project7"
        /// Using zip As New ZipFile()
        ///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
        ///     zip.Comment = "This will be embedded into a self-extracting console-based exe"
        ///     Dim options As New SelfExtractorOptions()
        ///     options.Flavor = SelfExtractorFlavor.WinFormsApplication
        ///     options.DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere"
        ///     options.PostExtractCommandLine = ExeToRunAfterExtract
        ///     options.SfxExeWindowTitle = "My Custom Window Title"
        ///     options.RemoveUnpackedFilesAfterExecute = True
        ///     zip.SaveSelfExtractor("archive.exe", options)
        /// End Using
        /// </code>
        /// </example>
        ///
        /// <param name="exeToGenerate">The name of the EXE to generate.</param>
        /// <param name="options">provides the options for creating the
        /// Self-extracting archive.</param>
        // Token: 0x06000306 RID: 774 RVA: 0x00013EAC File Offset: 0x000120AC
        public void SaveSelfExtractor(string exeToGenerate, SelfExtractorSaveOptions options)
        {
            if (this._name == null)
            {
                this._writestream = null;
            }
            this._SavingSfx = true;
            this._name = exeToGenerate;
            if (Directory.Exists(this._name))
            {
                throw new ZipException("Bad Directory", new ArgumentException("That name specifies an existing directory. Please specify a filename.", "exeToGenerate"));
            }
            this._contentsChanged = true;
            this._fileAlreadyExists = File.Exists(this._name);
            this._SaveSfxStub(exeToGenerate, options);
            this.Save();
            this._SavingSfx = false;
        }

        // Token: 0x06000307 RID: 775 RVA: 0x00013F3C File Offset: 0x0001213C
        private static void ExtractResourceToFile(Assembly a, string resourceName, string filename)
        {
            byte[] bytes = new byte[1024];
            using (Stream instream = a.GetManifestResourceStream(resourceName))
            {
                if (instream == null)
                {
                    throw new ZipException(string.Format("missing resource '{0}'", resourceName));
                }
                using (FileStream outstream = File.OpenWrite(filename))
                {
                    int i;
                    do
                    {
                        i = instream.Read(bytes, 0, bytes.Length);
                        outstream.Write(bytes, 0, i);
                    }
                    while (i > 0);
                }
            }
        }

        // Token: 0x06000308 RID: 776 RVA: 0x00013FF0 File Offset: 0x000121F0
        private void _SaveSfxStub(string exeToGenerate, SelfExtractorSaveOptions options)
        {/*
            string stubExe = null;
            string unpackedResourceDir = null;
            string tmpDir = null;
            try
            {
                if (File.Exists(exeToGenerate))
                {
                    if (this.Verbose)
                    {
                        this.StatusMessageTextWriter.WriteLine("The existing file ({0}) will be overwritten.", exeToGenerate);
                    }
                }
                if (!exeToGenerate.EndsWith(".exe"))
                {
                    if (this.Verbose)
                    {
                        this.StatusMessageTextWriter.WriteLine("Warning: The generated self-extracting file will not have an .exe extension.");
                    }
                }
                tmpDir = (this.TempFileFolder ?? Path.GetDirectoryName(exeToGenerate));
                stubExe = ZipFile.GenerateTempPathname(tmpDir, "exe");
                Assembly a = typeof(ZipFile).Assembly;
                using (CSharpCodeProvider csharp = new CSharpCodeProvider())
                {
                    ZipFile.ExtractorSettings settings = null;
                    foreach (ZipFile.ExtractorSettings x in ZipFile.SettingsList)
                    {
                        if (x.Flavor == options.Flavor)
                        {
                            settings = x;
                            break;
                        }
                    }
                    if (settings == null)
                    {
                        throw new BadStateException(string.Format("While saving a Self-Extracting Zip, Cannot find that flavor ({0})?", options.Flavor));
                    }
                    CompilerParameters cp = new CompilerParameters();
                    cp.ReferencedAssemblies.Add(a.Location);
                    if (settings.ReferencedAssemblies != null)
                    {
                        foreach (string ra in settings.ReferencedAssemblies)
                        {
                            cp.ReferencedAssemblies.Add(ra);
                        }
                    }
                    cp.GenerateInMemory = false;
                    cp.GenerateExecutable = true;
                    cp.IncludeDebugInformation = false;
                    cp.CompilerOptions = "";
                    Assembly a2 = Assembly.GetExecutingAssembly();
                    StringBuilder sb = new StringBuilder();
                    string sourceFile = ZipFile.GenerateTempPathname(tmpDir, "cs");
                    using (ZipFile zip = ZipFile.Read(a2.GetManifestResourceStream("Ionic.Zip.Resources.ZippedResources.zip")))
                    {
                        unpackedResourceDir = ZipFile.GenerateTempPathname(tmpDir, "tmp");
                        if (string.IsNullOrEmpty(options.IconFile))
                        {
                            Directory.CreateDirectory(unpackedResourceDir);
                            ZipEntry e = zip["zippedFile.ico"];
                            if ((e.Attributes & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
                            {
                                e.Attributes ^= FileAttributes.ReadOnly;
                            }
                            e.Extract(unpackedResourceDir);
                            string nameOfIconFile = Path.Combine(unpackedResourceDir, "zippedFile.ico");
                            CompilerParameters compilerParameters = cp;
                            compilerParameters.CompilerOptions += string.Format("/win32icon:\"{0}\"", nameOfIconFile);
                        }
                        else
                        {
                            CompilerParameters compilerParameters2 = cp;
                            compilerParameters2.CompilerOptions += string.Format("/win32icon:\"{0}\"", options.IconFile);
                        }
                        cp.OutputAssembly = stubExe;
                        if (options.Flavor == SelfExtractorFlavor.WinFormsApplication)
                        {
                            CompilerParameters compilerParameters3 = cp;
                            compilerParameters3.CompilerOptions += " /target:winexe";
                        }
                        if (!string.IsNullOrEmpty(options.AdditionalCompilerSwitches))
                        {
                            CompilerParameters compilerParameters4 = cp;
                            compilerParameters4.CompilerOptions = compilerParameters4.CompilerOptions + " " + options.AdditionalCompilerSwitches;
                        }
                        if (string.IsNullOrEmpty(cp.CompilerOptions))
                        {
                            cp.CompilerOptions = null;
                        }
                        if (settings.CopyThroughResources != null && settings.CopyThroughResources.Count != 0)
                        {
                            if (!Directory.Exists(unpackedResourceDir))
                            {
                                Directory.CreateDirectory(unpackedResourceDir);
                            }
                            foreach (string re in settings.CopyThroughResources)
                            {
                                string filename = Path.Combine(unpackedResourceDir, re);
                                ZipFile.ExtractResourceToFile(a2, re, filename);
                                cp.EmbeddedResources.Add(filename);
                            }
                        }
                        cp.EmbeddedResources.Add(a.Location);
                        sb.Append("// " + Path.GetFileName(sourceFile) + "\n").Append("// --------------------------------------------\n//\n").Append("// This SFX source file was generated by DotNetZip ").Append(ZipFile.LibraryVersion.ToString()).Append("\n//         at ").Append(DateTime.Now.ToString("yyyy MMMM dd  HH:mm:ss")).Append("\n//\n// --------------------------------------------\n\n\n");
                        if (!string.IsNullOrEmpty(options.Description))
                        {
                            sb.Append("[assembly: System.Reflection.AssemblyTitle(\"" + options.Description.Replace("\"", "") + "\")]\n");
                        }
                        else
                        {
                            sb.Append("[assembly: System.Reflection.AssemblyTitle(\"DotNetZip SFX Archive\")]\n");
                        }
                        if (!string.IsNullOrEmpty(options.ProductVersion))
                        {
                            sb.Append("[assembly: System.Reflection.AssemblyInformationalVersion(\"" + options.ProductVersion.Replace("\"", "") + "\")]\n");
                        }
                        string copyright = string.IsNullOrEmpty(options.Copyright) ? "Extractor: Copyright © Dino Chiesa 2008-2011" : options.Copyright.Replace("\"", "");
                        if (!string.IsNullOrEmpty(options.ProductName))
                        {
                            sb.Append("[assembly: System.Reflection.AssemblyProduct(\"").Append(options.ProductName.Replace("\"", "")).Append("\")]\n");
                        }
                        else
                        {
                            sb.Append("[assembly: System.Reflection.AssemblyProduct(\"DotNetZip\")]\n");
                        }
                        sb.Append("[assembly: System.Reflection.AssemblyCopyright(\"" + copyright + "\")]\n").Append(string.Format("[assembly: System.Reflection.AssemblyVersion(\"{0}\")]\n", ZipFile.LibraryVersion.ToString()));
                        if (options.FileVersion != null)
                        {
                            sb.Append(string.Format("[assembly: System.Reflection.AssemblyFileVersion(\"{0}\")]\n", options.FileVersion.ToString()));
                        }
                        sb.Append("\n\n\n");
                        string extractLoc = options.DefaultExtractDirectory;
                        if (extractLoc != null)
                        {
                            extractLoc = extractLoc.Replace("\"", "").Replace("\\", "\\\\");
                        }
                        string postExCmdLine = options.PostExtractCommandLine;
                        if (postExCmdLine != null)
                        {
                            postExCmdLine = postExCmdLine.Replace("\\", "\\\\");
                            postExCmdLine = postExCmdLine.Replace("\"", "\\\"");
                        }
                        foreach (string rc in settings.ResourcesToCompile)
                        {
                            using (Stream s = zip[rc].OpenReader())
                            {
                                if (s == null)
                                {
                                    throw new ZipException(string.Format("missing resource '{0}'", rc));
                                }
                                using (StreamReader sr = new StreamReader(s))
                                {
                                    while (sr.Peek() >= 0)
                                    {
                                        string line = sr.ReadLine();
                                        if (extractLoc != null)
                                        {
                                            line = line.Replace("@@EXTRACTLOCATION", extractLoc);
                                        }
                                        line = line.Replace("@@REMOVE_AFTER_EXECUTE", options.RemoveUnpackedFilesAfterExecute.ToString());
                                        line = line.Replace("@@QUIET", options.Quiet.ToString());
                                        if (!string.IsNullOrEmpty(options.SfxExeWindowTitle))
                                        {
                                            line = line.Replace("@@SFX_EXE_WINDOW_TITLE", options.SfxExeWindowTitle);
                                        }
                                        line = line.Replace("@@EXTRACT_EXISTING_FILE", ((int)options.ExtractExistingFile).ToString());
                                        if (postExCmdLine != null)
                                        {
                                            line = line.Replace("@@POST_UNPACK_CMD_LINE", postExCmdLine);
                                        }
                                        sb.Append(line).Append("\n");
                                    }
                                }
                                sb.Append("\n\n");
                            }
                        }
                    }
                    string LiteralSource = sb.ToString();
                    CompilerResults cr = csharp.CompileAssemblyFromSource(cp, new string[]
                    {
                        LiteralSource
                    });
                    if (cr == null)
                    {
                        throw new SfxGenerationException("Cannot compile the extraction logic!");
                    }
                    if (this.Verbose)
                    {
                        foreach (string output in cr.Output)
                        {
                            this.StatusMessageTextWriter.WriteLine(output);
                        }
                    }
                    if (cr.Errors.Count != 0)
                    {
                        using (TextWriter tw = new StreamWriter(sourceFile))
                        {
                            tw.Write(LiteralSource);
                            tw.Write("\n\n\n// ------------------------------------------------------------------\n");
                            tw.Write("// Errors during compilation: \n//\n");
                            string p = Path.GetFileName(sourceFile);
                            foreach (object obj in cr.Errors)
                            {
                                CompilerError error = (CompilerError)obj;
                                tw.Write(string.Format("//   {0}({1},{2}): {3} {4}: {5}\n//\n", new object[]
                                {
                                    p,
                                    error.Line,
                                    error.Column,
                                    error.IsWarning ? "Warning" : "error",
                                    error.ErrorNumber,
                                    error.ErrorText
                                }));
                            }
                        }
                        throw new SfxGenerationException(string.Format("Errors compiling the extraction logic!  {0}", sourceFile));
                    }
                    this.OnSaveEvent(ZipProgressEventType.Saving_AfterCompileSelfExtractor);
                    using (Stream input = File.OpenRead(stubExe))
                    {
                        byte[] buffer = new byte[4000];
                        int i = 1;
                        while (i != 0)
                        {
                            i = input.Read(buffer, 0, buffer.Length);
                            if (i != 0)
                            {
                                this.WriteStream.Write(buffer, 0, i);
                            }
                        }
                    }
                }
                this.OnSaveEvent(ZipProgressEventType.Saving_AfterSaveTempArchive);
            }
            finally
            {
                try
                {
                    if (Directory.Exists(unpackedResourceDir))
                    {
                        try
                        {
                            Directory.Delete(unpackedResourceDir, true);
                        }
                        catch (IOException exc)
                        {
                            this.StatusMessageTextWriter.WriteLine("Warning: Exception: {0}", exc);
                        }
                    }
                    if (File.Exists(stubExe))
                    {
                        try
                        {
                            File.Delete(stubExe);
                        }
                        catch (IOException exc)
                        {
                            this.StatusMessageTextWriter.WriteLine("Warning: Exception: {0}", exc);
                        }
                    }
                }
                catch (IOException)
                {
                }
            }*/
        }

        // Token: 0x06000309 RID: 777 RVA: 0x00014C38 File Offset: 0x00012E38
        internal static string GenerateTempPathname(string dir, string extension)
        {
            string AppName = Assembly.GetExecutingAssembly().GetName().Name;
            string candidate;
            do
            {
                string uuid = Guid.NewGuid().ToString();
                string Name = string.Format("{0}-{1}-{2}.{3}", new object[]
                {
                    AppName,
                    DateTime.Now.ToString("yyyyMMMdd-HHmmss"),
                    uuid,
                    extension
                });
                candidate = Path.Combine(dir, Name);
            }
            while (File.Exists(candidate) || Directory.Exists(candidate));
            return candidate;
        }

        /// <summary>
        /// Generic IEnumerator support, for use of a ZipFile in an enumeration.
        /// </summary>
        ///
        /// <remarks>
        /// You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
        /// it is implicitly called when you use a <see langword="foreach" /> loop in C#, or a
        /// <c>For Each</c> loop in VB.NET.
        /// </remarks>
        ///
        /// <example>
        /// This example reads a zipfile of a given name, then enumerates the
        /// entries in that zip file, and displays the information about each
        /// entry on the Console.
        /// <code>
        /// using (ZipFile zip = ZipFile.Read(zipfile))
        /// {
        ///   bool header = true;
        ///   foreach (ZipEntry e in zip)
        ///   {
        ///     if (header)
        ///     {
        ///        System.Console.WriteLine("Zipfile: {0}", zip.Name);
        ///        System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
        ///        System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
        ///        System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
        ///        System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
        ///                     "Filename", "Modified", "Size", "Ratio", "Packed");
        ///        System.Console.WriteLine(new System.String('-', 72));
        ///        header = false;
        ///     }
        ///
        ///     System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
        ///                 e.FileName,
        ///                 e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
        ///                 e.UncompressedSize,
        ///                 e.CompressionRatio,
        ///                 e.CompressedSize);
        ///
        ///     e.Extract();
        ///   }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        ///   Dim ZipFileToExtract As String = "c:\foo.zip"
        ///   Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
        ///       Dim header As Boolean = True
        ///       Dim e As ZipEntry
        ///       For Each e In zip
        ///           If header Then
        ///               Console.WriteLine("Zipfile: {0}", zip.Name)
        ///               Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
        ///               Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
        ///               Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
        ///               Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
        ///                 "Filename", "Modified", "Size", "Ratio", "Packed" )
        ///               Console.WriteLine(New String("-"c, 72))
        ///               header = False
        ///           End If
        ///           Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
        ///             e.FileName, _
        ///             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
        ///             e.UncompressedSize, _
        ///             e.CompressionRatio, _
        ///             e.CompressedSize )
        ///           e.Extract
        ///       Next
        ///   End Using
        /// </code>
        /// </example>
        ///
        /// <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        // Token: 0x0600030A RID: 778 RVA: 0x00014E3C File Offset: 0x0001303C
        public IEnumerator<ZipEntry> GetEnumerator()
        {
            foreach (ZipEntry e in this._entries.Values)
            {
                yield return e;
            }
            yield break;
        }

        // Token: 0x0600030B RID: 779 RVA: 0x00014E5C File Offset: 0x0001305C
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// An IEnumerator, for use of a ZipFile in a foreach construct.
        /// </summary>
        ///
        /// <remarks>
        /// This method is included for COM support.  An application generally does not call
        /// this method directly.  It is called implicitly by COM clients when enumerating
        /// the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
        /// statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
        /// </remarks>
        ///
        /// <returns>
        /// The IEnumerator over the entries in the ZipFile.
        /// </returns>
        // Token: 0x0600030C RID: 780 RVA: 0x00014E74 File Offset: 0x00013074
        [DispId(-4)]
        public IEnumerator GetNewEnum()
        {
            return this.GetEnumerator();
        }

        // Token: 0x04000145 RID: 325
        private TextWriter _StatusMessageTextWriter;

        // Token: 0x04000146 RID: 326
        private bool _CaseSensitiveRetrieval;

        // Token: 0x04000147 RID: 327
        private Stream _readstream;

        // Token: 0x04000148 RID: 328
        private Stream _writestream;

        // Token: 0x04000149 RID: 329
        private ushort _versionMadeBy;

        // Token: 0x0400014A RID: 330
        private ushort _versionNeededToExtract;

        // Token: 0x0400014B RID: 331
        private uint _diskNumberWithCd;

        // Token: 0x0400014C RID: 332
        private int _maxOutputSegmentSize;

        // Token: 0x0400014D RID: 333
        private uint _numberOfSegmentsForMostRecentSave;

        // Token: 0x0400014E RID: 334
        private ZipErrorAction _zipErrorAction;

        // Token: 0x0400014F RID: 335
        private bool _disposed;

        // Token: 0x04000150 RID: 336
        private Dictionary<string, ZipEntry> _entries;

        // Token: 0x04000151 RID: 337
        private List<ZipEntry> _zipEntriesAsList;

        // Token: 0x04000152 RID: 338
        private string _name;

        // Token: 0x04000153 RID: 339
        private string _readName;

        // Token: 0x04000154 RID: 340
        private string _Comment;

        // Token: 0x04000155 RID: 341
        internal string _Password;

        // Token: 0x04000156 RID: 342
        private bool _emitNtfsTimes = true;

        // Token: 0x04000157 RID: 343
        private bool _emitUnixTimes;

        // Token: 0x04000158 RID: 344
        private CompressionStrategy _Strategy = CompressionStrategy.Default;

        // Token: 0x04000159 RID: 345
        private CompressionMethod _compressionMethod = CompressionMethod.Deflate;

        // Token: 0x0400015A RID: 346
        private bool _fileAlreadyExists;

        // Token: 0x0400015B RID: 347
        private string _temporaryFileName;

        // Token: 0x0400015C RID: 348
        private bool _contentsChanged;

        // Token: 0x0400015D RID: 349
        private bool _hasBeenSaved;

        // Token: 0x0400015E RID: 350
        private string _TempFileFolder;

        // Token: 0x0400015F RID: 351
        private bool _ReadStreamIsOurs = true;

        // Token: 0x04000160 RID: 352
        private object LOCK = new object();

        // Token: 0x04000161 RID: 353
        private bool _saveOperationCanceled;

        // Token: 0x04000162 RID: 354
        private bool _extractOperationCanceled;

        // Token: 0x04000163 RID: 355
        private bool _addOperationCanceled;

        // Token: 0x04000164 RID: 356
        private EncryptionAlgorithm _Encryption;

        // Token: 0x04000165 RID: 357
        private bool _JustSaved;

        // Token: 0x04000166 RID: 358
        private long _locEndOfCDS = -1L;

        // Token: 0x04000167 RID: 359
        private uint _OffsetOfCentralDirectory;

        // Token: 0x04000168 RID: 360
        private long _OffsetOfCentralDirectory64;

        // Token: 0x04000169 RID: 361
        private bool? _OutputUsesZip64;

        // Token: 0x0400016A RID: 362
        internal bool _inExtractAll;

        // Token: 0x0400016B RID: 363
        private Encoding _alternateEncoding = Encoding.GetEncoding("IBM437");

        // Token: 0x0400016C RID: 364
        private ZipOption _alternateEncodingUsage = ZipOption.Default;

        // Token: 0x0400016D RID: 365
        private static Encoding _defaultEncoding = Encoding.GetEncoding("IBM437");

        // Token: 0x0400016E RID: 366
        private int _BufferSize = ZipFile.BufferSizeDefault;

        // Token: 0x0400016F RID: 367
        internal ParallelDeflateOutputStream ParallelDeflater;

        // Token: 0x04000170 RID: 368
        private long _ParallelDeflateThreshold;

        // Token: 0x04000171 RID: 369
        private int _maxBufferPairs = 16;

        // Token: 0x04000172 RID: 370
        internal Zip64Option _zip64 = Zip64Option.Default;

        // Token: 0x04000173 RID: 371
        private bool _SavingSfx;

        /// <summary>
        ///   Default size of the buffer used for IO.
        /// </summary>
        // Token: 0x04000174 RID: 372
        public static readonly int BufferSizeDefault = 32768;

        // Token: 0x04000177 RID: 375
        private long _lengthOfReadStream = -99L;

        // Token: 0x0400017B RID: 379
        private static ZipFile.ExtractorSettings[] SettingsList = new ZipFile.ExtractorSettings[]
        {
            new ZipFile.ExtractorSettings
            {
                Flavor = SelfExtractorFlavor.WinFormsApplication,
                ReferencedAssemblies = new List<string>
                {
                    "System.dll",
                    "System.Windows.Forms.dll",
                    "System.Drawing.dll"
                },
                CopyThroughResources = new List<string>
                {
                    "Ionic.Zip.WinFormsSelfExtractorStub.resources",
                    "Ionic.Zip.Forms.PasswordDialog.resources",
                    "Ionic.Zip.Forms.ZipContentsDialog.resources"
                },
                ResourcesToCompile = new List<string>
                {
                    "WinFormsSelfExtractorStub.cs",
                    "WinFormsSelfExtractorStub.Designer.cs",
                    "PasswordDialog.cs",
                    "PasswordDialog.Designer.cs",
                    "ZipContentsDialog.cs",
                    "ZipContentsDialog.Designer.cs",
                    "FolderBrowserDialogEx.cs"
                }
            },
            new ZipFile.ExtractorSettings
            {
                Flavor = SelfExtractorFlavor.ConsoleApplication,
                ReferencedAssemblies = new List<string>
                {
                    "System.dll"
                },
                CopyThroughResources = null,
                ResourcesToCompile = new List<string>
                {
                    "CommandLineSelfExtractorStub.cs"
                }
            }
        };

        // Token: 0x0200003A RID: 58
        private class ExtractorSettings
        {
            // Token: 0x04000184 RID: 388
            public SelfExtractorFlavor Flavor;

            // Token: 0x04000185 RID: 389
            public List<string> ReferencedAssemblies;

            // Token: 0x04000186 RID: 390
            public List<string> CopyThroughResources;

            // Token: 0x04000187 RID: 391
            public List<string> ResourcesToCompile;
        }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   Provides a stream metaphor for reading zip files.
    /// </summary>
    ///
    /// <remarks>
    /// <para>
    ///   This class provides an alternative programming model for reading zip files to
    ///   the one enabled by the <see cref="T:Ionic.Zip.ZipFile" /> class.  Use this when reading zip
    ///   files, as an alternative to the <see cref="T:Ionic.Zip.ZipFile" /> class, when you would
    ///   like to use a Stream class to read the file.
    /// </para>
    ///
    /// <para>
    ///   Some application designs require a readable stream for input. This stream can
    ///   be used to read a zip file, and extract entries.
    /// </para>
    ///
    /// <para>
    ///   Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
    ///   to read and extract zip files.  Both of them support many of the common zip
    ///   features, including Unicode, different compression levels, and ZIP64.  The
    ///   programming models differ. For example, when extracting entries via calls to
    ///   the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
    ///   <c>ZipInputStream</c> class, the caller is responsible for creating the file,
    ///   writing the bytes into the file, setting the attributes on the file, and
    ///   setting the created, last modified, and last accessed timestamps on the
    ///   file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
    ///   <c>ZipInputStream</c> is generally recommended for when your application wants
    ///   to extract the data, without storing that data into a file.
    /// </para>
    ///
    /// <para>
    ///   Aside from the obvious differences in programming model, there are some
    ///   differences in capability between the <c>ZipFile</c> class and the
    ///   <c>ZipInputStream</c> class.
    /// </para>
    ///
    /// <list type="bullet">
    ///   <item>
    ///     <c>ZipFile</c> can be used to create or update zip files, or read and
    ///     extract zip files. <c>ZipInputStream</c> can be used only to read and
    ///     extract zip files. If you want to use a stream to create zip files, check
    ///     out the <see cref="T:Ionic.Zip.ZipOutputStream" />.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipInputStream</c> cannot read segmented or spanned
    ///     zip files.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipInputStream</c> will not read Zip file comments.
    ///   </item>
    ///
    ///   <item>
    ///     When reading larger files, <c>ZipInputStream</c> will always underperform
    ///     <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
    ///     zip file, while the <c>ZipFile</c> class reads the central directory of the
    ///     zip file.
    ///   </item>
    ///
    /// </list>
    ///
    /// </remarks>
    // Token: 0x02000005 RID: 5
    public class ZipInputStream : Stream
    {
        /// <summary>
        ///   Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   While the <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier
        ///   to use, this class provides an alternative to those
        ///   applications that want to read from a zipfile directly,
        ///   using a <see cref="T:System.IO.Stream" />.
        /// </para>
        ///
        /// <para>
        ///   Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
        ///   to read and extract zip files.  Both of them support many of the common zip
        ///   features, including Unicode, different compression levels, and ZIP64.  The
        ///   programming models differ. For example, when extracting entries via calls to
        ///   the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
        ///   <c>ZipInputStream</c> class, the caller is responsible for creating the file,
        ///   writing the bytes into the file, setting the attributes on the file, and
        ///   setting the created, last modified, and last accessed timestamps on the
        ///   file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
        ///   <c>ZipInputStream</c> is generally recommended for when your application wants
        ///   to extract the data, without storing that data into a file.
        /// </para>
        ///
        /// <para>
        ///   Aside from the obvious differences in programming model, there are some
        ///   differences in capability between the <c>ZipFile</c> class and the
        ///   <c>ZipInputStream</c> class.
        /// </para>
        ///
        /// <list type="bullet">
        ///   <item>
        ///   <c>ZipFile</c> can be used to create or update zip files, or read and extract
        ///   zip files. <c>ZipInputStream</c> can be used only to read and extract zip
        ///     files. If you want to use a stream to create zip files, check out the <see cref="T:Ionic.Zip.ZipOutputStream" />.
        ///   </item>
        ///
        ///   <item>
        ///     <c>ZipInputStream</c> cannot read segmented or spanned
        ///     zip files.
        ///   </item>
        ///
        ///   <item>
        ///     <c>ZipInputStream</c> will not read Zip file comments.
        ///   </item>
        ///
        ///   <item>
        ///     When reading larger files, <c>ZipInputStream</c> will always underperform
        ///     <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
        ///     zip file, while the <c>ZipFile</c> class reads the central directory of the
        ///     zip file.
        ///   </item>
        ///
        /// </list>
        ///
        /// </remarks>
        ///
        /// <param name="stream">
        ///   The stream to read. It must be readable. This stream will be closed at
        ///   the time the <c>ZipInputStream</c> is closed.
        /// </param>
        ///
        /// <example>
        ///
        ///   This example shows how to read a zip file, and extract entries, using the
        ///   <c>ZipInputStream</c> class.
        ///
        /// <code lang="C#">
        /// private void Unzip()
        /// {
        ///     byte[] buffer= new byte[2048];
        ///     int n;
        ///     using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
        ///     {
        ///         using (var input= new ZipInputStream(raw))
        ///         {
        ///             ZipEntry e;
        ///             while (( e = input.GetNextEntry()) != null)
        ///             {
        ///                 if (e.IsDirectory) continue;
        ///                 string outputPath = Path.Combine(extractDir, e.FileName);
        ///                 using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
        ///                 {
        ///                     while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
        ///                     {
        ///                         output.Write(buffer,0,n);
        ///                     }
        ///                 }
        ///             }
        ///         }
        ///     }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Private Sub UnZip()
        ///     Dim inputFileName As String = "MyArchive.zip"
        ///     Dim extractDir As String = "extract"
        ///     Dim buffer As Byte() = New Byte(2048) {}
        ///     Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
        ///         Using input As ZipInputStream = New ZipInputStream(raw)
        ///             Dim e As ZipEntry
        ///             Do While (Not e = input.GetNextEntry Is Nothing)
        ///                 If Not e.IsDirectory Then
        ///                     Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
        ///                                                            FileMode.Create, FileAccess.ReadWrite)
        ///                         Dim n As Integer
        ///                         Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
        ///                             output.Write(buffer, 0, n)
        ///                         Loop
        ///                     End Using
        ///                 End If
        ///             Loop
        ///         End Using
        ///     End Using
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x0600004C RID: 76 RVA: 0x00003094 File Offset: 0x00001294
        public ZipInputStream(Stream stream) : this(stream, false)
        {
        }

        /// <summary>
        ///   Create a <c>ZipInputStream</c>, given the name of an existing zip file.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   This constructor opens a <c>FileStream</c> for the given zipfile, and
        ///   wraps a <c>ZipInputStream</c> around that.  See the documentation for the
        ///   <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)" /> constructor for full details.
        /// </para>
        ///
        /// <para>
        ///   While the <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier
        ///   to use, this class provides an alternative to those
        ///   applications that want to read from a zipfile directly,
        ///   using a <see cref="T:System.IO.Stream" />.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="fileName">
        ///   The name of the filesystem file to read.
        /// </param>
        ///
        /// <example>
        ///
        ///   This example shows how to read a zip file, and extract entries, using the
        ///   <c>ZipInputStream</c> class.
        ///
        /// <code lang="C#">
        /// private void Unzip()
        /// {
        ///     byte[] buffer= new byte[2048];
        ///     int n;
        ///     using (var input= new ZipInputStream(inputFileName))
        ///     {
        ///         ZipEntry e;
        ///         while (( e = input.GetNextEntry()) != null)
        ///         {
        ///             if (e.IsDirectory) continue;
        ///             string outputPath = Path.Combine(extractDir, e.FileName);
        ///             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
        ///             {
        ///                 while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
        ///                 {
        ///                     output.Write(buffer,0,n);
        ///                 }
        ///             }
        ///         }
        ///     }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Private Sub UnZip()
        ///     Dim inputFileName As String = "MyArchive.zip"
        ///     Dim extractDir As String = "extract"
        ///     Dim buffer As Byte() = New Byte(2048) {}
        ///     Using input As ZipInputStream = New ZipInputStream(inputFileName)
        ///         Dim e As ZipEntry
        ///         Do While (Not e = input.GetNextEntry Is Nothing)
        ///             If Not e.IsDirectory Then
        ///                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
        ///                                                        FileMode.Create, FileAccess.ReadWrite)
        ///                     Dim n As Integer
        ///                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
        ///                         output.Write(buffer, 0, n)
        ///                     Loop
        ///                 End Using
        ///             End If
        ///         Loop
        ///     End Using
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x0600004D RID: 77 RVA: 0x000030A4 File Offset: 0x000012A4
        public ZipInputStream(string fileName)
        {
            Stream stream = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            this._Init(stream, false, fileName);
        }

        /// <summary>
        ///   Create a <c>ZipInputStream</c>, explicitly specifying whether to
        ///   keep the underlying stream open.
        /// </summary>
        ///
        /// <remarks>
        ///   See the documentation for the <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">ZipInputStream(Stream)</see>
        ///   constructor for a discussion of the class, and an example of how to use the class.
        /// </remarks>
        ///
        /// <param name="stream">
        ///   The stream to read from. It must be readable.
        /// </param>
        ///
        /// <param name="leaveOpen">
        ///   true if the application would like the stream
        ///   to remain open after the <c>ZipInputStream</c> has been closed.
        /// </param>
        // Token: 0x0600004E RID: 78 RVA: 0x000030CE File Offset: 0x000012CE
        public ZipInputStream(Stream stream, bool leaveOpen)
        {
            this._Init(stream, leaveOpen, null);
        }

        // Token: 0x0600004F RID: 79 RVA: 0x000030E4 File Offset: 0x000012E4
        private void _Init(Stream stream, bool leaveOpen, string name)
        {
            this._inputStream = stream;
            if (!this._inputStream.CanRead)
            {
                throw new ZipException("The stream must be readable.");
            }
            this._container = new ZipContainer(this);
            this._provisionalAlternateEncoding = Encoding.GetEncoding("IBM437");
            this._leaveUnderlyingStreamOpen = leaveOpen;
            this._findRequired = true;
            this._name = (name ?? "(stream)");
        }

        /// <summary>Provides a string representation of the instance.</summary>
        /// <remarks>
        ///   <para>
        ///     This can be useful for debugging purposes.
        ///   </para>
        /// </remarks>
        /// <returns>a string representation of the instance.</returns>
        // Token: 0x06000050 RID: 80 RVA: 0x00003150 File Offset: 0x00001350
        public override string ToString()
        {
            return string.Format("ZipInputStream::{0}(leaveOpen({1})))", this._name, this._leaveUnderlyingStreamOpen);
        }

        /// <summary>
        ///   The text encoding to use when reading entries into the zip archive, for
        ///   those entries whose filenames or comments cannot be encoded with the
        ///   default (IBM437) encoding.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
        ///   zip specification</see>, PKWare describes two options for encoding
        ///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
        ///   or libraries do not follow the specification, and instead encode
        ///   characters using the system default code page.  For example, WinRAR when
        ///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
        ///   (950) code page.  This behavior is contrary to the Zip specification, but
        ///   it occurs anyway.
        /// </para>
        ///
        /// <para>
        ///   When using DotNetZip to read zip archives that use something other than
        ///   UTF-8 or IBM437, set this property to specify the code page to use when
        ///   reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
        ///   file.
        /// </para>
        ///
        /// <para>
        ///   This property is "provisional". When the entry in the zip archive is not
        ///   explicitly marked as using UTF-8, then IBM437 is used to decode filenames
        ///   and comments. If a loss of data would result from using IBM436 -
        ///   specifically when encoding and decoding is not reflexive - the codepage
        ///   specified here is used. It is possible, therefore, to have a given entry
        ///   with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
        ///   the specified "provisional" codepage.
        /// </para>
        ///
        /// <para>
        ///   When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
        ///   is no standard way for the reader application - whether DotNetZip, WinZip,
        ///   WinRar, or something else - to know which codepage has been used for the
        ///   entries. Readers of zip files are not able to inspect the zip file and
        ///   determine the codepage that was used for the entries contained within it.
        ///   It is left to the application or user to determine the necessary codepage
        ///   when reading zip files encoded this way.  If you use an incorrect codepage
        ///   when reading a zipfile, you will get entries with filenames that are
        ///   incorrect, and the incorrect filenames may even contain characters that
        ///   are not legal for use within filenames in Windows. Extracting entries with
        ///   illegal characters in the filenames will lead to exceptions. It's too bad,
        ///   but this is just the way things are with code pages in zip files. Caveat
        ///   Emptor.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x1700002A RID: 42
        // (get) Token: 0x06000051 RID: 81 RVA: 0x00003180 File Offset: 0x00001380
        // (set) Token: 0x06000052 RID: 82 RVA: 0x00003198 File Offset: 0x00001398
        public Encoding ProvisionalAlternateEncoding
        {
            get
            {
                return this._provisionalAlternateEncoding;
            }
            set
            {
                this._provisionalAlternateEncoding = value;
            }
        }

        /// <summary>
        ///   Size of the work buffer to use for the ZLIB codec during decompression.
        /// </summary>
        ///
        /// <remarks>
        ///   Setting this affects the performance and memory efficiency of compression
        ///   and decompression.  For larger files, setting this to a larger size may
        ///   improve performance, but the exact numbers vary depending on available
        ///   memory, and a bunch of other variables. I don't have good firm
        ///   recommendations on how to set it.  You'll have to test it yourself. Or
        ///   just leave it alone and accept the default.
        /// </remarks>
        // Token: 0x1700002B RID: 43
        // (get) Token: 0x06000053 RID: 83 RVA: 0x000031A4 File Offset: 0x000013A4
        // (set) Token: 0x06000054 RID: 84 RVA: 0x000031BB File Offset: 0x000013BB
        public int CodecBufferSize { get; set; }

        /// <summary>
        ///   Sets the password to be used on the <c>ZipInputStream</c> instance.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When reading a zip archive, this password is used to read and decrypt the
        ///   entries that are encrypted within the zip file. When entries within a zip
        ///   file use different passwords, set the appropriate password for the entry
        ///   before the first call to <c>Read()</c> for each entry.
        /// </para>
        ///
        /// <para>
        ///   When reading an entry that is not encrypted, the value of this property is
        ///   ignored.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example uses the ZipInputStream to read and extract entries from a
        ///   zip file, using a potentially different password for each entry.
        ///
        /// <code lang="C#">
        /// byte[] buffer= new byte[2048];
        /// int n;
        /// using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
        /// {
        ///     using (var input= new ZipInputStream(raw))
        ///     {
        ///         ZipEntry e;
        ///         while (( e = input.GetNextEntry()) != null)
        ///         {
        ///             input.Password = PasswordForEntry(e.FileName);
        ///             if (e.IsDirectory) continue;
        ///             string outputPath = Path.Combine(_extractDir, e.FileName);
        ///             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
        ///             {
        ///                 while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
        ///                 {
        ///                     output.Write(buffer,0,n);
        ///                 }
        ///             }
        ///         }
        ///     }
        /// }
        ///
        /// </code>
        /// </example>
        // Token: 0x1700002C RID: 44
        // (set) Token: 0x06000055 RID: 85 RVA: 0x000031C4 File Offset: 0x000013C4
        public string Password
        {
            set
            {
                if (this._closed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                this._Password = value;
            }
        }

        // Token: 0x06000056 RID: 86 RVA: 0x000031F9 File Offset: 0x000013F9
        private void SetupStream()
        {
            this._crcStream = this._currentEntry.InternalOpenReader(this._Password);
            this._LeftToRead = this._crcStream.Length;
            this._needSetup = false;
        }

        // Token: 0x1700002D RID: 45
        // (get) Token: 0x06000057 RID: 87 RVA: 0x0000322C File Offset: 0x0000142C
        internal Stream ReadStream
        {
            get
            {
                return this._inputStream;
            }
        }

        /// <summary>
        ///   Read the data from the stream into the buffer.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The data for the zipentry will be decrypted and uncompressed, as
        ///   necessary, before being copied into the buffer.
        /// </para>
        ///
        /// <para>
        ///   You must set the <see cref="P:Ionic.Zip.ZipInputStream.Password" /> property before calling
        ///   <c>Read()</c> the first time for an encrypted entry.  To determine if an
        ///   entry is encrypted and requires a password, check the <see cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</see> property.
        /// </para>
        /// </remarks>
        ///
        /// <param name="buffer">The buffer to hold the data read from the stream.</param>
        /// <param name="offset">the offset within the buffer to copy the first byte read.</param>
        /// <param name="count">the number of bytes to read.</param>
        /// <returns>the number of bytes read, after decryption and decompression.</returns>
        // Token: 0x06000058 RID: 88 RVA: 0x00003244 File Offset: 0x00001444
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this._closed)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("The stream has been closed.");
            }
            if (this._needSetup)
            {
                this.SetupStream();
            }
            int result;
            if (this._LeftToRead == 0L)
            {
                result = 0;
            }
            else
            {
                int len = (this._LeftToRead > (long)count) ? count : ((int)this._LeftToRead);
                int i = this._crcStream.Read(buffer, offset, len);
                this._LeftToRead -= (long)i;
                if (this._LeftToRead == 0L)
                {
                    int CrcResult = this._crcStream.Crc;
                    this._currentEntry.VerifyCrcAfterExtract(CrcResult);
                    this._inputStream.Seek(this._endOfEntry, SeekOrigin.Begin);
                }
                result = i;
            }
            return result;
        }

        /// <summary>
        ///   Read the next entry from the zip file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Call this method just before calling <see cref="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)" />,
        ///   to position the pointer in the zip file to the next entry that can be
        ///   read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
        ///   data in the zip file, until <c>Read()</c> returns 0.
        /// </para>
        ///
        /// <para>
        ///   Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
        ///   stream is moved to the next entry in the zip file.  If you call <see cref="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)" />, and thus re-position the pointer within
        ///   the file, you will need to call <c>GetNextEntry()</c> again, to insure
        ///   that the file pointer is positioned at the beginning of a zip entry.
        /// </para>
        ///
        /// <para>
        ///   This method returns the <c>ZipEntry</c>. Using a stream approach, you will
        ///   read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
        ///   Alternatively, you can extract an entry into a file, or a stream, by
        ///   calling <see cref="M:Ionic.Zip.ZipEntry.Extract" />, or one of its siblings.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <returns>
        ///   The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
        ///   entries in the zip file.
        /// </returns>
        // Token: 0x06000059 RID: 89 RVA: 0x0000331C File Offset: 0x0000151C
        public ZipEntry GetNextEntry()
        {
            if (this._findRequired)
            {
                long d = SharedUtilities.FindSignature(this._inputStream, 67324752);
                if (d == -1L)
                {
                    return null;
                }
                this._inputStream.Seek(-4L, SeekOrigin.Current);
            }
            else if (this._firstEntry)
            {
                this._inputStream.Seek(this._endOfEntry, SeekOrigin.Begin);
            }
            this._currentEntry = ZipEntry.ReadEntry(this._container, !this._firstEntry);
            this._endOfEntry = this._inputStream.Position;
            this._firstEntry = true;
            this._needSetup = true;
            this._findRequired = false;
            return this._currentEntry;
        }

        /// <summary>
        ///   Dispose the stream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method disposes the ZipInputStream.  It may also close the
        ///   underlying stream, depending on which constructor was used.
        /// </para>
        ///
        /// <para>
        ///   Typically the application will call <c>Dispose()</c> implicitly, via
        ///   a <c>using</c> statement in C#, or a <c>Using</c> statement in VB.
        /// </para>
        ///
        ///   <para>
        ///     Application code won't call this code directly.  This method may
        ///     be invoked in two distinct scenarios.  If disposing == true, the
        ///     method has been called directly or indirectly by a user's code,
        ///     for example via the public Dispose() method. In this case, both
        ///     managed and unmanaged resources can be referenced and disposed.
        ///     If disposing == false, the method has been called by the runtime
        ///     from inside the object finalizer and this method should not
        ///     reference other objects; in that case only unmanaged resources
        ///     must be referenced or disposed.
        ///   </para>
        /// </remarks>
        ///
        /// <param name="disposing">
        ///   true if the Dispose method was invoked by user code.
        /// </param>
        // Token: 0x0600005A RID: 90 RVA: 0x000033D8 File Offset: 0x000015D8
        protected override void Dispose(bool disposing)
        {
            if (!this._closed)
            {
                if (disposing)
                {
                    if (this._exceptionPending)
                    {
                        return;
                    }
                    if (!this._leaveUnderlyingStreamOpen)
                    {
                        this._inputStream.Dispose();
                    }
                }
                this._closed = true;
            }
        }

        /// <summary>
        /// Always returns true.
        /// </summary>
        // Token: 0x1700002E RID: 46
        // (get) Token: 0x0600005B RID: 91 RVA: 0x00003430 File Offset: 0x00001630
        public override bool CanRead
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
        /// </summary>
        // Token: 0x1700002F RID: 47
        // (get) Token: 0x0600005C RID: 92 RVA: 0x00003444 File Offset: 0x00001644
        public override bool CanSeek
        {
            get
            {
                return this._inputStream.CanSeek;
            }
        }

        /// <summary>
        /// Always returns false.
        /// </summary>
        // Token: 0x17000030 RID: 48
        // (get) Token: 0x0600005D RID: 93 RVA: 0x00003464 File Offset: 0x00001664
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Returns the length of the underlying stream.
        /// </summary>
        // Token: 0x17000031 RID: 49
        // (get) Token: 0x0600005E RID: 94 RVA: 0x00003478 File Offset: 0x00001678
        public override long Length
        {
            get
            {
                return this._inputStream.Length;
            }
        }

        /// <summary>
        /// Gets or sets the position of the underlying stream.
        /// </summary>
        /// <remarks>
        /// Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
        /// </remarks>
        // Token: 0x17000032 RID: 50
        // (get) Token: 0x0600005F RID: 95 RVA: 0x00003498 File Offset: 0x00001698
        // (set) Token: 0x06000060 RID: 96 RVA: 0x000034B5 File Offset: 0x000016B5
        public override long Position
        {
            get
            {
                return this._inputStream.Position;
            }
            set
            {
                this.Seek(value, SeekOrigin.Begin);
            }
        }

        /// <summary>
        /// This is a no-op.
        /// </summary>
        // Token: 0x06000061 RID: 97 RVA: 0x000034C1 File Offset: 0x000016C1
        public override void Flush()
        {
            throw new NotSupportedException("Flush");
        }

        /// <summary>
        /// This method always throws a NotSupportedException.
        /// </summary>
        /// <param name="buffer">ignored</param>
        /// <param name="offset">ignored</param>
        /// <param name="count">ignored</param>
        // Token: 0x06000062 RID: 98 RVA: 0x000034CE File Offset: 0x000016CE
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("Write");
        }

        /// <summary>
        ///   This method seeks in the underlying stream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Call this method if you want to seek around within the zip file for random access.
        /// </para>
        ///
        /// <para>
        ///   Applications can intermix calls to <c>Seek()</c> with calls to <see cref="M:Ionic.Zip.ZipInputStream.GetNextEntry" />.  After a call to <c>Seek()</c>,
        ///   <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
        ///   the current position in the input stream. You're on your own for finding
        ///   out just where to seek in the stream, to get to the various entries.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="offset">the offset point to seek to</param>
        /// <param name="origin">the reference point from which to seek</param>
        /// <returns>The new position</returns>
        // Token: 0x06000063 RID: 99 RVA: 0x000034DC File Offset: 0x000016DC
        public override long Seek(long offset, SeekOrigin origin)
        {
            this._findRequired = true;
            return this._inputStream.Seek(offset, origin);
        }

        /// <summary>
        /// This method always throws a NotSupportedException.
        /// </summary>
        /// <param name="value">ignored</param>
        // Token: 0x06000064 RID: 100 RVA: 0x00003504 File Offset: 0x00001704
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        // Token: 0x0400002A RID: 42
        private Stream _inputStream;

        // Token: 0x0400002B RID: 43
        private Encoding _provisionalAlternateEncoding;

        // Token: 0x0400002C RID: 44
        private ZipEntry _currentEntry;

        // Token: 0x0400002D RID: 45
        private bool _firstEntry;

        // Token: 0x0400002E RID: 46
        private bool _needSetup;

        // Token: 0x0400002F RID: 47
        private ZipContainer _container;

        // Token: 0x04000030 RID: 48
        private CrcCalculatorStream _crcStream;

        // Token: 0x04000031 RID: 49
        private long _LeftToRead;

        // Token: 0x04000032 RID: 50
        internal string _Password;

        // Token: 0x04000033 RID: 51
        private long _endOfEntry;

        // Token: 0x04000034 RID: 52
        private string _name;

        // Token: 0x04000035 RID: 53
        private bool _leaveUnderlyingStreamOpen;

        // Token: 0x04000036 RID: 54
        private bool _closed;

        // Token: 0x04000037 RID: 55
        private bool _findRequired;

        // Token: 0x04000038 RID: 56
        private bool _exceptionPending;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///  An enum representing the values on a three-way toggle switch
    ///  for various options in the library. This might be used to
    ///  specify whether to employ a particular text encoding, or to use
    ///  ZIP64 extensions, or some other option.
    /// </summary>
    // Token: 0x0200003C RID: 60
    public enum ZipOption
    {
        /// <summary>
        /// The default behavior. This is the same as "Never".
        /// (For COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x0400018E RID: 398
        Default,
        /// <summary>
        /// Never use the associated option.
        /// (For COM clients, this is a 0 (zero).)
        /// </summary>
        // Token: 0x0400018F RID: 399
        Never = 0,
        /// <summary>
        /// Use the associated behavior "as necessary."
        /// (For COM clients, this is a 1.)
        /// </summary>
        // Token: 0x04000190 RID: 400
        AsNecessary,
        /// <summary>
        /// Use the associated behavior Always, whether necessary or not.
        /// (For COM clients, this is a 2.)
        /// </summary>
        // Token: 0x04000191 RID: 401
        Always
    }
}


namespace Ionic.Zip
{
    // Token: 0x0200003F RID: 63
    internal static class ZipOutput
    {
        // Token: 0x06000316 RID: 790 RVA: 0x00015060 File Offset: 0x00013260
        public static bool WriteCentralDirectoryStructure(Stream s, ICollection<ZipEntry> entries, uint numSegments, Zip64Option zip64, string comment, ZipContainer container)
        {
            unchecked
            {
                ZipSegmentedStream zss = s as ZipSegmentedStream;
                if (zss != null)
                {
                    zss.ContiguousWrite = true;
                }
                long aLength = 0L;
                using (MemoryStream ms = new MemoryStream())
                {
                    foreach (ZipEntry e in entries)
                    {
                        if (e.IncludedInMostRecentSave)
                        {
                            e.WriteCentralDirectoryEntry(ms);
                        }
                    }
                    byte[] a = ms.ToArray();
                    s.Write(a, 0, a.Length);
                    aLength = (long)a.Length;
                }
                CountingStream output = s as CountingStream;
                long Finish = (output != null) ? output.ComputedPosition : s.Position;
                long Start = Finish - aLength;
                uint startSegment = (zss != null) ? zss.CurrentSegment : 0u;
                long SizeOfCentralDirectory = Finish - Start;
                int countOfEntries = ZipOutput.CountEntries(entries);
                bool needZip64CentralDirectory = false;// zip64 == Zip64Option.Always || countOfEntries >= 65535 || SizeOfCentralDirectory > (long)((ulong)-1) || Start > (long)((ulong)-1);
                byte[] a2;
                if (needZip64CentralDirectory)
                {
                    if (zip64 == Zip64Option.Default)
                    {
                        StackFrame sf = new StackFrame(1);
                        if (sf.GetMethod().DeclaringType == typeof(ZipFile))
                        {
                            throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");
                        }
                        throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");
                    }
                    else
                    {
                        byte[] a = ZipOutput.GenZip64EndOfCentralDirectory(Start, Finish, countOfEntries, numSegments);
                        a2 = ZipOutput.GenCentralDirectoryFooter(Start, Finish, zip64, countOfEntries, comment, container);
                        if (startSegment != 0u)
                        {
                            uint thisSegment = zss.ComputeSegment(a.Length + a2.Length);
                            int i = 16;
                            Array.Copy(BitConverter.GetBytes(thisSegment), 0, a, i, 4);
                            i += 4;
                            Array.Copy(BitConverter.GetBytes(thisSegment), 0, a, i, 4);
                            i = 60;
                            Array.Copy(BitConverter.GetBytes(thisSegment), 0, a, i, 4);
                            i += 4;
                            i += 8;
                            Array.Copy(BitConverter.GetBytes(thisSegment), 0, a, i, 4);
                        }
                        s.Write(a, 0, a.Length);
                    }
                }
                else
                {
                    a2 = ZipOutput.GenCentralDirectoryFooter(Start, Finish, zip64, countOfEntries, comment, container);
                }
                if (startSegment != 0u)
                {
                    ushort thisSegment2 = (ushort)zss.ComputeSegment(a2.Length);
                    int i = 4;
                    Array.Copy(BitConverter.GetBytes(thisSegment2), 0, a2, i, 2);
                    i += 2;
                    Array.Copy(BitConverter.GetBytes(thisSegment2), 0, a2, i, 2);
                    i += 2;
                }
                s.Write(a2, 0, a2.Length);
                if (zss != null)
                {
                    zss.ContiguousWrite = false;
                }
                return needZip64CentralDirectory;
            }
        }

        // Token: 0x06000317 RID: 791 RVA: 0x0001532C File Offset: 0x0001352C
        private static Encoding GetEncoding(ZipContainer container, string t)
        {
            switch (container.AlternateEncodingUsage)
            {
                case ZipOption.Default:
                    return container.DefaultEncoding;
                case ZipOption.Always:
                    return container.AlternateEncoding;
            }
            Encoding e = container.DefaultEncoding;
            Encoding result;
            if (t == null)
            {
                result = e;
            }
            else
            {
                byte[] bytes = e.GetBytes(t);
                string t2 = e.GetString(bytes, 0, bytes.Length);
                if (t2.Equals(t))
                {
                    result = e;
                }
                else
                {
                    result = container.AlternateEncoding;
                }
            }
            return result;
        }

        // Token: 0x06000318 RID: 792 RVA: 0x000153B4 File Offset: 0x000135B4
        private static byte[] GenCentralDirectoryFooter(long StartOfCentralDirectory, long EndOfCentralDirectory, Zip64Option zip64, int entryCount, string comment, ZipContainer container)
        {
            unchecked
            {
                Encoding encoding = ZipOutput.GetEncoding(container, comment);
                int bufferLength = 22;
                byte[] block = null;
                short commentLength = 0;
                if (comment != null && comment.Length != 0)
                {
                    block = encoding.GetBytes(comment);
                    commentLength = (short)block.Length;
                }
                bufferLength += (int)commentLength;
                byte[] bytes = new byte[bufferLength];
                int i = 0;
                byte[] sig = BitConverter.GetBytes(101010256u);
                Array.Copy(sig, 0, bytes, i, 4);
                i += 4;
                bytes[i++] = 0;
                bytes[i++] = 0;
                bytes[i++] = 0;
                bytes[i++] = 0;
                if (entryCount >= 65535 || zip64 == Zip64Option.Always)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        bytes[i++] = byte.MaxValue;
                    }
                }
                else
                {
                    bytes[i++] = (byte)(entryCount & 255);
                    bytes[i++] = (byte)((entryCount & 65280) >> 8);
                    bytes[i++] = (byte)(entryCount & 255);
                    bytes[i++] = (byte)((entryCount & 65280) >> 8);
                }
                long SizeOfCentralDirectory = EndOfCentralDirectory - StartOfCentralDirectory;
                if (SizeOfCentralDirectory >= (long)((ulong)-1) || StartOfCentralDirectory >= (long)((ulong)-1))
                {
                    for (int j = 0; j < 8; j++)
                    {
                        bytes[i++] = byte.MaxValue;
                    }
                }
                else
                {
                    bytes[i++] = (byte)(SizeOfCentralDirectory & 255L);
                    bytes[i++] = (byte)((SizeOfCentralDirectory & 65280L) >> 8);
                    bytes[i++] = (byte)((SizeOfCentralDirectory & 16711680L) >> 16);
                    bytes[i++] = (byte)((SizeOfCentralDirectory & (long)((ulong)-16777216)) >> 24);
                    bytes[i++] = (byte)(StartOfCentralDirectory & 255L);
                    bytes[i++] = (byte)((StartOfCentralDirectory & 65280L) >> 8);
                    bytes[i++] = (byte)((StartOfCentralDirectory & 16711680L) >> 16);
                    bytes[i++] = (byte)((StartOfCentralDirectory & (long)((ulong)-16777216)) >> 24);
                }
                if (comment == null || comment.Length == 0)
                {
                    bytes[i++] = 0;
                    bytes[i++] = 0;
                }
                else
                {
                    if ((int)commentLength + i + 2 > bytes.Length)
                    {
                        commentLength = (short)(bytes.Length - i - 2);
                    }
                    bytes[i++] = (byte)(commentLength & 255);
                    bytes[i++] = (byte)(((int)commentLength & 65280) >> 8);
                    if (commentLength != 0)
                    {
                        int j = 0;
                        while (j < (int)commentLength && i + j < bytes.Length)
                        {
                            bytes[i + j] = block[j];
                            j++;
                        }
                        i += j;
                    }
                }
                return bytes;
            }
        }

        // Token: 0x06000319 RID: 793 RVA: 0x000156A0 File Offset: 0x000138A0
        private static byte[] GenZip64EndOfCentralDirectory(long StartOfCentralDirectory, long EndOfCentralDirectory, int entryCount, uint numSegments)
        {
            byte[] bytes = new byte[76];
            int i = 0;
            byte[] sig = BitConverter.GetBytes(101075792u);
            Array.Copy(sig, 0, bytes, i, 4);
            i += 4;
            long DataSize = 44L;
            Array.Copy(BitConverter.GetBytes(DataSize), 0, bytes, i, 8);
            i += 8;
            bytes[i++] = 45;
            bytes[i++] = 0;
            bytes[i++] = 45;
            bytes[i++] = 0;
            for (int j = 0; j < 8; j++)
            {
                bytes[i++] = 0;
            }
            long numberOfEntries = (long)entryCount;
            Array.Copy(BitConverter.GetBytes(numberOfEntries), 0, bytes, i, 8);
            i += 8;
            Array.Copy(BitConverter.GetBytes(numberOfEntries), 0, bytes, i, 8);
            i += 8;
            long SizeofCentraldirectory = EndOfCentralDirectory - StartOfCentralDirectory;
            Array.Copy(BitConverter.GetBytes(SizeofCentraldirectory), 0, bytes, i, 8);
            i += 8;
            Array.Copy(BitConverter.GetBytes(StartOfCentralDirectory), 0, bytes, i, 8);
            i += 8;
            sig = BitConverter.GetBytes(117853008u);
            Array.Copy(sig, 0, bytes, i, 4);
            i += 4;
            uint x2 = (numSegments == 0u) ? 0u : (numSegments - 1u);
            Array.Copy(BitConverter.GetBytes(x2), 0, bytes, i, 4);
            i += 4;
            Array.Copy(BitConverter.GetBytes(EndOfCentralDirectory), 0, bytes, i, 8);
            i += 8;
            Array.Copy(BitConverter.GetBytes(numSegments), 0, bytes, i, 4);
            i += 4;
            return bytes;
        }

        // Token: 0x0600031A RID: 794 RVA: 0x000157F0 File Offset: 0x000139F0
        private static int CountEntries(ICollection<ZipEntry> _entries)
        {
            int count = 0;
            foreach (ZipEntry entry in _entries)
            {
                if (entry.IncludedInMostRecentSave)
                {
                    count++;
                }
            }
            return count;
        }
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   Provides a stream metaphor for generating zip files.
    /// </summary>
    ///
    /// <remarks>
    /// <para>
    ///   This class writes zip files, as defined in the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
    ///   for zip files described by PKWare</see>.  The compression for this
    ///   implementation is provided by a managed-code version of Zlib, included with
    ///   DotNetZip in the classes in the Ionic.Zlib namespace.
    /// </para>
    ///
    /// <para>
    ///   This class provides an alternative programming model to the one enabled by the
    ///   <see cref="T:Ionic.Zip.ZipFile" /> class. Use this when creating zip files, as an
    ///   alternative to the <see cref="T:Ionic.Zip.ZipFile" /> class, when you would like to use a
    ///   <c>Stream</c> type to write the zip file.
    /// </para>
    ///
    /// <para>
    ///   Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
    ///   to create zip files. Both of them support many of the common zip features,
    ///   including Unicode, different compression levels, and ZIP64.   They provide
    ///   very similar performance when creating zip files.
    /// </para>
    ///
    /// <para>
    ///   The <c>ZipFile</c> class is generally easier to use than
    ///   <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
    ///   example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
    ///   <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
    ///   responsible for opening the file, reading the bytes from the file, writing
    ///   those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
    ///   <c>ZipEntry</c>, and setting the created, last modified, and last accessed
    ///   timestamps on the zip entry. All of these things are done automatically by a
    ///   call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
    ///   For this reason, the <c>ZipOutputStream</c> is generally recommended for use
    ///   only when your application emits arbitrary data, not necessarily data from a
    ///   filesystem file, directly into a zip file, and does so using a <c>Stream</c>
    ///   metaphor.
    /// </para>
    ///
    /// <para>
    ///   Aside from the differences in programming model, there are other
    ///   differences in capability between the two classes.
    /// </para>
    ///
    /// <list type="bullet">
    ///   <item>
    ///     <c>ZipFile</c> can be used to read and extract zip files, in addition to
    ///     creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
    ///     to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream" /> class.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipOutputStream</c> does not support the creation of segmented or spanned
    ///     zip files.
    ///   </item>
    ///
    ///   <item>
    ///     <c>ZipOutputStream</c> cannot produce a self-extracting archive.
    ///   </item>
    /// </list>
    ///
    /// <para>
    ///   Be aware that the <c>ZipOutputStream</c> class implements the <see cref="T:System.IDisposable" /> interface.  In order for
    ///   <c>ZipOutputStream</c> to produce a valid zip file, you use use it within
    ///   a using clause (<c>Using</c> in VB), or call the <c>Dispose()</c> method
    ///   explicitly.  See the examples for how to employ a using clause.
    /// </para>
    ///
    /// <para>
    ///   Also, a note regarding compression performance: On the desktop .NET
    ///   Framework, DotNetZip can use a multi-threaded compression implementation
    ///   that provides significant speed increases on large files, over 300k or so,
    ///   at the cost of increased memory use at runtime.  (The output of the
    ///   compression is almost exactly the same size).  But, the multi-threaded
    ///   approach incurs a performance hit on smaller files. There's no way for the
    ///   ZipOutputStream to know whether parallel compression will be beneficial,
    ///   because the ZipOutputStream does not know how much data you will write
    ///   through the stream.  You may wish to set the <see cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold" /> property to zero, if you are compressing
    ///   large files through <c>ZipOutputStream</c>.  This will cause parallel
    ///   compression to be used, always.
    /// </para>
    /// </remarks>
    // Token: 0x02000003 RID: 3
    public class ZipOutputStream : Stream
    {
        /// <summary>
        ///   Create a ZipOutputStream, wrapping an existing stream.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier to use when creating
        ///   zip files. The ZipOutputStream offers a different metaphor for creating a
        ///   zip file, based on the <see cref="T:System.IO.Stream" /> class.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="stream">
        /// The stream to wrap. It must be writable. This stream will be closed at
        /// the time the ZipOutputStream is closed.
        /// </param>
        ///
        /// <example>
        ///
        ///   This example shows how to create a zip file, using the
        ///   ZipOutputStream class.
        ///
        /// <code lang="C#">
        /// private void Zipup()
        /// {
        ///     if (filesToZip.Count == 0)
        ///     {
        ///         System.Console.WriteLine("Nothing to do.");
        ///         return;
        ///     }
        ///
        ///     using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
        ///     {
        ///         using (var output= new ZipOutputStream(raw))
        ///         {
        ///             output.Password = "VerySecret!";
        ///             output.Encryption = EncryptionAlgorithm.WinZipAes256;
        ///
        ///             foreach (string inputFileName in filesToZip)
        ///             {
        ///                 System.Console.WriteLine("file: {0}", inputFileName);
        ///
        ///                 output.PutNextEntry(inputFileName);
        ///                 using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
        ///                 {
        ///                     byte[] buffer= new byte[2048];
        ///                     int n;
        ///                     while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
        ///                     {
        ///                         output.Write(buffer,0,n);
        ///                     }
        ///                 }
        ///             }
        ///         }
        ///     }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Private Sub Zipup()
        ///     Dim outputFileName As String = "XmlData.zip"
        ///     Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
        ///     If (filesToZip.Length = 0) Then
        ///         Console.WriteLine("Nothing to do.")
        ///     Else
        ///         Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
        ///             Using output As ZipOutputStream = New ZipOutputStream(raw)
        ///                 output.Password = "VerySecret!"
        ///                 output.Encryption = EncryptionAlgorithm.WinZipAes256
        ///                 Dim inputFileName As String
        ///                 For Each inputFileName In filesToZip
        ///                     Console.WriteLine("file: {0}", inputFileName)
        ///                     output.PutNextEntry(inputFileName)
        ///                     Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
        ///                         Dim n As Integer
        ///                         Dim buffer As Byte() = New Byte(2048) {}
        ///                         Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
        ///                             output.Write(buffer, 0, n)
        ///                         Loop
        ///                     End Using
        ///                 Next
        ///             End Using
        ///         End Using
        ///     End If
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x06000001 RID: 1 RVA: 0x000020D0 File Offset: 0x000002D0
        public ZipOutputStream(Stream stream) : this(stream, false)
        {
        }

        /// <summary>
        ///   Create a ZipOutputStream that writes to a filesystem file.
        /// </summary>
        ///
        /// <remarks>
        ///   The <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier to use when creating
        ///   zip files. The ZipOutputStream offers a different metaphor for creating a
        ///   zip file, based on the <see cref="T:System.IO.Stream" /> class.
        /// </remarks>
        ///
        /// <param name="fileName">
        ///   The name of the zip file to create.
        /// </param>
        ///
        /// <example>
        ///
        ///   This example shows how to create a zip file, using the
        ///   ZipOutputStream class.
        ///
        /// <code lang="C#">
        /// private void Zipup()
        /// {
        ///     if (filesToZip.Count == 0)
        ///     {
        ///         System.Console.WriteLine("Nothing to do.");
        ///         return;
        ///     }
        ///
        ///     using (var output= new ZipOutputStream(outputFileName))
        ///     {
        ///         output.Password = "VerySecret!";
        ///         output.Encryption = EncryptionAlgorithm.WinZipAes256;
        ///
        ///         foreach (string inputFileName in filesToZip)
        ///         {
        ///             System.Console.WriteLine("file: {0}", inputFileName);
        ///
        ///             output.PutNextEntry(inputFileName);
        ///             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
        ///                                          FileShare.Read | FileShare.Write ))
        ///             {
        ///                 byte[] buffer= new byte[2048];
        ///                 int n;
        ///                 while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
        ///                 {
        ///                     output.Write(buffer,0,n);
        ///                 }
        ///             }
        ///         }
        ///     }
        /// }
        /// </code>
        ///
        /// <code lang="VB">
        /// Private Sub Zipup()
        ///     Dim outputFileName As String = "XmlData.zip"
        ///     Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
        ///     If (filesToZip.Length = 0) Then
        ///         Console.WriteLine("Nothing to do.")
        ///     Else
        ///         Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
        ///             output.Password = "VerySecret!"
        ///             output.Encryption = EncryptionAlgorithm.WinZipAes256
        ///             Dim inputFileName As String
        ///             For Each inputFileName In filesToZip
        ///                 Console.WriteLine("file: {0}", inputFileName)
        ///                 output.PutNextEntry(inputFileName)
        ///                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
        ///                     Dim n As Integer
        ///                     Dim buffer As Byte() = New Byte(2048) {}
        ///                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
        ///                         output.Write(buffer, 0, n)
        ///                     Loop
        ///                 End Using
        ///             Next
        ///         End Using
        ///     End If
        /// End Sub
        /// </code>
        /// </example>
        // Token: 0x06000002 RID: 2 RVA: 0x000020E0 File Offset: 0x000002E0
        public ZipOutputStream(string fileName)
        {
            this._alternateEncodingUsage = ZipOption.Default;
            this._alternateEncoding = Encoding.GetEncoding("IBM437");
            this._maxBufferPairs = 16;
            //base..ctor();
            Stream stream = File.Open(fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.None);
            this._Init(stream, false, fileName);
        }

        /// <summary>
        ///   Create a ZipOutputStream.
        /// </summary>
        ///
        /// <remarks>
        ///   See the documentation for the <see cref="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">ZipOutputStream(Stream)</see>
        ///   constructor for an example.
        /// </remarks>
        ///
        /// <param name="stream">
        ///   The stream to wrap. It must be writable.
        /// </param>
        ///
        /// <param name="leaveOpen">
        ///   true if the application would like the stream
        ///   to remain open after the <c>ZipOutputStream</c> has been closed.
        /// </param>
        // Token: 0x06000003 RID: 3 RVA: 0x00002129 File Offset: 0x00000329
        public ZipOutputStream(Stream stream, bool leaveOpen)
        {
            this._alternateEncodingUsage = ZipOption.Default;
            this._alternateEncoding = Encoding.GetEncoding("IBM437");
            this._maxBufferPairs = 16;

            this._Init(stream, leaveOpen, null);
        }

        // Token: 0x06000004 RID: 4 RVA: 0x00002160 File Offset: 0x00000360
        private void _Init(Stream stream, bool leaveOpen, string name)
        {
            this._outputStream = (stream.CanRead ? stream : new CountingStream(stream));
            this.CompressionLevel = CompressionLevel.Default;
            this.CompressionMethod = CompressionMethod.Deflate;
            this._encryption = EncryptionAlgorithm.None;
            this._entriesWritten = new Dictionary<string, ZipEntry>(StringComparer.Ordinal);
            this._zip64 = Zip64Option.Default;
            this._leaveUnderlyingStreamOpen = leaveOpen;
            this.Strategy = CompressionStrategy.Default;
            this._name = (name ?? "(stream)");
            this.ParallelDeflateThreshold = -1L;
        }

        /// <summary>Provides a string representation of the instance.</summary>
        /// <remarks>
        ///   <para>
        ///     This can be useful for debugging purposes.
        ///   </para>
        /// </remarks>
        /// <returns>a string representation of the instance.</returns>
        // Token: 0x06000005 RID: 5 RVA: 0x000021DC File Offset: 0x000003DC
        public override string ToString()
        {
            return string.Format("ZipOutputStream::{0}(leaveOpen({1})))", this._name, this._leaveUnderlyingStreamOpen);
        }

        /// <summary>
        ///   Sets the password to be used on the <c>ZipOutputStream</c> instance.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   When writing a zip archive, this password is applied to the entries, not
        ///   to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
        ///   written to the <c>ZipOutputStream</c>.
        /// </para>
        ///
        /// <para>
        ///   Using a password does not encrypt or protect the "directory" of the
        ///   archive - the list of entries contained in the archive.  If you set the
        ///   <c>Password</c> property, the password actually applies to individual
        ///   entries that are added to the archive, subsequent to the setting of this
        ///   property.  The list of filenames in the archive that is eventually created
        ///   will appear in clear text, but the contents of the individual files are
        ///   encrypted.  This is how Zip encryption works.
        /// </para>
        ///
        /// <para>
        ///   If you set this property, and then add a set of entries to the archive via
        ///   calls to <c>PutNextEntry</c>, then each entry is encrypted with that
        ///   password.  You may also want to change the password between adding
        ///   different entries. If you set the password, add an entry, then set the
        ///   password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
        ///   first entry is encrypted and the second is not.
        /// </para>
        ///
        /// <para>
        ///   When setting the <c>Password</c>, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" /> property, to specify how to encrypt the entries added
        ///   to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
        ///   set <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.
        ///   This encryption is relatively weak but is very interoperable. If
        ///   you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
        ///   <c>Encryption</c> is reset to None.
        /// </para>
        ///
        /// <para>
        ///   Special case: if you wrap a ZipOutputStream around a non-seekable stream,
        ///   and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
        ///   <c>PutNextEntry()</c> following the entry will throw an exception.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000001 RID: 1
        // (set) Token: 0x06000006 RID: 6 RVA: 0x0000220C File Offset: 0x0000040C
        public string Password
        {
            set
            {
                if (this._disposed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                this._password = value;
                if (this._password == null)
                {
                    this._encryption = EncryptionAlgorithm.None;
                }
                else if (this._encryption == EncryptionAlgorithm.None)
                {
                    this._encryption = EncryptionAlgorithm.PkzipWeak;
                }
            }
        }

        /// <summary>
        ///   The Encryption to use for entries added to the <c>ZipOutputStream</c>.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The specified Encryption is applied to the entries subsequently
        ///   written to the <c>ZipOutputStream</c> instance.
        /// </para>
        ///
        /// <para>
        ///   If you set this to something other than
        ///   EncryptionAlgorithm.None, you will also need to set the
        ///   <see cref="P:Ionic.Zip.ZipOutputStream.Password" /> to a non-null, non-empty value in
        ///   order to actually get encryption on the entry.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipOutputStream.Password">ZipOutputStream.Password</seealso>
        /// <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        // Token: 0x17000002 RID: 2
        // (get) Token: 0x06000007 RID: 7 RVA: 0x00002278 File Offset: 0x00000478
        // (set) Token: 0x06000008 RID: 8 RVA: 0x00002290 File Offset: 0x00000490
        public EncryptionAlgorithm Encryption
        {
            get
            {
                return this._encryption;
            }
            set
            {
                if (this._disposed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                if (value == EncryptionAlgorithm.Unsupported)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("You may not set Encryption to that value.");
                }
                this._encryption = value;
            }
        }

        /// <summary>
        ///   Size of the work buffer to use for the ZLIB codec during compression.
        /// </summary>
        ///
        /// <remarks>
        ///   Setting this may affect performance.  For larger files, setting this to a
        ///   larger size may improve performance, but I'm not sure.  Sorry, I don't
        ///   currently have good recommendations on how to set it.  You can test it if
        ///   you like.
        /// </remarks>
        // Token: 0x17000003 RID: 3
        // (get) Token: 0x06000009 RID: 9 RVA: 0x000022E4 File Offset: 0x000004E4
        // (set) Token: 0x0600000A RID: 10 RVA: 0x000022FB File Offset: 0x000004FB
        public int CodecBufferSize { get; set; }

        /// <summary>
        ///   The compression strategy to use for all entries.
        /// </summary>
        ///
        /// <remarks>
        ///   Set the Strategy used by the ZLIB-compatible compressor, when compressing
        ///   data for the entries in the zip archive. Different compression strategies
        ///   work better on different sorts of data. The strategy parameter can affect
        ///   the compression ratio and the speed of compression but not the correctness
        ///   of the compresssion.  For more information see <see cref="T:Ionic.Zlib.CompressionStrategy" />.
        /// </remarks>
        // Token: 0x17000004 RID: 4
        // (get) Token: 0x0600000B RID: 11 RVA: 0x00002304 File Offset: 0x00000504
        // (set) Token: 0x0600000C RID: 12 RVA: 0x0000231B File Offset: 0x0000051B
        public CompressionStrategy Strategy { get; set; }

        /// <summary>
        ///   The type of timestamp attached to the ZipEntry.
        /// </summary>
        ///
        /// <remarks>
        ///   Set this in order to specify the kind of timestamp that should be emitted
        ///   into the zip file for each entry.
        /// </remarks>
        // Token: 0x17000005 RID: 5
        // (get) Token: 0x0600000D RID: 13 RVA: 0x00002324 File Offset: 0x00000524
        // (set) Token: 0x0600000E RID: 14 RVA: 0x0000233C File Offset: 0x0000053C
        public ZipEntryTimestamp Timestamp
        {
            get
            {
                return this._timestamp;
            }
            set
            {
                if (this._disposed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                this._timestamp = value;
            }
        }

        /// <summary>
        ///   Sets the compression level to be used for entries subsequently added to
        ///   the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///  <para>
        ///    Varying the compression level used on entries can affect the
        ///    size-vs-speed tradeoff when compression and decompressing data streams
        ///    or files.
        ///  </para>
        ///
        ///  <para>
        ///    As with some other properties on the <c>ZipOutputStream</c> class, like <see cref="P:Ionic.Zip.ZipOutputStream.Password" />, and <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" />,
        ///    setting this property on a <c>ZipOutputStream</c>
        ///    instance will cause the specified <c>CompressionLevel</c> to be used on all
        ///    <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
        ///    <c>ZipOutputStream</c> instance.
        ///  </para>
        ///
        ///  <para>
        ///    If you do not set this property, the default compression level is used,
        ///    which normally gives a good balance of compression efficiency and
        ///    compression speed.  In some tests, using <c>BestCompression</c> can
        ///    double the time it takes to compress, while delivering just a small
        ///    increase in compression efficiency.  This behavior will vary with the
        ///    type of data you compress.  If you are in doubt, just leave this setting
        ///    alone, and accept the default.
        ///  </para>
        /// </remarks>
        // Token: 0x17000006 RID: 6
        // (get) Token: 0x0600000F RID: 15 RVA: 0x00002374 File Offset: 0x00000574
        // (set) Token: 0x06000010 RID: 16 RVA: 0x0000238B File Offset: 0x0000058B
        public CompressionLevel CompressionLevel { get; set; }

        /// <summary>
        ///   The compression method used on each entry added to the ZipOutputStream.
        /// </summary>
        // Token: 0x17000007 RID: 7
        // (get) Token: 0x06000011 RID: 17 RVA: 0x00002394 File Offset: 0x00000594
        // (set) Token: 0x06000012 RID: 18 RVA: 0x000023AB File Offset: 0x000005AB
        public CompressionMethod CompressionMethod { get; set; }

        /// <summary>
        ///   A comment attached to the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///
        /// <para>
        ///   The application sets this property to specify a comment to be embedded
        ///   into the generated zip archive.
        /// </para>
        ///
        /// <para>
        ///   According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
        ///   zip specification</see>, the comment is not encrypted, even if there is a
        ///   password set on the zip file.
        /// </para>
        ///
        /// <para>
        ///   The specification does not describe how to indicate the encoding used
        ///   on a comment string. Many "compliant" zip tools and libraries use
        ///   IBM437 as the code page for comments; DotNetZip, too, follows that
        ///   practice.  On the other hand, there are situations where you want a
        ///   Comment to be encoded with something else, for example using code page
        ///   950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
        ///   comment following the same procedure it follows for encoding
        ///   filenames: (a) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is
        ///   <c>Never</c>, it uses the default encoding (IBM437). (b) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is <c>Always</c>, it always uses the
        ///   alternate encoding (<see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncoding" />). (c) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is <c>AsNecessary</c>, it uses the
        ///   alternate encoding only if the default encoding is not sufficient for
        ///   encoding the comment - in other words if decoding the result does not
        ///   produce the original string.  This decision is taken at the time of
        ///   the call to <c>ZipFile.Save()</c>.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000008 RID: 8
        // (get) Token: 0x06000013 RID: 19 RVA: 0x000023B4 File Offset: 0x000005B4
        // (set) Token: 0x06000014 RID: 20 RVA: 0x000023CC File Offset: 0x000005CC
        public string Comment
        {
            get
            {
                return this._comment;
            }
            set
            {
                if (this._disposed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                this._comment = value;
            }
        }

        /// <summary>
        ///   Specify whether to use ZIP64 extensions when saving a zip archive.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   The default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never" />. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is
        ///   safest, in the sense that you will not get an Exception if a
        ///   pre-ZIP64 limit is exceeded.
        /// </para>
        ///
        /// <para>
        ///   You must set this property before calling <c>Write()</c>.
        /// </para>
        ///
        /// </remarks>
        // Token: 0x17000009 RID: 9
        // (get) Token: 0x06000015 RID: 21 RVA: 0x00002404 File Offset: 0x00000604
        // (set) Token: 0x06000016 RID: 22 RVA: 0x0000241C File Offset: 0x0000061C
        public Zip64Option EnableZip64
        {
            get
            {
                return this._zip64;
            }
            set
            {
                if (this._disposed)
                {
                    this._exceptionPending = true;
                    throw new InvalidOperationException("The stream has been closed.");
                }
                this._zip64 = value;
            }
        }

        /// <summary>
        ///   Indicates whether ZIP64 extensions were used when saving the zip archive.
        /// </summary>
        ///
        /// <remarks>
        ///   The value is defined only after the <c>ZipOutputStream</c> has been closed.
        /// </remarks>
        // Token: 0x1700000A RID: 10
        // (get) Token: 0x06000017 RID: 23 RVA: 0x00002454 File Offset: 0x00000654
        public bool OutputUsedZip64
        {
            get
            {
                return this._anyEntriesUsedZip64 || this._directoryNeededZip64;
            }
        }

        /// <summary>
        ///   Whether the ZipOutputStream should use case-insensitive comparisons when
        ///   checking for uniqueness of zip entries.
        /// </summary>
        ///
        /// <remarks>
        ///   <para>
        ///   Though the zip specification doesn't prohibit zipfiles with duplicate
        ///   entries, Sane zip files have no duplicates, and the DotNetZip library
        ///   cannot create zip files with duplicate entries. If an application attempts
        ///   to call <see cref="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)" /> with a name that duplicates one
        ///   already used within the archive, the library will throw an Exception.
        ///   </para>
        ///   <para>
        ///   This property allows the application to specify whether the
        ///   ZipOutputStream instance considers ordinal case when checking for
        ///   uniqueness of zip entries.
        ///   </para>
        /// </remarks>
        // Token: 0x1700000B RID: 11
        // (get) Token: 0x06000018 RID: 24 RVA: 0x00002478 File Offset: 0x00000678
        // (set) Token: 0x06000019 RID: 25 RVA: 0x00002493 File Offset: 0x00000693
        public bool IgnoreCase
        {
            get
            {
                return !this._DontIgnoreCase;
            }
            set
            {
                this._DontIgnoreCase = !value;
            }
        }

        /// <summary>
        ///   Indicates whether to encode entry filenames and entry comments using
        ///   Unicode (UTF-8).
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
        ///   PKWare zip specification</see> provides for encoding file names and file
        ///   comments in either the IBM437 code page, or in UTF-8.  This flag selects
        ///   the encoding according to that specification.  By default, this flag is
        ///   false, and filenames and comments are encoded into the zip file in the
        ///   IBM437 codepage.  Setting this flag to true will specify that filenames
        ///   and comments that cannot be encoded with IBM437 will be encoded with
        ///   UTF-8.
        /// </para>
        ///
        /// <para>
        ///   Zip files created with strict adherence to the PKWare specification with
        ///   respect to UTF-8 encoding can contain entries with filenames containing
        ///   any combination of Unicode characters, including the full range of
        ///   characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
        ///   alphabets.  However, because at this time, the UTF-8 portion of the PKWare
        ///   specification is not broadly supported by other zip libraries and
        ///   utilities, such zip files may not be readable by your favorite zip tool or
        ///   archiver. In other words, interoperability will decrease if you set this
        ///   flag to true.
        /// </para>
        ///
        /// <para>
        ///   In particular, Zip files created with strict adherence to the PKWare
        ///   specification with respect to UTF-8 encoding will not work well with
        ///   Explorer in Windows XP or Windows Vista, because Windows compressed
        ///   folders, as far as I know, do not support UTF-8 in zip files.  Vista can
        ///   read the zip files, but shows the filenames incorrectly. Unpacking from
        ///   Windows Vista Explorer will result in filenames that have rubbish
        ///   characters in place of the high-order UTF-8 bytes.
        /// </para>
        ///
        /// <para>
        ///   Also, zip files that use UTF-8 encoding will not work well with Java
        ///   applications that use the java.util.zip classes, as of v5.0 of the Java
        ///   runtime. The Java runtime does not correctly implement the PKWare
        ///   specification in this regard.
        /// </para>
        ///
        /// <para>
        ///   As a result, we have the unfortunate situation that "correct" behavior by
        ///   the DotNetZip library with regard to Unicode encoding of filenames during
        ///   zip creation will result in zip files that are readable by strictly
        ///   compliant and current tools (for example the most recent release of the
        ///   commercial WinZip tool); but these zip files will not be readable by
        ///   various other tools or libraries, including Windows Explorer.
        /// </para>
        ///
        /// <para>
        ///   The DotNetZip library can read and write zip files with UTF8-encoded
        ///   entries, according to the PKware spec.  If you use DotNetZip for both
        ///   creating and reading the zip file, and you use UTF-8, there will be no
        ///   loss of information in the filenames. For example, using a self-extractor
        ///   created by this library will allow you to unpack files correctly with no
        ///   loss of information in the filenames.
        /// </para>
        ///
        /// <para>
        ///   If you do not set this flag, it will remain false.  If this flag is false,
        ///   the <c>ZipOutputStream</c> will encode all filenames and comments using
        ///   the IBM437 codepage.  This can cause "loss of information" on some
        ///   filenames, but the resulting zipfile will be more interoperable with other
        ///   utilities. As an example of the loss of information, diacritics can be
        ///   lost.  The o-tilde character will be down-coded to plain o.  The c with a
        ///   cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
        ///   Likewise, the O-stroke character (Unicode 248), used in Danish and
        ///   Norwegian, will be down-coded to plain o. Chinese characters cannot be
        ///   represented in codepage IBM437; when using the default encoding, Chinese
        ///   characters in filenames will be represented as ?. These are all examples
        ///   of "information loss".
        /// </para>
        ///
        /// <para>
        ///   The loss of information associated to the use of the IBM437 encoding is
        ///   inconvenient, and can also lead to runtime errors. For example, using
        ///   IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
        ///   your application creates a <c>ZipOutputStream</c>, does not set the
        ///   encoding, then adds two files, each with names of four Chinese characters
        ///   each, this will result in a duplicate filename exception.  In the case
        ///   where you add a single file with a name containing four Chinese
        ///   characters, the zipfile will save properly, but extracting that file
        ///   later, with any zip tool, will result in an error, because the question
        ///   mark is not legal for use within filenames on Windows.  These are just a
        ///   few examples of the problems associated to loss of information.
        /// </para>
        ///
        /// <para>
        ///   This flag is independent of the encoding of the content within the entries
        ///   in the zip file. Think of the zip file as a container - it supports an
        ///   encoding.  Within the container are other "containers" - the file entries
        ///   themselves.  The encoding within those entries is independent of the
        ///   encoding of the zip archive container for those entries.
        /// </para>
        ///
        /// <para>
        ///   Rather than specify the encoding in a binary fashion using this flag, an
        ///   application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding" /> property.  Setting the encoding
        ///   explicitly when creating zip archives will result in non-compliant zip
        ///   files that, curiously, are fairly interoperable.  The challenge is, the
        ///   PKWare specification does not provide for a way to specify that an entry
        ///   in a zip archive uses a code page that is neither IBM437 nor UTF-8.
        ///   Therefore if you set the encoding explicitly when creating a zip archive,
        ///   you must take care upon reading the zip archive to use the same code page.
        ///   If you get it wrong, the behavior is undefined and may result in incorrect
        ///   filenames, exceptions, stomach upset, hair loss, and acne.
        /// </para>
        /// </remarks>
        /// <seealso cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding" />
        // Token: 0x1700000C RID: 12
        // (get) Token: 0x0600001A RID: 26 RVA: 0x000024A0 File Offset: 0x000006A0
        // (set) Token: 0x0600001B RID: 27 RVA: 0x000024CC File Offset: 0x000006CC
        [Obsolete("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete. It will be removed in a future version of the library. Use AlternateEncoding and AlternateEncodingUsage instead.")]
        public bool UseUnicodeAsNecessary
        {
            get
            {
                return this._alternateEncoding == Encoding.UTF8 && this.AlternateEncodingUsage == ZipOption.AsNecessary;
            }
            set
            {
                if (value)
                {
                    this._alternateEncoding = Encoding.UTF8;
                    this._alternateEncodingUsage = ZipOption.AsNecessary;
                }
                else
                {
                    this._alternateEncoding = ZipOutputStream.DefaultEncoding;
                    this._alternateEncodingUsage = ZipOption.Default;
                }
            }
        }

        /// <summary>
        ///   The text encoding to use when emitting entries into the zip archive, for
        ///   those entries whose filenames or comments cannot be encoded with the
        ///   default (IBM437) encoding.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
        ///   zip specification</see>, PKWare describes two options for encoding
        ///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
        ///   or libraries do not follow the specification, and instead encode
        ///   characters using the system default code page.  For example, WinRAR when
        ///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
        ///   (950) code page.  This behavior is contrary to the Zip specification, but
        ///   it occurs anyway.
        /// </para>
        ///
        /// <para>
        ///   When using DotNetZip to write zip archives that will be read by one of
        ///   these other archivers, set this property to specify the code page to use
        ///   when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each <c>ZipEntry</c> in the zip file, for
        ///   values that cannot be encoded with the default codepage for zip files,
        ///   IBM437.  This is why this property is "provisional".  In all cases, IBM437
        ///   is used where possible, in other words, where no loss of data would
        ///   result. It is possible, therefore, to have a given entry with a
        ///   <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
        ///   specified "provisional" codepage.
        /// </para>
        ///
        /// <para>
        ///   Be aware that a zip file created after you've explicitly set the
        ///   <c>ProvisionalAlternateEncoding</c> property to a value other than
        ///   IBM437 may not be compliant to the PKWare specification, and may not be
        ///   readable by compliant archivers.  On the other hand, many (most?)
        ///   archivers are non-compliant and can read zip files created in arbitrary
        ///   code pages.  The trick is to use or specify the proper codepage when
        ///   reading the zip.
        /// </para>
        ///
        /// <para>
        ///   When creating a zip archive using this library, it is possible to change
        ///   the value of <c>ProvisionalAlternateEncoding</c> between each entry you
        ///   add, and between adding entries and the call to <c>Close()</c>. Don't do
        ///   this. It will likely result in a zipfile that is not readable.  For best
        ///   interoperability, either leave <c>ProvisionalAlternateEncoding</c>
        ///   alone, or specify it only once, before adding any entries to the
        ///   <c>ZipOutputStream</c> instance.  There is one exception to this
        ///   recommendation, described later.
        /// </para>
        ///
        /// <para>
        ///   When using an arbitrary, non-UTF8 code page for encoding, there is no
        ///   standard way for the creator application - whether DotNetZip, WinZip,
        ///   WinRar, or something else - to formally specify in the zip file which
        ///   codepage has been used for the entries. As a result, readers of zip files
        ///   are not able to inspect the zip file and determine the codepage that was
        ///   used for the entries contained within it.  It is left to the application
        ///   or user to determine the necessary codepage when reading zip files encoded
        ///   this way.  If you use an incorrect codepage when reading a zipfile, you
        ///   will get entries with filenames that are incorrect, and the incorrect
        ///   filenames may even contain characters that are not legal for use within
        ///   filenames in Windows. Extracting entries with illegal characters in the
        ///   filenames will lead to exceptions. It's too bad, but this is just the way
        ///   things are with code pages in zip files. Caveat Emptor.
        /// </para>
        ///
        /// <para>
        ///   One possible approach for specifying the code page for a given zip file is
        ///   to describe the code page in a human-readable form in the Zip comment. For
        ///   example, the comment may read "Entries in this archive are encoded in the
        ///   Big5 code page".  For maximum interoperability, the zip comment in this
        ///   case should be encoded in the default, IBM437 code page.  In this case,
        ///   the zip comment is encoded using a different page than the filenames.  To
        ///   do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
        ///   region-specific code page, once before adding any entries, and then set
        ///   the <see cref="P:Ionic.Zip.ZipOutputStream.Comment" /> property and reset
        ///   <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
        /// </para>
        /// </remarks>
        // Token: 0x1700000D RID: 13
        // (get) Token: 0x0600001C RID: 28 RVA: 0x0000250C File Offset: 0x0000070C
        // (set) Token: 0x0600001D RID: 29 RVA: 0x00002538 File Offset: 0x00000738
        [Obsolete("use AlternateEncoding and AlternateEncodingUsage instead.")]
        public Encoding ProvisionalAlternateEncoding
        {
            get
            {
                Encoding result;
                if (this._alternateEncodingUsage == ZipOption.AsNecessary)
                {
                    result = this._alternateEncoding;
                }
                else
                {
                    result = null;
                }
                return result;
            }
            set
            {
                this._alternateEncoding = value;
                this._alternateEncodingUsage = ZipOption.AsNecessary;
            }
        }

        /// <summary>
        ///   A Text Encoding to use when encoding the filenames and comments for
        ///   all the ZipEntry items, during a ZipFile.Save() operation.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Whether the encoding specified here is used during the save depends
        ///     on <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" />.
        ///   </para>
        /// </remarks>
        // Token: 0x1700000E RID: 14
        // (get) Token: 0x0600001E RID: 30 RVA: 0x0000254C File Offset: 0x0000074C
        // (set) Token: 0x0600001F RID: 31 RVA: 0x00002564 File Offset: 0x00000764
        public Encoding AlternateEncoding
        {
            get
            {
                return this._alternateEncoding;
            }
            set
            {
                this._alternateEncoding = value;
            }
        }

        /// <summary>
        ///   A flag that tells if and when this instance should apply
        ///   AlternateEncoding to encode the filenames and comments associated to
        ///   of ZipEntry objects contained within this instance.
        /// </summary>
        // Token: 0x1700000F RID: 15
        // (get) Token: 0x06000020 RID: 32 RVA: 0x00002570 File Offset: 0x00000770
        // (set) Token: 0x06000021 RID: 33 RVA: 0x00002588 File Offset: 0x00000788
        public ZipOption AlternateEncodingUsage
        {
            get
            {
                return this._alternateEncodingUsage;
            }
            set
            {
                this._alternateEncodingUsage = value;
            }
        }

        /// <summary>
        /// The default text encoding used in zip archives.  It is numeric 437, also
        /// known as IBM437.
        /// </summary>
        /// <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        // Token: 0x17000010 RID: 16
        // (get) Token: 0x06000022 RID: 34 RVA: 0x00002594 File Offset: 0x00000794
        public static Encoding DefaultEncoding
        {
            get
            {
                return Encoding.GetEncoding("IBM437");
            }
        }

        /// <summary>
        ///   The size threshold for an entry, above which a parallel deflate is used.
        /// </summary>
        ///
        /// <remarks>
        ///
        ///   <para>
        ///     DotNetZip will use multiple threads to compress any ZipEntry, when
        ///     the <c>CompressionMethod</c> is Deflate, and if the entry is
        ///     larger than the given size.  Zero means "always use parallel
        ///     deflate", while -1 means "never use parallel deflate".
        ///   </para>
        ///
        ///   <para>
        ///     If the entry size cannot be known before compression, as with any entry
        ///     added via a ZipOutputStream, then Parallel deflate will never be
        ///     performed, unless the value of this property is zero.
        ///   </para>
        ///
        ///   <para>
        ///     A parallel deflate operations will speed up the compression of
        ///     large files, on computers with multiple CPUs or multiple CPU
        ///     cores.  For files above 1mb, on a dual core or dual-cpu (2p)
        ///     machine, the time required to compress the file can be 70% of the
        ///     single-threaded deflate.  For very large files on 4p machines the
        ///     compression can be done in 30% of the normal time.  The downside
        ///     is that parallel deflate consumes extra memory during the deflate,
        ///     and the deflation is slightly less effective.
        ///   </para>
        ///
        ///   <para>
        ///     Parallel deflate tends to not be as effective as single-threaded deflate
        ///     because the original data stream is split into multiple independent
        ///     buffers, each of which is compressed in parallel.  But because they are
        ///     treated independently, there is no opportunity to share compression
        ///     dictionaries, and additional framing bytes must be added to the output
        ///     stream.  For that reason, a deflated stream may be slightly larger when
        ///     compressed using parallel deflate, as compared to a traditional
        ///     single-threaded deflate. For files of about 512k, the increase over the
        ///     normal deflate is as much as 5% of the total compressed size. For larger
        ///     files, the difference can be as small as 0.1%.
        ///   </para>
        ///
        ///   <para>
        ///     Multi-threaded compression does not give as much an advantage when using
        ///     Encryption. This is primarily because encryption tends to slow down
        ///     the entire pipeline. Also, multi-threaded compression gives less of an
        ///     advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed" />.  You may have to perform
        ///     some tests to determine the best approach for your situation.
        ///   </para>
        ///
        ///   <para>
        ///     The default value for this property is -1, which means parallel
        ///     compression will not be performed unless you set it to zero.
        ///   </para>
        ///
        /// </remarks>
        // Token: 0x17000011 RID: 17
        // (get) Token: 0x06000024 RID: 36 RVA: 0x000025F0 File Offset: 0x000007F0
        // (set) Token: 0x06000023 RID: 35 RVA: 0x000025B0 File Offset: 0x000007B0
        public long ParallelDeflateThreshold
        {
            get
            {
                return this._ParallelDeflateThreshold;
            }
            set
            {
                if (value != 0L && value != -1L && value < 65536L)
                {
                    throw new ArgumentOutOfRangeException("value must be greater than 64k, or 0, or -1");
                }
                this._ParallelDeflateThreshold = value;
            }
        }

        /// <summary>
        ///   The maximum number of buffer pairs to use when performing
        ///   parallel compression.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This property sets an upper limit on the number of memory
        ///   buffer pairs to create when performing parallel
        ///   compression.  The implementation of the parallel
        ///   compression stream allocates multiple buffers to
        ///   facilitate parallel compression.  As each buffer fills up,
        ///   the stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
        ///   ThreadPool.QueueUserWorkItem()</see> to compress those
        ///   buffers in a background threadpool thread. After a buffer
        ///   is compressed, it is re-ordered and written to the output
        ///   stream.
        /// </para>
        ///
        /// <para>
        ///   A higher number of buffer pairs enables a higher degree of
        ///   parallelism, which tends to increase the speed of compression on
        ///   multi-cpu computers.  On the other hand, a higher number of buffer
        ///   pairs also implies a larger memory consumption, more active worker
        ///   threads, and a higher cpu utilization for any compression. This
        ///   property enables the application to limit its memory consumption and
        ///   CPU utilization behavior depending on requirements.
        /// </para>
        ///
        /// <para>
        ///   For each compression "task" that occurs in parallel, there are 2
        ///   buffers allocated: one for input and one for output.  This property
        ///   sets a limit for the number of pairs.  The total amount of storage
        ///   space allocated for buffering will then be (N*S*2), where N is the
        ///   number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zip.ZipOutputStream.CodecBufferSize" />).  By default, DotNetZip allocates 4 buffer
        ///   pairs per CPU core, so if your machine has 4 cores, and you retain
        ///   the default buffer size of 128k, then the
        ///   ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
        ///   memory in total, or 4mb, in blocks of 128kb.  If you then set this
        ///   property to 8, then the number will be 8 * 2 * 128kb of buffer
        ///   memory, or 2mb.
        /// </para>
        ///
        /// <para>
        ///   CPU utilization will also go up with additional buffers, because a
        ///   larger number of buffer pairs allows a larger number of background
        ///   threads to compress in parallel. If you find that parallel
        ///   compression is consuming too much memory or CPU, you can adjust this
        ///   value downward.
        /// </para>
        ///
        /// <para>
        ///   The default value is 16. Different values may deliver better or
        ///   worse results, depending on your priorities and the dynamic
        ///   performance characteristics of your storage and compute resources.
        /// </para>
        ///
        /// <para>
        ///   This property is not the number of buffer pairs to use; it is an
        ///   upper limit. An illustration: Suppose you have an application that
        ///   uses the default value of this property (which is 16), and it runs
        ///   on a machine with 2 CPU cores. In that case, DotNetZip will allocate
        ///   4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
        ///   limit specified by this property has no effect.
        /// </para>
        ///
        /// <para>
        ///   The application can set this value at any time, but it is
        ///   effective only if set before calling
        ///   <c>ZipOutputStream.Write()</c> for the first time.
        /// </para>
        /// </remarks>
        ///
        /// <seealso cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold" />
        // Token: 0x17000012 RID: 18
        // (get) Token: 0x06000025 RID: 37 RVA: 0x00002608 File Offset: 0x00000808
        // (set) Token: 0x06000026 RID: 38 RVA: 0x00002620 File Offset: 0x00000820
        public int ParallelDeflateMaxBufferPairs
        {
            get
            {
                return this._maxBufferPairs;
            }
            set
            {
                if (value < 4)
                {
                    throw new ArgumentOutOfRangeException("ParallelDeflateMaxBufferPairs", "Value must be 4 or greater.");
                }
                this._maxBufferPairs = value;
            }
        }

        // Token: 0x06000027 RID: 39 RVA: 0x00002650 File Offset: 0x00000850
        private void InsureUniqueEntry(ZipEntry ze1)
        {
            if (this._entriesWritten.ContainsKey(ze1.FileName))
            {
                this._exceptionPending = true;
                throw new ArgumentException(string.Format("The entry '{0}' already exists in the zip archive.", ze1.FileName));
            }
        }

        // Token: 0x17000013 RID: 19
        // (get) Token: 0x06000028 RID: 40 RVA: 0x00002694 File Offset: 0x00000894
        internal Stream OutputStream
        {
            get
            {
                return this._outputStream;
            }
        }

        // Token: 0x17000014 RID: 20
        // (get) Token: 0x06000029 RID: 41 RVA: 0x000026AC File Offset: 0x000008AC
        internal string Name
        {
            get
            {
                return this._name;
            }
        }

        /// <summary>
        ///   Returns true if an entry by the given name has already been written
        ///   to the ZipOutputStream.
        /// </summary>
        ///
        /// <param name="name">
        ///   The name of the entry to scan for.
        /// </param>
        ///
        /// <returns>
        /// true if an entry by the given name has already been written.
        /// </returns>
        // Token: 0x0600002A RID: 42 RVA: 0x000026C4 File Offset: 0x000008C4
        public bool ContainsEntry(string name)
        {
            return this._entriesWritten.ContainsKey(SharedUtilities.NormalizePathForUseInZipFile(name));
        }

        /// <summary>
        ///   Write the data from the buffer to the stream.
        /// </summary>
        ///
        /// <remarks>
        ///   As the application writes data into this stream, the data may be
        ///   compressed and encrypted before being written out to the underlying
        ///   stream, depending on the settings of the <see cref="P:Ionic.Zip.ZipOutputStream.CompressionLevel" />
        ///   and the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" /> properties.
        /// </remarks>
        ///
        /// <param name="buffer">The buffer holding data to write to the stream.</param>
        /// <param name="offset">the offset within that data array to find the first byte to write.</param>
        /// <param name="count">the number of bytes to write.</param>
        // Token: 0x0600002B RID: 43 RVA: 0x000026E8 File Offset: 0x000008E8
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this._disposed)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("The stream has been closed.");
            }
            if (buffer == null)
            {
                this._exceptionPending = true;
                throw new ArgumentNullException("buffer");
            }
            if (this._currentEntry == null)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("You must call PutNextEntry() before calling Write().");
            }
            if (this._currentEntry.IsDirectory)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("You cannot Write() data for an entry that is a directory.");
            }
            if (this._needToWriteEntryHeader)
            {
                this._InitiateCurrentEntry(false);
            }
            if (count != 0)
            {
                this._entryOutputStream.Write(buffer, offset, count);
            }
        }

        /// <summary>
        ///   Specify the name of the next entry that will be written to the zip file.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   Call this method just before calling <see cref="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)" />, to
        ///   specify the name of the entry that the next set of bytes written to
        ///   the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
        ///   until the next call to <c>PutNextEntry</c>,
        ///   will be inserted into the named entry in the zip file.
        /// </para>
        ///
        /// <para>
        ///   If the <paramref name="entryName" /> used in <c>PutNextEntry()</c> ends in
        ///   a slash, then the entry added is marked as a directory. Because directory
        ///   entries do not contain data, a call to <c>Write()</c>, before an
        ///   intervening additional call to <c>PutNextEntry()</c>, will throw an
        ///   exception.
        /// </para>
        ///
        /// <para>
        ///   If you don't call <c>Write()</c> between two calls to
        ///   <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
        ///   file of zero size.  This may be what you want.
        /// </para>
        ///
        /// <para>
        ///   Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
        ///   method may throw if there is a problem with the prior entry.
        /// </para>
        ///
        /// <para>
        ///   This method returns the <c>ZipEntry</c>.  You can modify public properties
        ///   on the <c>ZipEntry</c>, such as <see cref="P:Ionic.Zip.ZipEntry.Encryption" />, <see cref="P:Ionic.Zip.ZipEntry.Password" />, and so on, until the first call to
        ///   <c>ZipOutputStream.Write()</c>, or until the next call to
        ///   <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c> <em>after</em>
        ///   having called <c>Write()</c>, you may get a runtime exception, or you may
        ///   silently get an invalid zip archive.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <example>
        ///
        ///   This example shows how to create a zip file, using the
        ///   <c>ZipOutputStream</c> class.
        ///
        /// <code>
        /// private void Zipup()
        /// {
        ///     using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
        ///     {
        ///         using (var output= new ZipOutputStream(fs))
        ///         {
        ///             output.Password = "VerySecret!";
        ///             output.Encryption = EncryptionAlgorithm.WinZipAes256;
        ///             output.PutNextEntry("entry1.txt");
        ///             byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
        ///             output.Write(buffer,0,buffer.Length);
        ///             output.PutNextEntry("entry2.txt");  // this will be zero length
        ///             output.PutNextEntry("entry3.txt");
        ///             buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
        ///             output.Write(buffer,0,buffer.Length);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        ///
        /// <param name="entryName">
        ///   The name of the entry to be added, including any path to be used
        ///   within the zip file.
        /// </param>
        ///
        /// <returns>
        ///   The ZipEntry created.
        /// </returns>
        // Token: 0x0600002C RID: 44 RVA: 0x000027A8 File Offset: 0x000009A8
        public ZipEntry PutNextEntry(string entryName)
        {
            if (string.IsNullOrEmpty(entryName))
            {
                throw new ArgumentNullException("entryName");
            }
            if (this._disposed)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("The stream has been closed.");
            }
            this._FinishCurrentEntry();
            this._currentEntry = ZipEntry.CreateForZipOutputStream(entryName);
            this._currentEntry._container = new ZipContainer(this);
            ZipEntry currentEntry = this._currentEntry;
            currentEntry._BitField |= 8;
            this._currentEntry.SetEntryTimes(DateTime.Now, DateTime.Now, DateTime.Now);
            this._currentEntry.CompressionLevel = this.CompressionLevel;
            this._currentEntry.CompressionMethod = this.CompressionMethod;
            this._currentEntry.Password = this._password;
            this._currentEntry.Encryption = this.Encryption;
            this._currentEntry.AlternateEncoding = this.AlternateEncoding;
            this._currentEntry.AlternateEncodingUsage = this.AlternateEncodingUsage;
            if (entryName.EndsWith("/"))
            {
                this._currentEntry.MarkAsDirectory();
            }
            this._currentEntry.EmitTimesInWindowsFormatWhenSaving = ((this._timestamp & ZipEntryTimestamp.Windows) != ZipEntryTimestamp.None);
            this._currentEntry.EmitTimesInUnixFormatWhenSaving = ((this._timestamp & ZipEntryTimestamp.Unix) != ZipEntryTimestamp.None);
            this.InsureUniqueEntry(this._currentEntry);
            this._needToWriteEntryHeader = true;
            return this._currentEntry;
        }

        // Token: 0x0600002D RID: 45 RVA: 0x00002920 File Offset: 0x00000B20
        private void _InitiateCurrentEntry(bool finishing)
        {
            this._entriesWritten.Add(this._currentEntry.FileName, this._currentEntry);
            this._entryCount++;
            if (this._entryCount > 65534 && this._zip64 == Zip64Option.Default)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("Too many entries. Consider setting ZipOutputStream.EnableZip64.");
            }
            this._currentEntry.WriteHeader(this._outputStream, finishing ? 99 : 0);
            this._currentEntry.StoreRelativeOffset();
            if (!this._currentEntry.IsDirectory)
            {
                this._currentEntry.WriteSecurityMetadata(this._outputStream);
                this._currentEntry.PrepOutputStream(this._outputStream, finishing ? 0L : -1L, out this._outputCounter, out this._encryptor, out this._deflater, out this._entryOutputStream);
            }
            this._needToWriteEntryHeader = false;
        }

        // Token: 0x0600002E RID: 46 RVA: 0x00002A10 File Offset: 0x00000C10
        private void _FinishCurrentEntry()
        {
            if (this._currentEntry != null)
            {
                if (this._needToWriteEntryHeader)
                {
                    this._InitiateCurrentEntry(true);
                }
                this._currentEntry.FinishOutputStream(this._outputStream, this._outputCounter, this._encryptor, this._deflater, this._entryOutputStream);
                this._currentEntry.PostProcessOutput(this._outputStream);
                if (this._currentEntry.OutputUsedZip64 != null)
                {
                    this._anyEntriesUsedZip64 |= this._currentEntry.OutputUsedZip64.Value;
                }
                this._outputCounter = null;
                this._encryptor = (this._deflater = null);
                this._entryOutputStream = null;
            }
        }

        /// <summary>
        /// Dispose the stream
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        ///   This method writes the Zip Central directory, then closes the stream.  The
        ///   application must call Dispose() (or Close) in order to produce a valid zip file.
        /// </para>
        ///
        /// <para>
        ///   Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
        ///   statement in C#, or a <c>Using</c> statement in VB.
        /// </para>
        ///
        /// </remarks>
        ///
        /// <param name="disposing">set this to true, always.</param>
        // Token: 0x0600002F RID: 47 RVA: 0x00002ADC File Offset: 0x00000CDC
        protected override void Dispose(bool disposing)
        {
            if (!this._disposed)
            {
                if (disposing)
                {
                    if (!this._exceptionPending)
                    {
                        this._FinishCurrentEntry();
                        this._directoryNeededZip64 = ZipOutput.WriteCentralDirectoryStructure(this._outputStream, this._entriesWritten.Values, 1u, this._zip64, this.Comment, new ZipContainer(this));
                        CountingStream cs = this._outputStream as CountingStream;
                        Stream wrappedStream;
                        if (cs != null)
                        {
                            wrappedStream = cs.WrappedStream;
                            cs.Dispose();
                        }
                        else
                        {
                            wrappedStream = this._outputStream;
                        }
                        if (!this._leaveUnderlyingStreamOpen)
                        {
                            wrappedStream.Dispose();
                        }
                        this._outputStream = null;
                    }
                }
                this._disposed = true;
            }
        }

        /// <summary>
        /// Always returns false.
        /// </summary>
        // Token: 0x17000015 RID: 21
        // (get) Token: 0x06000030 RID: 48 RVA: 0x00002BA0 File Offset: 0x00000DA0
        public override bool CanRead
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Always returns false.
        /// </summary>
        // Token: 0x17000016 RID: 22
        // (get) Token: 0x06000031 RID: 49 RVA: 0x00002BB4 File Offset: 0x00000DB4
        public override bool CanSeek
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Always returns true.
        /// </summary>
        // Token: 0x17000017 RID: 23
        // (get) Token: 0x06000032 RID: 50 RVA: 0x00002BC8 File Offset: 0x00000DC8
        public override bool CanWrite
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Always returns a NotSupportedException.
        /// </summary>
        // Token: 0x17000018 RID: 24
        // (get) Token: 0x06000033 RID: 51 RVA: 0x00002BDB File Offset: 0x00000DDB
        public override long Length
        {
            get
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Setting this property always returns a NotSupportedException. Getting it
        /// returns the value of the Position on the underlying stream.
        /// </summary>
        // Token: 0x17000019 RID: 25
        // (get) Token: 0x06000034 RID: 52 RVA: 0x00002BE4 File Offset: 0x00000DE4
        // (set) Token: 0x06000035 RID: 53 RVA: 0x00002C01 File Offset: 0x00000E01
        public override long Position
        {
            get
            {
                return this._outputStream.Position;
            }
            set
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// This is a no-op.
        /// </summary>
        // Token: 0x06000036 RID: 54 RVA: 0x00002C09 File Offset: 0x00000E09
        public override void Flush()
        {
        }

        /// <summary>
        /// This method always throws a NotSupportedException.
        /// </summary>
        /// <param name="buffer">ignored</param>
        /// <param name="offset">ignored</param>
        /// <param name="count">ignored</param>
        /// <returns>nothing</returns>
        // Token: 0x06000037 RID: 55 RVA: 0x00002C0C File Offset: 0x00000E0C
        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("Read");
        }

        /// <summary>
        /// This method always throws a NotSupportedException.
        /// </summary>
        /// <param name="offset">ignored</param>
        /// <param name="origin">ignored</param>
        /// <returns>nothing</returns>
        // Token: 0x06000038 RID: 56 RVA: 0x00002C19 File Offset: 0x00000E19
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Seek");
        }

        /// <summary>
        /// This method always throws a NotSupportedException.
        /// </summary>
        /// <param name="value">ignored</param>
        // Token: 0x06000039 RID: 57 RVA: 0x00002C26 File Offset: 0x00000E26
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        // Token: 0x04000009 RID: 9
        private EncryptionAlgorithm _encryption;

        // Token: 0x0400000A RID: 10
        private ZipEntryTimestamp _timestamp;

        // Token: 0x0400000B RID: 11
        internal string _password;

        // Token: 0x0400000C RID: 12
        private string _comment;

        // Token: 0x0400000D RID: 13
        private Stream _outputStream;

        // Token: 0x0400000E RID: 14
        private ZipEntry _currentEntry;

        // Token: 0x0400000F RID: 15
        internal Zip64Option _zip64;

        // Token: 0x04000010 RID: 16
        private Dictionary<string, ZipEntry> _entriesWritten;

        // Token: 0x04000011 RID: 17
        private int _entryCount;

        // Token: 0x04000012 RID: 18
        private ZipOption _alternateEncodingUsage;

        // Token: 0x04000013 RID: 19
        private Encoding _alternateEncoding;

        // Token: 0x04000014 RID: 20
        private bool _leaveUnderlyingStreamOpen;

        // Token: 0x04000015 RID: 21
        private bool _disposed;

        // Token: 0x04000016 RID: 22
        private bool _exceptionPending;

        // Token: 0x04000017 RID: 23
        private bool _anyEntriesUsedZip64;

        // Token: 0x04000018 RID: 24
        private bool _directoryNeededZip64;

        // Token: 0x04000019 RID: 25
        private CountingStream _outputCounter;

        // Token: 0x0400001A RID: 26
        private Stream _encryptor;

        // Token: 0x0400001B RID: 27
        private Stream _deflater;

        // Token: 0x0400001C RID: 28
        private CrcCalculatorStream _entryOutputStream;

        // Token: 0x0400001D RID: 29
        private bool _needToWriteEntryHeader;

        // Token: 0x0400001E RID: 30
        private string _name;

        // Token: 0x0400001F RID: 31
        private bool _DontIgnoreCase;

        // Token: 0x04000020 RID: 32
        internal ParallelDeflateOutputStream ParallelDeflater;

        // Token: 0x04000021 RID: 33
        private long _ParallelDeflateThreshold;

        // Token: 0x04000022 RID: 34
        private int _maxBufferPairs;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    /// Provides information about the progress of a save, read, or extract operation.
    /// This is a base class; you will probably use one of the classes derived from this one.
    /// </summary>
    // Token: 0x0200002E RID: 46
    public class ZipProgressEventArgs : EventArgs
    {
        // Token: 0x06000158 RID: 344 RVA: 0x00007D32 File Offset: 0x00005F32
        internal ZipProgressEventArgs()
        {
        }

        // Token: 0x06000159 RID: 345 RVA: 0x00007D3D File Offset: 0x00005F3D
        internal ZipProgressEventArgs(string archiveName, ZipProgressEventType flavor)
        {
            this._archiveName = archiveName;
            this._flavor = flavor;
        }

        /// <summary>
        /// The total number of entries to be saved or extracted.
        /// </summary>
        // Token: 0x17000064 RID: 100
        // (get) Token: 0x0600015A RID: 346 RVA: 0x00007D58 File Offset: 0x00005F58
        // (set) Token: 0x0600015B RID: 347 RVA: 0x00007D70 File Offset: 0x00005F70
        public int EntriesTotal
        {
            get
            {
                return this._entriesTotal;
            }
            set
            {
                this._entriesTotal = value;
            }
        }

        /// <summary>
        /// The name of the last entry saved or extracted.
        /// </summary>
        // Token: 0x17000065 RID: 101
        // (get) Token: 0x0600015C RID: 348 RVA: 0x00007D7C File Offset: 0x00005F7C
        // (set) Token: 0x0600015D RID: 349 RVA: 0x00007D94 File Offset: 0x00005F94
        public ZipEntry CurrentEntry
        {
            get
            {
                return this._latestEntry;
            }
            set
            {
                this._latestEntry = value;
            }
        }

        /// <summary>
        /// In an event handler, set this to cancel the save or extract
        /// operation that is in progress.
        /// </summary>
        // Token: 0x17000066 RID: 102
        // (get) Token: 0x0600015E RID: 350 RVA: 0x00007DA0 File Offset: 0x00005FA0
        // (set) Token: 0x0600015F RID: 351 RVA: 0x00007DB8 File Offset: 0x00005FB8
        public bool Cancel
        {
            get
            {
                return this._cancel;
            }
            set
            {
                this._cancel = (this._cancel || value);
            }
        }

        /// <summary>
        /// The type of event being reported.
        /// </summary>
        // Token: 0x17000067 RID: 103
        // (get) Token: 0x06000160 RID: 352 RVA: 0x00007DD0 File Offset: 0x00005FD0
        // (set) Token: 0x06000161 RID: 353 RVA: 0x00007DE8 File Offset: 0x00005FE8
        public ZipProgressEventType EventType
        {
            get
            {
                return this._flavor;
            }
            set
            {
                this._flavor = value;
            }
        }

        /// <summary>
        /// Returns the archive name associated to this event.
        /// </summary>
        // Token: 0x17000068 RID: 104
        // (get) Token: 0x06000162 RID: 354 RVA: 0x00007DF4 File Offset: 0x00005FF4
        // (set) Token: 0x06000163 RID: 355 RVA: 0x00007E0C File Offset: 0x0000600C
        public string ArchiveName
        {
            get
            {
                return this._archiveName;
            }
            set
            {
                this._archiveName = value;
            }
        }

        /// <summary>
        /// The number of bytes read or written so far for this entry.
        /// </summary>
        // Token: 0x17000069 RID: 105
        // (get) Token: 0x06000164 RID: 356 RVA: 0x00007E18 File Offset: 0x00006018
        // (set) Token: 0x06000165 RID: 357 RVA: 0x00007E30 File Offset: 0x00006030
        public long BytesTransferred
        {
            get
            {
                return this._bytesTransferred;
            }
            set
            {
                this._bytesTransferred = value;
            }
        }

        /// <summary>
        /// Total number of bytes that will be read or written for this entry.
        /// This number will be -1 if the value cannot be determined.
        /// </summary>
        // Token: 0x1700006A RID: 106
        // (get) Token: 0x06000166 RID: 358 RVA: 0x00007E3C File Offset: 0x0000603C
        // (set) Token: 0x06000167 RID: 359 RVA: 0x00007E54 File Offset: 0x00006054
        public long TotalBytesToTransfer
        {
            get
            {
                return this._totalBytesToTransfer;
            }
            set
            {
                this._totalBytesToTransfer = value;
            }
        }

        // Token: 0x040000DB RID: 219
        private int _entriesTotal;

        // Token: 0x040000DC RID: 220
        private bool _cancel;

        // Token: 0x040000DD RID: 221
        private ZipEntry _latestEntry;

        // Token: 0x040000DE RID: 222
        private ZipProgressEventType _flavor;

        // Token: 0x040000DF RID: 223
        private string _archiveName;

        // Token: 0x040000E0 RID: 224
        private long _bytesTransferred;

        // Token: 0x040000E1 RID: 225
        private long _totalBytesToTransfer;
    }
}


namespace Ionic.Zip
{
    /// <summary>
    ///   In an EventArgs type, indicates which sort of progress event is being
    ///   reported.
    /// </summary>
    /// <remarks>
    ///   There are events for reading, events for saving, and events for
    ///   extracting. This enumeration allows a single EventArgs type to be sued to
    ///   describe one of multiple subevents. For example, a SaveProgress event is
    ///   invoked before, after, and during the saving of a single entry.  The value
    ///   of an enum with this type, specifies which event is being triggered.  The
    ///   same applies to Extraction, Reading and Adding events.
    /// </remarks>
    // Token: 0x0200002D RID: 45
    public enum ZipProgressEventType
    {
        /// <summary>
        /// Indicates that a Add() operation has started.
        /// </summary>
        // Token: 0x040000C3 RID: 195
        Adding_Started,
        /// <summary>
        /// Indicates that an individual entry in the archive has been added.
        /// </summary>
        // Token: 0x040000C4 RID: 196
        Adding_AfterAddEntry,
        /// <summary>
        /// Indicates that a Add() operation has completed.
        /// </summary>
        // Token: 0x040000C5 RID: 197
        Adding_Completed,
        /// <summary>
        /// Indicates that a Read() operation has started.
        /// </summary>
        // Token: 0x040000C6 RID: 198
        Reading_Started,
        /// <summary>
        /// Indicates that an individual entry in the archive is about to be read.
        /// </summary>
        // Token: 0x040000C7 RID: 199
        Reading_BeforeReadEntry,
        /// <summary>
        /// Indicates that an individual entry in the archive has just been read.
        /// </summary>
        // Token: 0x040000C8 RID: 200
        Reading_AfterReadEntry,
        /// <summary>
        /// Indicates that a Read() operation has completed.
        /// </summary>
        // Token: 0x040000C9 RID: 201
        Reading_Completed,
        /// <summary>
        /// The given event reports the number of bytes read so far
        /// during a Read() operation.
        /// </summary>
        // Token: 0x040000CA RID: 202
        Reading_ArchiveBytesRead,
        /// <summary>
        /// Indicates that a Save() operation has started.
        /// </summary>
        // Token: 0x040000CB RID: 203
        Saving_Started,
        /// <summary>
        /// Indicates that an individual entry in the archive is about to be written.
        /// </summary>
        // Token: 0x040000CC RID: 204
        Saving_BeforeWriteEntry,
        /// <summary>
        /// Indicates that an individual entry in the archive has just been saved.
        /// </summary>
        // Token: 0x040000CD RID: 205
        Saving_AfterWriteEntry,
        /// <summary>
        /// Indicates that a Save() operation has completed.
        /// </summary>
        // Token: 0x040000CE RID: 206
        Saving_Completed,
        /// <summary>
        /// Indicates that the zip archive has been created in a
        /// temporary location during a Save() operation.
        /// </summary>
        // Token: 0x040000CF RID: 207
        Saving_AfterSaveTempArchive,
        /// <summary>
        /// Indicates that the temporary file is about to be renamed to the final archive
        /// name during a Save() operation.
        /// </summary>
        // Token: 0x040000D0 RID: 208
        Saving_BeforeRenameTempArchive,
        /// <summary>
        /// Indicates that the temporary file is has just been renamed to the final archive
        /// name during a Save() operation.
        /// </summary>
        // Token: 0x040000D1 RID: 209
        Saving_AfterRenameTempArchive,
        /// <summary>
        /// Indicates that the self-extracting archive has been compiled
        /// during a Save() operation.
        /// </summary>
        // Token: 0x040000D2 RID: 210
        Saving_AfterCompileSelfExtractor,
        /// <summary>
        /// The given event is reporting the number of source bytes that have run through the compressor so far
        /// during a Save() operation.
        /// </summary>
        // Token: 0x040000D3 RID: 211
        Saving_EntryBytesRead,
        /// <summary>
        /// Indicates that an entry is about to be extracted.
        /// </summary>
        // Token: 0x040000D4 RID: 212
        Extracting_BeforeExtractEntry,
        /// <summary>
        /// Indicates that an entry has just been extracted.
        /// </summary>
        // Token: 0x040000D5 RID: 213
        Extracting_AfterExtractEntry,
        /// <summary>
        ///   Indicates that extraction of an entry would overwrite an existing
        ///   filesystem file. You must use
        ///   <see cref="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
        ///   ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
        ///   to <c>ZipEntry.Extract()</c> in order to receive this event.
        /// </summary>
        // Token: 0x040000D6 RID: 214
        Extracting_ExtractEntryWouldOverwrite,
        /// <summary>
        ///   The given event is reporting the number of bytes written so far for
        ///   the current entry during an Extract() operation.
        /// </summary>
        // Token: 0x040000D7 RID: 215
        Extracting_EntryBytesWritten,
        /// <summary>
        /// Indicates that an ExtractAll operation is about to begin.
        /// </summary>
        // Token: 0x040000D8 RID: 216
        Extracting_BeforeExtractAll,
        /// <summary>
        /// Indicates that an ExtractAll operation has completed.
        /// </summary>
        // Token: 0x040000D9 RID: 217
        Extracting_AfterExtractAll,
        /// <summary>
        /// Indicates that an error has occurred while saving a zip file.
        /// This generally means the file cannot be opened, because it has been
        /// removed, or because it is locked by another process.  It can also
        /// mean that the file cannot be Read, because of a range lock conflict.
        /// </summary>
        // Token: 0x040000DA RID: 218
        Error_Saving
    }
}


namespace Ionic.Zip
{
    // Token: 0x02000006 RID: 6
    internal class ZipSegmentedStream : Stream
    {
        // Token: 0x06000065 RID: 101 RVA: 0x0000350C File Offset: 0x0000170C
        private ZipSegmentedStream()
        {
            this._exceptionPending = false;
        }

        // Token: 0x06000066 RID: 102 RVA: 0x00003520 File Offset: 0x00001720
        public static ZipSegmentedStream ForReading(string name, uint initialDiskNumber, uint maxDiskNumber)
        {
            ZipSegmentedStream zss = new ZipSegmentedStream
            {
                rwMode = ZipSegmentedStream.RwMode.ReadOnly,
                CurrentSegment = initialDiskNumber,
                _maxDiskNumber = maxDiskNumber,
                _baseName = name
            };
            zss._SetReadStream();
            return zss;
        }

        // Token: 0x06000067 RID: 103 RVA: 0x00003560 File Offset: 0x00001760
        public static ZipSegmentedStream ForWriting(string name, int maxSegmentSize)
        {
            ZipSegmentedStream zss = new ZipSegmentedStream
            {
                rwMode = ZipSegmentedStream.RwMode.Write,
                CurrentSegment = 0u,
                _baseName = name,
                _maxSegmentSize = maxSegmentSize,
                _baseDir = Path.GetDirectoryName(name)
            };
            if (zss._baseDir == "")
            {
                zss._baseDir = ".";
            }
            zss._SetWriteStream(0u);
            return zss;
        }

        /// <summary>
        ///   Sort-of like a factory method, ForUpdate is used only when
        ///   the application needs to update the zip entry metadata for
        ///   a segmented zip file, when the starting segment is earlier
        ///   than the ending segment, for a particular entry.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     The update is always contiguous, never rolls over.  As a
        ///     result, this method doesn't need to return a ZSS; it can
        ///     simply return a FileStream.  That's why it's "sort of"
        ///     like a Factory method.
        ///   </para>
        ///   <para>
        ///     Caller must Close/Dispose the stream object returned by
        ///     this method.
        ///   </para>
        /// </remarks>
        // Token: 0x06000068 RID: 104 RVA: 0x000035D0 File Offset: 0x000017D0
        public static Stream ForUpdate(string name, uint diskNumber)
        {
            if (diskNumber >= 99u)
            {
                throw new ArgumentOutOfRangeException("diskNumber");
            }
            string fname = string.Format("{0}.z{1:D2}", Path.Combine(Path.GetDirectoryName(name), Path.GetFileNameWithoutExtension(name)), diskNumber + 1u);
            return File.Open(fname, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
        }

        // Token: 0x17000033 RID: 51
        // (get) Token: 0x06000069 RID: 105 RVA: 0x00003624 File Offset: 0x00001824
        // (set) Token: 0x0600006A RID: 106 RVA: 0x0000363B File Offset: 0x0000183B
        public bool ContiguousWrite { get; set; }

        // Token: 0x17000034 RID: 52
        // (get) Token: 0x0600006B RID: 107 RVA: 0x00003644 File Offset: 0x00001844
        // (set) Token: 0x0600006C RID: 108 RVA: 0x0000365C File Offset: 0x0000185C
        public uint CurrentSegment
        {
            get
            {
                return this._currentDiskNumber;
            }
            private set
            {
                this._currentDiskNumber = value;
                this._currentName = null;
            }
        }

        /// <summary>
        ///   Name of the filesystem file corresponding to the current segment.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     The name is not always the name currently being used in the
        ///     filesystem.  When rwMode is RwMode.Write, the filesystem file has a
        ///     temporary name until the stream is closed or until the next segment is
        ///     started.
        ///   </para>
        /// </remarks>
        // Token: 0x17000035 RID: 53
        // (get) Token: 0x0600006D RID: 109 RVA: 0x00003670 File Offset: 0x00001870
        public string CurrentName
        {
            get
            {
                if (this._currentName == null)
                {
                    this._currentName = this._NameForSegment(this.CurrentSegment);
                }
                return this._currentName;
            }
        }

        // Token: 0x17000036 RID: 54
        // (get) Token: 0x0600006E RID: 110 RVA: 0x000036AC File Offset: 0x000018AC
        public string CurrentTempName
        {
            get
            {
                return this._currentTempName;
            }
        }

        // Token: 0x0600006F RID: 111 RVA: 0x000036C4 File Offset: 0x000018C4
        private string _NameForSegment(uint diskNumber)
        {
            if (diskNumber >= 99u)
            {
                this._exceptionPending = true;
                throw new OverflowException("The number of zip segments would exceed 99.");
            }
            return string.Format("{0}.z{1:D2}", Path.Combine(Path.GetDirectoryName(this._baseName), Path.GetFileNameWithoutExtension(this._baseName)), diskNumber + 1u);
        }

        // Token: 0x06000070 RID: 112 RVA: 0x00003720 File Offset: 0x00001920
        public uint ComputeSegment(int length)
        {
            uint result;
            if (this._innerStream.Position + (long)length > (long)this._maxSegmentSize)
            {
                result = this.CurrentSegment + 1u;
            }
            else
            {
                result = this.CurrentSegment;
            }
            return result;
        }

        // Token: 0x06000071 RID: 113 RVA: 0x00003764 File Offset: 0x00001964
        public override string ToString()
        {
            return string.Format("{0}[{1}][{2}], pos=0x{3:X})", new object[]
            {
                "ZipSegmentedStream",
                this.CurrentName,
                this.rwMode.ToString(),
                this.Position
            });
        }

        // Token: 0x06000072 RID: 114 RVA: 0x000037BC File Offset: 0x000019BC
        private void _SetReadStream()
        {
            if (this._innerStream != null)
            {
                this._innerStream.Dispose();
            }
            if (this.CurrentSegment + 1u == this._maxDiskNumber)
            {
                this._currentName = this._baseName;
            }
            this._innerStream = File.OpenRead(this.CurrentName);
        }

        /// <summary>
        /// Read from the stream
        /// </summary>
        /// <param name="buffer">the buffer to read</param>
        /// <param name="offset">the offset at which to start</param>
        /// <param name="count">the number of bytes to read</param>
        /// <returns>the number of bytes actually read</returns>
        // Token: 0x06000073 RID: 115 RVA: 0x0000381C File Offset: 0x00001A1C
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (this.rwMode != ZipSegmentedStream.RwMode.ReadOnly)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("Stream Error: Cannot Read.");
            }
            int r = this._innerStream.Read(buffer, offset, count);
            int r2 = r;
            while (r2 != count)
            {
                if (this._innerStream.Position != this._innerStream.Length)
                {
                    this._exceptionPending = true;
                    throw new ZipException(string.Format("Read error in file {0}", this.CurrentName));
                }
                if (this.CurrentSegment + 1u == this._maxDiskNumber)
                {
                    return r;
                }
                this.CurrentSegment += 1u;
                this._SetReadStream();
                offset += r2;
                count -= r2;
                r2 = this._innerStream.Read(buffer, offset, count);
                r += r2;
            }
            return r;
        }

        // Token: 0x06000074 RID: 116 RVA: 0x00003900 File Offset: 0x00001B00
        private void _SetWriteStream(uint increment)
        {
            if (this._innerStream != null)
            {
                this._innerStream.Dispose();
                if (File.Exists(this.CurrentName))
                {
                    File.Delete(this.CurrentName);
                }
                File.Move(this._currentTempName, this.CurrentName);
            }
            if (increment > 0u)
            {
                this.CurrentSegment += increment;
            }
            SharedUtilities.CreateAndOpenUniqueTempFile(this._baseDir, out this._innerStream, out this._currentTempName);
            if (this.CurrentSegment == 0u)
            {
                this._innerStream.Write(BitConverter.GetBytes(134695760), 0, 4);
            }
        }

        /// <summary>
        /// Write to the stream.
        /// </summary>
        /// <param name="buffer">the buffer from which to write</param>
        /// <param name="offset">the offset at which to start writing</param>
        /// <param name="count">the number of bytes to write</param>
        // Token: 0x06000075 RID: 117 RVA: 0x000039B4 File Offset: 0x00001BB4
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (this.rwMode != ZipSegmentedStream.RwMode.Write)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException("Stream Error: Cannot Write.");
            }
            if (this.ContiguousWrite)
            {
                if (this._innerStream.Position + (long)count > (long)this._maxSegmentSize)
                {
                    this._SetWriteStream(1u);
                }
            }
            else
            {
                while (this._innerStream.Position + (long)count > (long)this._maxSegmentSize)
                {
                    int c = this._maxSegmentSize - (int)this._innerStream.Position;
                    this._innerStream.Write(buffer, offset, c);
                    this._SetWriteStream(1u);
                    count -= c;
                    offset += c;
                }
            }
            this._innerStream.Write(buffer, offset, count);
        }

        // Token: 0x06000076 RID: 118 RVA: 0x00003A80 File Offset: 0x00001C80
        public long TruncateBackward(uint diskNumber, long offset)
        {
            if (diskNumber >= 99u)
            {
                throw new ArgumentOutOfRangeException("diskNumber");
            }
            if (this.rwMode != ZipSegmentedStream.RwMode.Write)
            {
                this._exceptionPending = true;
                throw new ZipException("bad state.");
            }
            long result;
            if (diskNumber == this.CurrentSegment)
            {
                long x = this._innerStream.Seek(offset, SeekOrigin.Begin);
                result = x;
            }
            else
            {
                if (this._innerStream != null)
                {
                    this._innerStream.Dispose();
                    if (File.Exists(this._currentTempName))
                    {
                        File.Delete(this._currentTempName);
                    }
                }
                for (uint i = this.CurrentSegment - 1u; i > diskNumber; i -= 1u)
                {
                    string s = this._NameForSegment(i);
                    if (File.Exists(s))
                    {
                        File.Delete(s);
                    }
                }
                this.CurrentSegment = diskNumber;
                for (int j = 0; j < 3; j++)
                {
                    try
                    {
                        this._currentTempName = SharedUtilities.InternalGetTempFileName();
                        File.Move(this.CurrentName, this._currentTempName);
                        break;
                    }
                    catch (IOException)
                    {
                        if (j == 2)
                        {
                            throw;
                        }
                    }
                }
                this._innerStream = new FileStream(this._currentTempName, FileMode.Open);
                long r = this._innerStream.Seek(offset, SeekOrigin.Begin);
                result = r;
            }
            return result;
        }

        // Token: 0x17000037 RID: 55
        // (get) Token: 0x06000077 RID: 119 RVA: 0x00003BF0 File Offset: 0x00001DF0
        public override bool CanRead
        {
            get
            {
                return this.rwMode == ZipSegmentedStream.RwMode.ReadOnly && this._innerStream != null && this._innerStream.CanRead;
            }
        }

        // Token: 0x17000038 RID: 56
        // (get) Token: 0x06000078 RID: 120 RVA: 0x00003C24 File Offset: 0x00001E24
        public override bool CanSeek
        {
            get
            {
                return this._innerStream != null && this._innerStream.CanSeek;
            }
        }

        // Token: 0x17000039 RID: 57
        // (get) Token: 0x06000079 RID: 121 RVA: 0x00003C4C File Offset: 0x00001E4C
        public override bool CanWrite
        {
            get
            {
                return this.rwMode == ZipSegmentedStream.RwMode.Write && this._innerStream != null && this._innerStream.CanWrite;
            }
        }

        // Token: 0x0600007A RID: 122 RVA: 0x00003C7D File Offset: 0x00001E7D
        public override void Flush()
        {
            this._innerStream.Flush();
        }

        // Token: 0x1700003A RID: 58
        // (get) Token: 0x0600007B RID: 123 RVA: 0x00003C8C File Offset: 0x00001E8C
        public override long Length
        {
            get
            {
                return this._innerStream.Length;
            }
        }

        // Token: 0x1700003B RID: 59
        // (get) Token: 0x0600007C RID: 124 RVA: 0x00003CAC File Offset: 0x00001EAC
        // (set) Token: 0x0600007D RID: 125 RVA: 0x00003CC9 File Offset: 0x00001EC9
        public override long Position
        {
            get
            {
                return this._innerStream.Position;
            }
            set
            {
                this._innerStream.Position = value;
            }
        }

        // Token: 0x0600007E RID: 126 RVA: 0x00003CDC File Offset: 0x00001EDC
        public override long Seek(long offset, SeekOrigin origin)
        {
            return this._innerStream.Seek(offset, origin);
        }

        // Token: 0x0600007F RID: 127 RVA: 0x00003D00 File Offset: 0x00001F00
        public override void SetLength(long value)
        {
            if (this.rwMode != ZipSegmentedStream.RwMode.Write)
            {
                this._exceptionPending = true;
                throw new InvalidOperationException();
            }
            this._innerStream.SetLength(value);
        }

        // Token: 0x06000080 RID: 128 RVA: 0x00003D38 File Offset: 0x00001F38
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (this._innerStream != null)
                {
                    this._innerStream.Dispose();
                    if (this.rwMode == ZipSegmentedStream.RwMode.Write)
                    {
                        if (this._exceptionPending)
                        {
                        }
                    }
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        // Token: 0x0400003A RID: 58
        private ZipSegmentedStream.RwMode rwMode;

        // Token: 0x0400003B RID: 59
        private bool _exceptionPending;

        // Token: 0x0400003C RID: 60
        private string _baseName;

        // Token: 0x0400003D RID: 61
        private string _baseDir;

        // Token: 0x0400003E RID: 62
        private string _currentName;

        // Token: 0x0400003F RID: 63
        private string _currentTempName;

        // Token: 0x04000040 RID: 64
        private uint _currentDiskNumber;

        // Token: 0x04000041 RID: 65
        private uint _maxDiskNumber;

        // Token: 0x04000042 RID: 66
        private int _maxSegmentSize;

        // Token: 0x04000043 RID: 67
        private Stream _innerStream;

        // Token: 0x02000007 RID: 7
        private enum RwMode
        {
            // Token: 0x04000046 RID: 70
            None,
            // Token: 0x04000047 RID: 71
            ReadOnly,
            // Token: 0x04000048 RID: 72
            Write
        }
    }
}
